
================================================================================
 FILE: App.tsx  (36 lines)
================================================================================

import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Layout } from "./components/Layout";
import { HomePage } from "./pages/HomePage";
import { ArchitecturePage } from "./pages/ArchitecturePage";
import { SparsityPage } from "./pages/SparsityPage";
import { GraphPage } from "./pages/GraphPage";
import { MonosemanticityPage } from "./pages/MonosemanticityPage";
import { HebbianPage } from "./pages/HebbianPage";
import { MergePage } from "./pages/MergePage";
import { FindingsPage } from "./pages/FindingsPage";
import { LearnBDHPage } from "./pages/LearnBDHPage";
import { GraphTest } from "./pages/GraphTest";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Diagnostic route — remove after testing */}
        <Route path="/graph-test" element={<GraphTest />} />
        <Route path="/" element={<Layout />}>
          <Route index element={<HomePage />} />
          <Route path="architecture" element={<ArchitecturePage />} />
          <Route path="sparsity" element={<SparsityPage />} />
          <Route path="graph" element={<GraphPage />} />
          <Route path="monosemanticity" element={<MonosemanticityPage />} />
          <Route path="hebbian" element={<HebbianPage />} />
          <Route path="merge" element={<MergePage />} />
          <Route path="findings" element={<FindingsPage />} />
          <Route path="learn" element={<LearnBDHPage />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

export default App;


================================================================================
 FILE: pages\index.ts  (9 lines)
================================================================================

export { HomePage } from "./HomePage";
export { ArchitecturePage } from "./ArchitecturePage";
export { SparsityPage } from "./SparsityPage";
export { GraphPage } from "./GraphPage";
export { MonosemanticityPage } from "./MonosemanticityPage";
export { HebbianPage } from "./HebbianPage";
export { MergePage } from "./MergePage";
export { FindingsPage } from "./FindingsPage";
export { LearnBDHPage } from "./LearnBDHPage";


================================================================================
 FILE: utils\index.ts  (2 lines)
================================================================================

export * from './api'
export * from './helpers'


================================================================================
 FILE: utils\helpers.ts  (101 lines)
================================================================================

import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

// Merge Tailwind classes
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Format numbers with commas
export function formatNumber(num: number): string {
  return num.toLocaleString()
}

// Format percentage
export function formatPercent(num: number, decimals = 1): string {
  return `${(num * 100).toFixed(decimals)}%`
}

// Format bytes to human readable
export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`
}

// Debounce function
export function debounce<T extends (...args: unknown[]) => unknown>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout>
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => fn(...args), delay)
  }
}

// Throttle function
export function throttle<T extends (...args: unknown[]) => unknown>(
  fn: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle = false
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      fn(...args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}

// Generate color from string (for consistent colors)
export function stringToColor(str: string): string {
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash)
  }
  const hue = hash % 360
  return `hsl(${hue}, 70%, 60%)`
}

// Interpolate between two colors
export function interpolateColor(color1: string, color2: string, factor: number): string {
  const hex = (c: string) => parseInt(c, 16)
  const r1 = hex(color1.slice(1, 3))
  const g1 = hex(color1.slice(3, 5))
  const b1 = hex(color1.slice(5, 7))
  const r2 = hex(color2.slice(1, 3))
  const g2 = hex(color2.slice(3, 5))
  const b2 = hex(color2.slice(5, 7))
  
  const r = Math.round(r1 + (r2 - r1) * factor)
  const g = Math.round(g1 + (g2 - g1) * factor)
  const b = Math.round(b1 + (b2 - b1) * factor)
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
}

// Decode UTF-8 bytes to string
export function bytesToString(bytes: number[]): string {
  return new TextDecoder().decode(new Uint8Array(bytes))
}

// Encode string to UTF-8 bytes
export function stringToBytes(str: string): number[] {
  return Array.from(new TextEncoder().encode(str))
}

// Safe character display (for non-printable chars)
export function safeChar(byte: number): string {
  if (byte >= 32 && byte < 127) {
    return String.fromCharCode(byte)
  }
  if (byte === 32) return '␣'
  if (byte === 10) return '↵'
  if (byte === 9) return '→'
  return `\\x${byte.toString(16).padStart(2, '0')}`
}


================================================================================
 FILE: utils\api.ts  (192 lines)
================================================================================

import axios from "axios";

const API_BASE = "/api";

export const api = axios.create({
  baseURL: API_BASE,
  timeout: 30000,
});

/* ------------------------------------------------------------------ */
/*  Backend connection status (reactive)                               */
/* ------------------------------------------------------------------ */
type StatusListener = (connected: boolean) => void;
const _listeners = new Set<StatusListener>();
let _backendConnected = false;

export function onBackendStatus(fn: StatusListener) {
  _listeners.add(fn);
  fn(_backendConnected); // notify immediately with current state
  return () => _listeners.delete(fn);
}
export function isBackendConnected() {
  return _backendConnected;
}
function _setConnected(v: boolean) {
  if (v !== _backendConnected) {
    _backendConnected = v;
    _listeners.forEach((fn) => fn(v));
  }
}

// Health-check poller — runs every 5 s, marks backend up/down
let _polling = false;
export function startHealthPoll() {
  if (_polling) return;
  _polling = true;
  const poll = async () => {
    try {
      await axios.get("/health", { timeout: 4000 });
      _setConnected(true);
    } catch {
      _setConnected(false);
    }
  };
  poll(); // immediate first check
  setInterval(poll, 5000);
}

// Axios interceptor — update status on every response / error
api.interceptors.response.use(
  (res) => {
    _setConnected(true);
    return res;
  },
  (err) => {
    if (!err.response) {
      // Network error (ECONNREFUSED, timeout, etc.)
      _setConnected(false);
    }
    return Promise.reject(err);
  },
);

// Inference endpoints
export const inference = {
  run: (text: string, modelName = "french") =>
    api.post("/inference/run", { text, model_name: modelName }),

  generate: (prompt: string, modelName = "french", maxTokens = 50) =>
    api.post("/inference/generate", {
      prompt,
      model_name: modelName,
      max_tokens: maxTokens,
    }),

  extractDetailed: (text: string, modelName = "french") =>
    api.post("/inference/extract-detailed", { text, model_name: modelName }),
};

// Analysis endpoints
export const analysis = {
  sparsity: (texts: string[], modelName = "french") =>
    api.post("/analysis/sparsity", { texts, model_name: modelName }),

  probeConcept: (
    conceptName: string,
    examples: string[],
    modelName = "french",
  ) =>
    api.post("/analysis/probe-concept", {
      concept_name: conceptName,
      examples,
      model_name: modelName,
    }),

  neuronFingerprint: (
    conceptName: string,
    words: string[],
    modelName = "french",
  ) =>
    api.post("/analysis/neuron-fingerprint", {
      concept_name: conceptName,
      examples: words,
      model_name: modelName,
    }),

  compare: (text: string, modelNames: string[]) =>
    api.post("/analysis/compare", { text, model_names: modelNames }),

  getConceptCategories: () => api.get("/analysis/concept-categories"),

  /**
   * Live synapse tracking: send a sentence through the model and get
   * token-by-token x_sparse activations for specified neurons.
   */
  synapseTrack: (
    sentence: string,
    synapses: { layer: number; head: number; neuron: number }[],
    modelName = "french",
  ) =>
    api.post("/analysis/synapse-track", {
      sentence,
      synapses,
      model_name: modelName,
    }),
};

// Model endpoints
export const models = {
  list: () => api.get("/models/list"),

  getInfo: (modelName: string) => api.get(`/models/${modelName}`),

  load: (modelName: string, checkpointPath?: string) =>
    api.post("/models/load", {
      model_name: modelName,
      checkpoint_path: checkpointPath,
    }),

  unload: (modelName: string) => api.post(`/models/${modelName}/unload`),

  getGraph: (modelName: string, threshold = 0.01) =>
    api.get(`/models/${modelName}/graph`, { params: { threshold } }),
};

// Visualization endpoints
export const visualization = {
  playback: (text: string, modelName = "french", includeAttention = false) =>
    api.post("/visualization/playback", {
      text,
      model_name: modelName,
      include_attention: includeAttention,
    }),

  hebbianTrack: (text: string, modelName = "french") =>
    api.post("/visualization/hebbian-track", { text, model_name: modelName }),

  getArchitectureSpec: () => api.get("/visualization/architecture-spec"),

  getColorScheme: () => api.get("/visualization/color-scheme"),
};

// Utility function to load playback from static JSON
export async function loadPlaybackJSON(filename: string) {
  const response = await fetch(`/playback/${filename}`);
  if (!response.ok) throw new Error(`Failed to load ${filename}`);
  return response.json();
}

// Health check (hits root /health, NOT /api/health)
export const health = () => axios.get("/health", { timeout: 4000 });

 // Graph Brain endpoints
export const graph = {
  getClusters: (modelName: string, head = 0, beta = 1.0, maxNodes = 400) =>
    api.get(`/graph/clusters/${modelName}`, {
      params: { head, beta, max_nodes: maxNodes },
      timeout: 60000,
    }),

  activate: (text: string, modelName = "french", head = 0, layer = -1) =>
    api.post("/graph/activate", {
      text,
      model_name: modelName,
      head,
      layer,
     }),

  clearCache: () => api.delete("/graph/cache"),
 };




================================================================================
 FILE: stores\playbackStore.ts  (611 lines)
================================================================================

import { create } from "zustand";

// Types for our data structures
interface TimelinePoint {
  iteration: number;
  checkpoint: string;
  file: string;
  sparsity: number;
  x_sparsity: number;
  y_sparsity: number;
  sparsity_by_layer: number[];
  graph_density: number;
  total_edges?: number;
  concepts_detected?: number;
}

interface EvolutionTimeline {
  timeline: TimelinePoint[];
  num_checkpoints: number;
  iterations: number[];
  metrics: string[];
}

interface KeyframeData {
  iteration: number;
  checkpoint: string;
  sparsity: {
    overall_sparsity: number;
    overall_x_sparsity: number;
    overall_y_sparsity: number;
    sparsity_by_layer: number[];
  };
  graph: {
    density: number;
    total_edges: number;
  };
  playback_preview?: {
    input_text: string;
    overall_sparsity: number;
    num_frames: number;
    frames: PlaybackFrame[];
  };
}

interface PlaybackFrame {
  token_idx: number;
  token_byte: number;
  token_char: string;
  layer: number;
  x_active: Array<{ indices: number[]; values: number[] }>;
  y_active: Array<{ indices: number[]; values: number[] }>;
  x_sparsity: number;
  y_sparsity: number;
  // Extended interpretability fields
  x_active_count?: number;
  y_active_count?: number;
  x_top_neurons?: Array<{ head: number; neuron: number; value: number }>;
  y_top_neurons?: Array<{ head: number; neuron: number; value: number }>;
  x_pre_relu?: {
    mean: number;
    std: number;
    max: number;
    min: number;
    positive_count: number;
    total: number;
  };
  y_pre_relu?: {
    mean: number;
    std: number;
    max: number;
    min: number;
    positive_count: number;
    total: number;
  };
  gating?: {
    x_only: number;
    y_only: number;
    both: number;
    survival_rate: number;
  };
  attention?: number[];
  attention_stats?: {
    top_attended: Array<{ token_idx: number; char: string; weight: number }>;
  };
  embedding?: {
    byte_value: number;
    norm: number;
    mean: number;
    std: number;
  };
}

interface ConceptEvolution {
  concepts: {
    [key: string]: Array<{
      iteration: number;
      avg_activation: number;
      consistent_neurons: number;
    }>;
  };
  available_concepts: string[];
}

interface Manifest {
  model_name: string;
  num_checkpoints: number;
  checkpoint_files: string[];
  config: {
    n_layer?: number;
    n_embd?: number;
    n_head?: number;
    n_neurons?: number;
  };
  has_full_checkpoints?: boolean;
}

// Store state
interface EvolutionState {
  // Data
  currentModel: "french" | "portuguese" | "merged";
  manifest: Manifest | null;
  timeline: EvolutionTimeline | null;
  keyframes: KeyframeData[];
  conceptEvolution: ConceptEvolution | null;

  // Current selection
  currentIteration: number;
  currentKeyframeIndex: number;
  isPlaying: boolean;
  playbackSpeed: number; // ms per frame

  // Loading state
  isLoading: boolean;
  loadingProgress: number;
  error: string | null;

  // Cached full checkpoint data
  loadedCheckpoints: { [key: string]: any };

  // Actions
  setModel: (model: "french" | "portuguese" | "merged") => Promise<void>;
  loadModelData: (model: string) => Promise<void>;
  setIteration: (iteration: number) => void;
  setKeyframeIndex: (index: number) => void;
  play: () => void;
  pause: () => void;
  togglePlay: () => void;
  nextKeyframe: () => void;
  prevKeyframe: () => void;
  setPlaybackSpeed: (speed: number) => void;
  loadFullCheckpoint: (checkpoint: string) => Promise<any>;

  // Computed
  getCurrentKeyframe: () => KeyframeData | null;
  getIterationData: (iteration: number) => TimelinePoint | null;
  getSparsityAtIteration: (iteration: number) => number;
  getClosestKeyframeIndex: (iteration: number) => number;
}

// Helper to fetch JSON
async function fetchJSON<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
  }
  return response.json();
}

export const useEvolutionStore = create<EvolutionState>((set, get) => ({
  // Initial state
  currentModel: "french",
  manifest: null,
  timeline: null,
  keyframes: [],
  conceptEvolution: null,
  currentIteration: 0,
  currentKeyframeIndex: 0,
  isPlaying: false,
  playbackSpeed: 500,
  isLoading: false,
  loadingProgress: 0,
  error: null,
  loadedCheckpoints: {},

  setModel: async (model) => {
    set({ currentModel: model });
    await get().loadModelData(model);
  },

  loadModelData: async (model) => {
    set({ isLoading: true, loadingProgress: 0, error: null });

    const basePath = `/playback/${model}`;

    try {
      // Load manifest first
      set({ loadingProgress: 10 });
      const manifest = await fetchJSON<Manifest>(`${basePath}/manifest.json`);
      set({ manifest, loadingProgress: 30 });

      // Load evolution timeline
      const timeline = await fetchJSON<EvolutionTimeline>(
        `${basePath}/evolution_timeline.json`,
      );
      set({ timeline, loadingProgress: 50 });

      // Load keyframe summary
      const keyframeSummary = await fetchJSON<{ keyframes: KeyframeData[] }>(
        `${basePath}/keyframe_summary.json`,
      );
      set({ keyframes: keyframeSummary.keyframes, loadingProgress: 70 });

      // Load concept evolution
      try {
        const concepts = await fetchJSON<ConceptEvolution>(
          `${basePath}/concept_evolution.json`,
        );
        set({ conceptEvolution: concepts, loadingProgress: 90 });
      } catch {
        // Concept evolution might not exist
        set({ conceptEvolution: null });
      }

      // Set initial iteration to the last one
      const lastIteration =
        timeline.iterations[timeline.iterations.length - 1] || 0;
      set({
        currentIteration: lastIteration,
        currentKeyframeIndex: keyframeSummary.keyframes.length - 1,
        loadingProgress: 100,
        isLoading: false,
      });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : "Unknown error",
        isLoading: false,
      });
    }
  },

  setIteration: (iteration) => {
    const { keyframes } = get();
    // Find closest keyframe
    let closestIndex = 0;
    let closestDist = Infinity;
    keyframes.forEach((kf, i) => {
      const dist = Math.abs(kf.iteration - iteration);
      if (dist < closestDist) {
        closestDist = dist;
        closestIndex = i;
      }
    });
    set({ currentIteration: iteration, currentKeyframeIndex: closestIndex });
  },

  setKeyframeIndex: (index) => {
    const { keyframes } = get();
    if (index >= 0 && index < keyframes.length) {
      set({
        currentKeyframeIndex: index,
        currentIteration: keyframes[index].iteration,
      });
    }
  },

  play: () => set({ isPlaying: true }),
  pause: () => set({ isPlaying: false }),
  togglePlay: () => set((state) => ({ isPlaying: !state.isPlaying })),

  nextKeyframe: () => {
    const { currentKeyframeIndex, keyframes } = get();
    if (currentKeyframeIndex < keyframes.length - 1) {
      get().setKeyframeIndex(currentKeyframeIndex + 1);
    }
  },

  prevKeyframe: () => {
    const { currentKeyframeIndex } = get();
    if (currentKeyframeIndex > 0) {
      get().setKeyframeIndex(currentKeyframeIndex - 1);
    }
  },

  setPlaybackSpeed: (speed) => set({ playbackSpeed: speed }),

  loadFullCheckpoint: async (checkpoint) => {
    const { currentModel, loadedCheckpoints } = get();

    // Return cached if available
    if (loadedCheckpoints[checkpoint]) {
      return loadedCheckpoints[checkpoint];
    }

    // Load from server
    const url = `/playback/${currentModel}/checkpoints/${checkpoint}.json`;
    try {
      const data = await fetchJSON(url);
      set((state) => ({
        loadedCheckpoints: { ...state.loadedCheckpoints, [checkpoint]: data },
      }));
      return data;
    } catch {
      // Try without checkpoints subdirectory
      const altUrl = `/playback/${currentModel}/${checkpoint}.json`;
      const data = await fetchJSON(altUrl);
      set((state) => ({
        loadedCheckpoints: { ...state.loadedCheckpoints, [checkpoint]: data },
      }));
      return data;
    }
  },

  getCurrentKeyframe: () => {
    const { keyframes, currentKeyframeIndex } = get();
    return keyframes[currentKeyframeIndex] || null;
  },

  getIterationData: (iteration) => {
    const { timeline } = get();
    if (!timeline) return null;
    return timeline.timeline.find((t) => t.iteration === iteration) || null;
  },

  getSparsityAtIteration: (iteration) => {
    const data = get().getIterationData(iteration);
    return data?.sparsity || 0;
  },

  getClosestKeyframeIndex: (iteration) => {
    const { keyframes } = get();
    let closest = 0;
    let minDist = Infinity;
    keyframes.forEach((kf, i) => {
      const dist = Math.abs(kf.iteration - iteration);
      if (dist < minDist) {
        minDist = dist;
        closest = i;
      }
    });
    return closest;
  },
}));

// ============================================================================
// ORIGINAL PLAYBACK STORE (for single checkpoint playback)
// ============================================================================

interface PlaybackData {
  input_text: string;
  input_tokens: number[];
  input_chars: string[];
  num_layers: number;
  num_heads: number;
  neurons_per_head: number;
  frames: PlaybackFrame[];
  overall_sparsity?: number;
  sparsity_by_layer?: number[];
  // Extended fields for interpretability
  embedding_dim?: number;
  total_neurons?: number;
  predictions?: Array<Array<{ byte: number; char: string; prob: number }>>;
}

interface PlaybackState {
  playbackData: PlaybackData | null;
  currentFrame: number;
  isLoading: boolean;
  loadingMessage: string;
  error: string | null;
  mode: "live" | "playback";
  currentModel: string;

  loadPlayback: (text: string, modelName?: string) => Promise<void>;
  loadFromCheckpoint: (
    model: string,
    checkpoint: string,
    exampleIdx?: number,
  ) => Promise<void>;
  setModel: (model: string) => void;
  setFrame: (frame: number) => void;
  nextFrame: () => void;
  prevFrame: () => void;
  reset: () => void;
}

export const usePlaybackStore = create<PlaybackState>((set, get) => ({
  playbackData: null,
  currentFrame: 0,
  isLoading: false,
  loadingMessage: "",
  error: null,
  mode: "playback",
  currentModel: "french",

  loadPlayback: async (text: string, modelName?: string) => {
    const model = modelName || get().currentModel;
    set({
      isLoading: true,
      error: null,
      loadingMessage: "Checking backend...",
    });

    // Quick health check first (2s timeout)
    try {
      const hc = await fetch("/api/status", {
        signal: AbortSignal.timeout(3000),
      });
      if (!hc.ok) {
        set({
          isLoading: false,
          loadingMessage: "",
          error:
            "Backend responded but API status check failed. Check server logs.",
        });
        return;
      }
      const status = await hc.json();
      if (!status.loaded_models || status.loaded_models.length === 0) {
        set({
          loadingMessage:
            "Backend is loading model... (first run may take longer)",
        });
      }
    } catch {
      set({
        isLoading: false,
        loadingMessage: "",
        error:
          "Cannot reach backend. Start the server with: uvicorn backend.main:app --reload --port 8000  (from the project root)",
      });
      return;
    }

    const MAX_RETRIES = 3;
    const TIMEOUT_MS = 120_000; // 120 seconds — model inference can be slow

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        // Update loading message
        if (attempt === 1) {
          set({
            loadingMessage: "Running model inference... (this may take 10-30s)",
          });
        } else {
          set({
            loadingMessage: `Retry ${attempt}/${MAX_RETRIES} — running inference...`,
          });
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

        const response = await fetch("/api/visualization/playback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text,
            model_name: model,
            include_attention: true,
          }),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          set({ loadingMessage: "Processing response..." });
          const data = await response.json();
          set({
            playbackData: data,
            currentFrame: 0,
            isLoading: false,
            loadingMessage: "",
            mode: "live",
            error: null,
          });
          return; // Success!
        } else {
          const errData = await response
            .json()
            .catch(() => ({ detail: "Unknown error" }));
          console.warn(`API error (attempt ${attempt}):`, errData);

          // Don't retry on 4xx client errors
          if (response.status >= 400 && response.status < 500) {
            set({
              isLoading: false,
              loadingMessage: "",
              error: `API Error: ${errData.detail || response.statusText}`,
            });
            return;
          }
          // Server errors — retry
          if (attempt < MAX_RETRIES) {
            const backoff = attempt * 2000;
            set({
              loadingMessage: `Server error — retrying in ${backoff / 1000}s...`,
            });
            await new Promise((r) => setTimeout(r, backoff));
            continue;
          }
          set({
            isLoading: false,
            loadingMessage: "",
            error: `Server error after ${MAX_RETRIES} attempts: ${errData.detail || response.statusText}`,
          });
          return;
        }
      } catch (err: any) {
        if (err?.name === "AbortError") {
          console.warn(`Request timed out (attempt ${attempt})`);
          if (attempt < MAX_RETRIES) {
            set({
              loadingMessage: `Timed out — retrying (${attempt + 1}/${MAX_RETRIES})...`,
            });
            continue;
          }
          set({
            isLoading: false,
            loadingMessage: "",
            error:
              "Request timed out after multiple attempts. Ensure the backend is running (uvicorn on port 8000) and the model checkpoint is loaded.",
          });
          return;
        } else {
          console.warn(`API not available (attempt ${attempt}):`, err);
          if (attempt < MAX_RETRIES) {
            const backoff = attempt * 2000;
            set({
              loadingMessage: `Backend unreachable — retrying in ${backoff / 1000}s...`,
            });
            await new Promise((r) => setTimeout(r, backoff));
            continue;
          }
          set({
            isLoading: false,
            loadingMessage: "",
            error:
              "Backend is offline. Start the server with: uvicorn backend.main:app --reload --port 8000  (from the project root)",
          });
          return;
        }
      }
    }

    set({ isLoading: false, loadingMessage: "" });
  },

  setModel: (model: string) => {
    set({ currentModel: model });
  },

  loadFromCheckpoint: async (
    model: string,
    checkpoint: string,
    exampleIdx: number = 0,
  ) => {
    set({ isLoading: true, error: null });

    try {
      const url = `/playback/${model}/${checkpoint}.json`;
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`Failed to load ${url}`);
      }

      const data = await response.json();

      // Extract playback data from checkpoint
      if (data.playback && data.playback[exampleIdx]) {
        set({
          playbackData: data.playback[exampleIdx].data,
          currentFrame: 0,
          isLoading: false,
          mode: "playback",
        });
      } else {
        throw new Error("No playback data in checkpoint");
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : "Unknown error",
        isLoading: false,
      });
    }
  },

  setFrame: (frame: number) => {
    const { playbackData } = get();
    if (!playbackData) return;
    const maxFrame = playbackData.frames.length - 1;
    set({ currentFrame: Math.max(0, Math.min(frame, maxFrame)) });
  },

  nextFrame: () => {
    const { playbackData, currentFrame } = get();
    if (!playbackData) return;
    const maxFrame = playbackData.frames.length - 1;
    set({ currentFrame: currentFrame < maxFrame ? currentFrame + 1 : 0 });
  },

  prevFrame: () => {
    const { playbackData, currentFrame } = get();
    if (!playbackData) return;
    const maxFrame = playbackData.frames.length - 1;
    set({ currentFrame: currentFrame > 0 ? currentFrame - 1 : maxFrame });
  },

  reset: () => set({ currentFrame: 0 }),
}));


================================================================================
 FILE: pages\HomePage.tsx  (505 lines)
================================================================================

import { useRef, useEffect, useCallback } from 'react';
import { NavLink } from 'react-router-dom';
import { motion } from 'framer-motion';
import {
  Cpu,
  BarChart3,
  Network,
  Brain,
  Zap,
  GitMerge,
  FileText,
  ArrowRight,
  BookOpen,
} from 'lucide-react';
import { spring, fadeUp, scaleUp, stagger, cardInteraction } from '../utils/motion';

/* ═══════════════════════════════════════════════════════════════
   WIREFRAME TERRAIN — full-bleed green mesh hills
   ═══════════════════════════════════════════════════════════════ */
function WireframeTerrain() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animRef = useRef(0);
  const timeRef = useRef(0);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    if (w === 0 || h === 0) { animRef.current = requestAnimationFrame(draw); return; }
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, w, h);

    timeRef.current += 0.003;
    const t = timeRef.current;

    const cols = 100;
    const rows = 55;
    const cellW = (w + 40) / cols;
    const cellH = h / rows;
    const startX = -20;

    const getH = (gx: number, gz: number) => {
      const nx = gx / cols;
      const nz = gz / rows;
      const s1 = Math.sin(gx * 0.06 + t * 0.8) * Math.cos(gz * 0.045 + t * 0.5) * 55;
      const s2 = Math.sin(gx * 0.13 + t * 1.2) * Math.sin(gz * 0.1 - t * 0.3) * 28;
      const s3 = Math.cos(gx * 0.025 - t * 0.6) * Math.sin(gz * 0.035 + t * 0.25) * 70;
      const envX = Math.sin(nx * Math.PI);
      const envZ = Math.pow(Math.sin(nz * Math.PI), 0.75);
      return (s1 + s2 + s3) * envX * envZ;
    };

    // Horizontal lines
    for (let z = 0; z < rows; z++) {
      const nz = z / rows;
      const alpha = 0.03 + nz * 0.32;
      ctx.beginPath();
      ctx.strokeStyle = `rgba(0,200,150,${alpha})`;
      ctx.lineWidth = 0.3 + nz * 0.5;
      for (let x = 0; x <= cols; x++) {
        const px = startX + x * cellW;
        const py = z * cellH + getH(x, z);
        if (x === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    // Vertical lines (thinner)
    for (let x = 0; x <= cols; x++) {
      ctx.beginPath();
      for (let z = 0; z < rows; z++) {
        const nz = z / rows;
        const px = startX + x * cellW;
        const py = z * cellH + getH(x, z);
        ctx.strokeStyle = `rgba(0,200,150,${0.015 + nz * 0.15})`;
        ctx.lineWidth = 0.2 + nz * 0.25;
        if (z === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    animRef.current = requestAnimationFrame(draw);
  }, []);

  useEffect(() => {
    animRef.current = requestAnimationFrame(draw);
    return () => cancelAnimationFrame(animRef.current);
  }, [draw]);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 w-full h-full"
      style={{ opacity: 0.7 }}
    />
  );
}

/* ═══════════════════════════════════════════════════════════════
   LIQUID BLOBS — floating, morphing orbs with spring feel
   ═══════════════════════════════════════════════════════════════ */
function LiquidBlobs() {
  return (
    <div className="absolute inset-0 overflow-hidden pointer-events-none">
      <motion.div
        className="absolute w-[600px] h-[600px] rounded-full"
        style={{
          background: 'radial-gradient(circle, rgba(0,200,150,0.10) 0%, transparent 70%)',
          filter: 'blur(80px)',
          top: '-10%',
          right: '-12%',
        }}
        animate={{ x: [0, 40, -25, 0], y: [0, 50, 15, 0], scale: [1, 1.08, 0.94, 1] }}
        transition={{ duration: 14, repeat: Infinity, ease: 'easeInOut' }}
      />
      <motion.div
        className="absolute w-[450px] h-[450px] rounded-full"
        style={{
          background: 'radial-gradient(circle, rgba(42,127,255,0.07) 0%, transparent 70%)',
          filter: 'blur(70px)',
          top: '35%',
          left: '-8%',
        }}
        animate={{ x: [0, -30, 20, 0], y: [0, -35, 25, 0], scale: [1, 0.92, 1.06, 1] }}
        transition={{ duration: 18, repeat: Infinity, ease: 'easeInOut' }}
      />
      <motion.div
        className="absolute w-[350px] h-[350px] rounded-full"
        style={{
          background: 'radial-gradient(circle, rgba(0,200,150,0.06) 0%, transparent 70%)',
          filter: 'blur(50px)',
          top: '60%',
          left: '45%',
        }}
        animate={{ x: [0, 35, -25, 0], y: [0, -25, 35, 0], scale: [1, 1.12, 0.88, 1] }}
        transition={{ duration: 20, repeat: Infinity, ease: 'easeInOut' }}
      />
    </div>
  );
}

/* ═══════════════════════════════════════════════════════════════
   DATA
   ═══════════════════════════════════════════════════════════════ */
const features = [
  { path: '/architecture', icon: Cpu, title: 'Structural View', desc: 'Animated data flow through every BDH layer', tag: 'Architecture' },
  { path: '/sparsity', icon: BarChart3, title: 'Sparsity View', desc: "Compare BDH's ~5% activation vs Transformer's ~95%", tag: 'Analysis' },
  { path: '/graph', icon: Network, title: 'Topology View', desc: '3D force-directed graph of neural connectivity', tag: 'Visualization' },
  { path: '/monosemanticity', icon: Brain, title: 'Concept View', desc: 'Discover synapses that encode specific concepts', tag: 'Analysis' },
  { path: '/hebbian', icon: Zap, title: 'Dynamics View', desc: 'Watch memory form in real-time during inference', tag: 'Live' },
  { path: '/merge', icon: GitMerge, title: 'Composition View', desc: 'Combine French + Portuguese into a polyglot', tag: 'Experiment' },
  { path: '/findings', icon: FileText, title: 'Findings', desc: 'Key results, metrics, and measurement methods', tag: 'Summary' },
  { path: '/learn', icon: BookOpen, title: 'Learn BDH', desc: 'Step-by-step architecture walkthrough', tag: 'Tutorial' },
];

const stats = [
  { value: '~5%', label: 'Neurons Active', sub: 'vs ~95% in transformers' },
  { value: 'O(T)', label: 'Attention', sub: 'linear, not quadratic' },
  { value: '∞', label: 'Context Length', sub: 'constant memory' },
  { value: '1:1', label: 'Synapse ≈ Concept', sub: 'monosemantic' },
];

const differentiators = [
  { title: 'Sparse by Design', text: "BDH achieves ~95% sparsity through ReLU after expanding to neuron space. Not regularization — it's architectural." },
  { title: 'Monosemantic Neurons', text: 'Individual synapses reliably encode specific concepts. Point to a synapse and say "this is the currency neuron."' },
  { title: 'Hebbian Learning', text: '"Neurons that fire together wire together" — BDH implements this during inference through co-activation, no backprop.' },
  { title: 'Composable Intelligence', text: 'Train specialists separately, merge freely. French + Portuguese → polyglot. Transformers cannot do this.' },
];

/* ═══════════════════════════════════════════════════════════════
   HOME PAGE
   ═══════════════════════════════════════════════════════════════ */
export function HomePage() {
  return (
    <div className="min-h-screen overflow-x-hidden" style={{ background: '#070D12' }}>

      {/* ═══ HERO ═══ */}
      <section className="relative h-screen min-h-[700px] flex flex-col items-center justify-center overflow-hidden">
        <WireframeTerrain />
        <LiquidBlobs />

        {/* Gradient scrims */}
        <div
          className="absolute inset-0 pointer-events-none"
          style={{
            background: `linear-gradient(to bottom,
              rgba(7,13,18,0.88) 0%,
              rgba(7,13,18,0.20) 28%,
              rgba(7,13,18,0.04) 48%,
              rgba(7,13,18,0.12) 72%,
              rgba(7,13,18,0.96) 100%
            )`,
          }}
        />

        {/* Content */}
        <motion.div
          className="relative z-10 text-center px-6 max-w-5xl mx-auto"
          initial="hidden"
          animate="visible"
          variants={stagger}
        >
          {/* Pill */}
          <motion.div
            custom={0}
            variants={fadeUp}
            className="inline-flex items-center gap-2 px-4 py-1.5 rounded-full text-sm mb-8"
            style={{
              background: 'rgba(0,200,150,0.06)',
              border: '1px solid rgba(0,200,150,0.15)',
              color: '#00C896',
            }}
          >
            <span className="w-1.5 h-1.5 rounded-full bg-[#00C896] animate-pulse" />
            KRITI 2026 &middot; AI Interpretability Challenge
          </motion.div>

          {/* Headline */}
          <motion.h1
            custom={1}
            variants={fadeUp}
            className="text-6xl sm:text-7xl md:text-8xl lg:text-[6.5rem] font-extrabold tracking-tight leading-[0.93] mb-7"
          >
            <span className="text-[#E2E8F0]">Explore </span>
            <span className="text-[#00C896]">BDH</span>
            <br />
            <span className="text-[#E2E8F0]">Interpretability</span>
          </motion.h1>

          {/* Subtitle */}
          <motion.p
            custom={2}
            variants={fadeUp}
            className="text-base sm:text-lg md:text-xl max-w-2xl mx-auto mb-10 leading-relaxed"
            style={{ color: '#8B95A5' }}
          >
            A biologically-inspired architecture where AI reasoning becomes{' '}
            <span className="text-[#E2E8F0] font-medium">visible and understandable</span>.
            From sparse activations to Hebbian learning — every neuron tells a story.
          </motion.p>

          {/* CTAs */}
          <motion.div custom={3} variants={fadeUp} className="flex items-center justify-center gap-4 mb-12">
            <NavLink
              to="/architecture"
              className="group inline-flex items-center gap-2 px-8 py-3.5 rounded-full font-semibold text-base transition-all duration-300"
              style={{
                background: '#00C896',
                color: '#070D12',
                boxShadow: '0 0 24px rgba(0,200,150,0.15)',
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.boxShadow = '0 0 48px rgba(0,200,150,0.35)';
                e.currentTarget.style.background = '#34D399';
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.boxShadow = '0 0 24px rgba(0,200,150,0.15)';
                e.currentTarget.style.background = '#00C896';
              }}
            >
              Start Exploring
              <ArrowRight size={18} className="transition-transform group-hover:translate-x-1" />
            </NavLink>
            <NavLink
              to="/learn"
              className="inline-flex items-center gap-2 px-8 py-3.5 rounded-full font-medium text-base transition-all duration-300 hover:bg-white/5"
              style={{
                border: '1px solid rgba(255,255,255,0.1)',
                color: '#E2E8F0',
              }}
            >
              Learn BDH
            </NavLink>
          </motion.div>

          {/* Feature pills */}
          <motion.div
            custom={4}
            variants={fadeUp}
            className="inline-flex items-center gap-4 px-6 py-3 rounded-full backdrop-blur-md"
            style={{
              background: 'rgba(255,255,255,0.02)',
              border: '1px solid rgba(255,255,255,0.06)',
            }}
          >
            {[
              { icon: '⚡', label: '~5% Active', accent: true },
              { icon: '🧠', label: 'Monosemantic', accent: false },
              { icon: '∑', label: 'O(T) Attention', accent: false },
            ].map((p, i) => (
              <span key={i} className="flex items-center gap-1.5 text-sm">
                <span>{p.icon}</span>
                <span style={{ color: p.accent ? '#00C896' : '#8B95A5', fontWeight: p.accent ? 500 : 400 }}>{p.label}</span>
                {i < 2 && <span className="ml-2" style={{ color: '#2D3748' }}>·</span>}
              </span>
            ))}
          </motion.div>
        </motion.div>

        {/* Scroll indicator */}
        <motion.div
          className="absolute bottom-8 left-1/2 -translate-x-1/2 z-10"
          animate={{ y: [0, 8, 0] }}
          transition={{ duration: 2.5, repeat: Infinity, ease: 'easeInOut' }}
        >
          <div className="w-5 h-9 rounded-full flex justify-center pt-1.5" style={{ border: '2px solid rgba(255,255,255,0.1)' }}>
            <motion.div
              className="w-1 h-2 rounded-full"
              style={{ background: 'rgba(255,255,255,0.2)' }}
              animate={{ opacity: [0.3, 1, 0.3] }}
              transition={{ duration: 2, repeat: Infinity }}
            />
          </div>
        </motion.div>
      </section>

      {/* ═══ STATS ═══ */}
      <motion.section
        className="py-16 px-8"
        style={{ borderTop: '1px solid rgba(255,255,255,0.04)', borderBottom: '1px solid rgba(255,255,255,0.04)' }}
        initial="hidden"
        whileInView="visible"
        viewport={{ once: true, margin: '-80px' }}
        variants={stagger}
      >
        <div className="max-w-5xl mx-auto grid grid-cols-2 md:grid-cols-4 gap-8">
          {stats.map((s, i) => (
            <motion.div key={s.label} custom={i} variants={fadeUp} className="text-center">
              <div className="text-3xl md:text-4xl font-bold text-[#E2E8F0] mb-1 tracking-tight">{s.value}</div>
              <div className="text-sm font-medium" style={{ color: '#8B95A5' }}>{s.label}</div>
              <div className="text-xs mt-0.5" style={{ color: '#4A5568' }}>{s.sub}</div>
            </motion.div>
          ))}
        </div>
      </motion.section>

      {/* ═══ FEATURES GRID ═══ */}
      <motion.section
        className="relative py-24 px-8 overflow-hidden"
        initial="hidden"
        whileInView="visible"
        viewport={{ once: true, margin: '-60px' }}
        variants={stagger}
      >
        {/* Ambient glow */}
        <div
          className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[700px] h-[700px] rounded-full pointer-events-none"
          style={{ background: 'radial-gradient(circle, rgba(0,200,150,0.03) 0%, transparent 70%)', filter: 'blur(80px)' }}
        />

        <div className="relative z-10 max-w-6xl mx-auto">
          <motion.h2 custom={0} variants={fadeUp} className="text-3xl md:text-5xl font-extrabold text-center mb-3 tracking-tight">
            <span className="text-[#E2E8F0]">Explore the </span>
            <span className="text-[#00C896]">Problem Space</span>
          </motion.h2>
          <motion.p custom={1} variants={fadeUp} className="text-center mb-14 text-sm" style={{ color: '#4A5568' }}>
            8 interactive lenses into the BDH neural system.
          </motion.p>

          <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
            {features.map((f, i) => (
              <motion.div key={f.path} custom={i + 2} variants={scaleUp}>
                <NavLink to={f.path} className="group relative block h-full">
                  <motion.div
                    className="relative p-5 h-full rounded-xl overflow-hidden transition-colors duration-300"
                    style={{
                      background: 'rgba(255,255,255,0.02)',
                      border: '1px solid rgba(255,255,255,0.06)',
                    }}
                    whileHover={{
                      y: -6,
                      borderColor: 'rgba(0,200,150,0.2)',
                      background: 'rgba(255,255,255,0.035)',
                      boxShadow: '0 12px 40px rgba(0,200,150,0.07)',
                    }}
                    whileTap={{ scale: 0.98 }}
                    transition={spring.snappy}
                  >
                    {/* Hover glow */}
                    <div
                      className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none"
                      style={{ background: 'radial-gradient(circle at 50% 0%, rgba(0,200,150,0.06) 0%, transparent 60%)' }}
                    />
                    <div className="relative z-10">
                      <div
                        className="w-10 h-10 rounded-lg flex items-center justify-center mb-8"
                        style={{ background: 'rgba(255,255,255,0.04)', border: '1px solid rgba(255,255,255,0.06)' }}
                      >
                        <f.icon size={18} className="text-[#4A5568] group-hover:text-[#00C896] transition-colors duration-300" />
                      </div>
                      <span className="text-[10px] uppercase tracking-widest block mb-1.5" style={{ color: '#4A5568' }}>{f.tag}</span>
                      <h3 className="text-base font-semibold text-[#E2E8F0] mb-1.5 tracking-tight">{f.title}</h3>
                      <p className="text-sm leading-relaxed mb-5" style={{ color: '#6B7280' }}>{f.desc}</p>
                      <ArrowRight size={14} className="text-[#2D3748] group-hover:text-[#6B7280] transition-all duration-300 group-hover:translate-x-1" />
                    </div>
                  </motion.div>
                </NavLink>
              </motion.div>
            ))}
          </div>
        </div>
      </motion.section>

      {/* ═══ DIFFERENTIATORS ═══ */}
      <motion.section
        className="py-24 px-8"
        initial="hidden"
        whileInView="visible"
        viewport={{ once: true, margin: '-60px' }}
        variants={stagger}
      >
        <div className="max-w-4xl mx-auto">
          <motion.h2 custom={0} variants={fadeUp} className="text-3xl md:text-5xl font-extrabold text-center mb-3 tracking-tight">
            <span className="text-[#E2E8F0]">What Makes BDH </span>
            <span className="text-[#00C896]">Different</span>
          </motion.h2>
          <motion.p custom={1} variants={fadeUp} className="text-center mb-16 text-sm" style={{ color: '#4A5568' }}>
            Not just another language model — a window into neural computation.
          </motion.p>

          <div className="space-y-4">
            {differentiators.map((d, i) => (
              <motion.div
                key={d.title}
                custom={i + 2}
                variants={fadeUp}
                className="group flex gap-5 p-5 rounded-xl transition-all duration-400"
                style={{
                  background: 'rgba(255,255,255,0.015)',
                  border: '1px solid rgba(255,255,255,0.05)',
                }}
                whileHover={{
                  borderColor: 'rgba(0,200,150,0.15)',
                  background: 'rgba(255,255,255,0.025)',
                }}
                transition={spring.snappy}
              >
                <div
                  className="shrink-0 w-9 h-9 rounded-lg flex items-center justify-center font-mono text-sm font-semibold"
                  style={{ background: 'rgba(0,200,150,0.08)', color: '#00C896', border: '1px solid rgba(0,200,150,0.12)' }}
                >
                  {i + 1}
                </div>
                <div>
                  <h3 className="text-base font-semibold text-[#E2E8F0] mb-1 tracking-tight">{d.title}</h3>
                  <p className="text-sm leading-relaxed" style={{ color: '#6B7280' }}>{d.text}</p>
                </div>
              </motion.div>
            ))}
          </div>
        </div>
      </motion.section>

      {/* ═══ CTA FOOTER ═══ */}
      <section className="relative py-32 px-8 overflow-hidden">
        <div className="absolute inset-0 pointer-events-none" style={{
          background: 'radial-gradient(ellipse 60% 40% at 50% 50%, rgba(0,200,150,0.05) 0%, transparent 70%)',
        }} />

        <motion.div
          className="relative z-10 max-w-2xl mx-auto text-center"
          initial="hidden"
          whileInView="visible"
          viewport={{ once: true }}
          variants={stagger}
        >
          <motion.h2 custom={0} variants={fadeUp} className="text-4xl md:text-6xl font-extrabold tracking-tight mb-5">
            <span className="text-[#E2E8F0]">Start your </span>
            <span className="text-[#00C896]">BDH journey</span>
          </motion.h2>
          <motion.p custom={1} variants={fadeUp} className="mb-10 text-base" style={{ color: '#6B7280' }}>
            Dive into the architecture. See every neuron. Understand every gate.
          </motion.p>
          <motion.div custom={2} variants={fadeUp}>
            <NavLink
              to="/architecture"
              className="group inline-flex items-center gap-2 px-10 py-4 rounded-full font-semibold text-lg transition-all duration-300"
              style={{
                background: '#E2E8F0',
                color: '#070D12',
                boxShadow: '0 0 30px rgba(226,232,240,0.06)',
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.boxShadow = '0 0 50px rgba(226,232,240,0.15)';
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.boxShadow = '0 0 30px rgba(226,232,240,0.06)';
              }}
            >
              Explore Architecture
              <ArrowRight size={20} className="transition-transform group-hover:translate-x-1" />
            </NavLink>
          </motion.div>
        </motion.div>
      </section>
    </div>
  );
}


================================================================================
 FILE: pages\SparsityPage.tsx  (303 lines)
================================================================================

import { useState } from "react";
import { motion } from "framer-motion";
import { BarChart3, Zap, RefreshCw, AlertCircle } from "lucide-react";

export function SparsityPage() {
  const [inputText, setInputText] = useState(
    "The European Parliament adopted the resolution.",
  );
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLiveMode, setIsLiveMode] = useState(false);
  const [comparisonData, setComparisonData] = useState<{
    bdh: { sparsity: number; activeNeurons: number; totalNeurons: number };
    transformer: {
      sparsity: number;
      activeNeurons: number;
      totalNeurons: number;
    };
  } | null>(null);

  // Demo data fallback
  const demoData = {
    bdh: { sparsity: 0.947, activeNeurons: 1732, totalNeurons: 32768 },
    transformer: { sparsity: 0.05, activeNeurons: 31130, totalNeurons: 32768 },
  };

  const handleAnalyze = async () => {
    setIsLoading(true);
    setError(null);

    try {
      // Try API first
      const response = await fetch("/api/inference/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text: inputText,
          model_name: "french",
        }),
      });

      if (response.ok) {
        const data = await response.json();
        const totalNeurons =
          data.num_heads * data.neurons_per_head * data.num_layers;
        const activeNeurons = Math.round(
          totalNeurons * (1 - data.overall_sparsity),
        );

        setComparisonData({
          bdh: {
            sparsity: data.overall_sparsity,
            activeNeurons,
            totalNeurons,
          },
          // Transformer comparison (simulated - they don't have real sparsity)
          transformer: {
            sparsity: 0.05,
            activeNeurons: Math.round(totalNeurons * 0.95),
            totalNeurons,
          },
        });
        setIsLiveMode(true);
        setIsLoading(false);
        return;
      } else {
        const errData = await response.json().catch(() => ({}));
        setError(`API Error: ${errData.detail || response.statusText}`);
      }
    } catch (err) {
      setError("Backend offline - showing demo data");
    }

    // Fall back to demo data
    setComparisonData(demoData);
    setIsLiveMode(false);
    setIsLoading(false);
  };

  return (
    <div className="min-h-screen p-8" style={{ background: '#070D12' }}>
      {/* Error display */}
      {error && (
        <div className="mb-4 p-4 rounded-lg text-[#8B95A5] flex items-center gap-2 text-sm" style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.06)' }}>
          <AlertCircle size={16} />
          {error}
        </div>
      )}

      {/* Mode indicator */}
      {comparisonData && (
        <div className="mb-4 flex items-center gap-2">
          <span
            className={`px-2 py-1 rounded text-xs font-medium ${
              isLiveMode
                ? "text-[#00C896]"
                : "text-[#6B7280]"
            }`}
            style={{ background: 'rgba(255,255,255,0.03)', border: '1px solid rgba(255,255,255,0.06)' }}
          >
            {isLiveMode ? "Live API" : "Demo Mode"}
          </span>
        </div>
      )}

      <div className="mb-8">
        <h1 className="text-2xl font-bold mb-2 text-[#E2E8F0]">
          Sparse Brain <span className="text-[#00C896]">Comparator</span>
        </h1>
        <p className="text-[#8B95A5] text-sm">
          Compare BDH's ~5% activation rate with Transformer's ~95%.
        </p>
      </div>

      {/* Input */}
      <div className="card-interactive p-6 mb-8">
        <div className="flex gap-4">
          <input
            type="text"
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            placeholder="Enter text to compare..."
            className="input-field flex-1"
          />
          <button
            onClick={handleAnalyze}
            className="btn-primary flex items-center gap-2"
            disabled={isLoading}
          >
            {isLoading ? (
              <RefreshCw className="animate-spin" size={18} />
            ) : (
              <Zap size={18} />
            )}
            Analyze
          </button>
        </div>
      </div>

      {/* Comparison */}
      <div className="grid md:grid-cols-2 gap-8">
        {/* BDH */}
        <div className="card-interactive p-6">
          <div className="flex items-center gap-3 mb-6">
            <span className="text-xl">🐉</span>
            <div>
              <h2 className="text-lg font-semibold text-[#E2E8F0]">BDH</h2>
              <p className="text-[#6B7280] text-sm">Baby Dragon Hatchling</p>
            </div>
          </div>

          {/* Sparsity visualization */}
          <div className="mb-6">
            <div className="flex justify-between mb-2">
              <span className="text-[#8B95A5]">Sparsity</span>
              <span className="text-white font-bold">
                {comparisonData
                  ? `${(comparisonData.bdh.sparsity * 100).toFixed(1)}%`
                  : "--"}
              </span>
            </div>
            <div className="h-3 rounded overflow-hidden" style={{ background: 'rgba(255,255,255,0.06)' }}>
              <div
                className="h-full bg-[#00C896] rounded"
                style={{
                  width: comparisonData
                    ? `${comparisonData.bdh.sparsity * 100}%`
                    : "0%",
                  boxShadow: '0 0 8px rgba(0,200,150,0.4)',
                }}
              />
            </div>
          </div>

          {/* Neuron grid */}
          <div className="mb-4">
            <p className="text-[#6B7280] text-sm mb-2">
              Neuron activations (sample of 400)
            </p>
            <div className="grid grid-cols-20 gap-0.5">
              {Array.from({ length: 400 }).map((_, i) => (
                <div
                  key={i}
                  className="w-2 h-2 rounded-sm"
                  style={{
                    background: i <
                    (comparisonData
                      ? 400 * (1 - comparisonData.bdh.sparsity)
                      : 20)
                      ? '#00C896'
                      : 'rgba(255,255,255,0.04)',
                    boxShadow: i <
                    (comparisonData
                      ? 400 * (1 - comparisonData.bdh.sparsity)
                      : 20)
                      ? '0 0 4px rgba(0,200,150,0.5)'
                      : 'none',
                  }}
                />
              ))}
            </div>
          </div>

          <div className="text-center p-4 rounded-lg" style={{ background: 'rgba(255,255,255,0.02)' }}>
            <div className="text-2xl font-bold text-[#E2E8F0]">
              {comparisonData
                ? comparisonData.bdh.activeNeurons.toLocaleString()
                : "--"}
            </div>
            <div className="text-[#8B95A5] text-sm">active neurons</div>
            <div className="text-[#6B7280] text-xs mt-1">
              out of {comparisonData?.bdh.totalNeurons.toLocaleString() || "--"}
            </div>
          </div>
        </div>

        {/* Transformer */}
        <div className="card-interactive p-6">
          <div className="flex items-center gap-3 mb-6">
            <div className="w-10 h-10 rounded-lg flex items-center justify-center" style={{ background: 'rgba(255,255,255,0.04)' }}>
              <BarChart3 size={20} className="text-[#6B7280]" />
            </div>
            <div>
              <h2 className="text-lg font-semibold text-[#E2E8F0]">Transformer</h2>
              <p className="text-[#6B7280] text-sm">Standard architecture</p>
            </div>
          </div>

          {/* Sparsity visualization */}
          <div className="mb-6">
            <div className="flex justify-between mb-2">
              <span className="text-[#8B95A5]">Sparsity</span>
              <span className="text-[#E2E8F0] font-bold">
                {comparisonData
                  ? `${(comparisonData.transformer.sparsity * 100).toFixed(1)}%`
                  : "--"}
              </span>
            </div>
            <div className="h-3 rounded overflow-hidden" style={{ background: 'rgba(255,255,255,0.06)' }}>
              <div
                className="h-full bg-orange-500 rounded"
                style={{
                  width: comparisonData
                    ? `${comparisonData.transformer.sparsity * 100}%`
                    : "0%",
                }}
              />
            </div>
          </div>

          {/* Neuron grid */}
          <div className="mb-4">
            <p className="text-[#6B7280] text-sm mb-2">
              Neuron activations (sample of 400)
            </p>
            <div className="grid grid-cols-20 gap-0.5">
              {Array.from({ length: 400 }).map((_, i) => (
                <div
                  key={i}
                  className="w-2 h-2 rounded-sm"
                  style={{
                    background: i <
                    (comparisonData
                      ? 400 * (1 - comparisonData.transformer.sparsity)
                      : 380)
                      ? '#F97316'
                      : 'rgba(255,255,255,0.04)',
                  }}
                />
              ))}
            </div>
          </div>

          <div className="text-center p-4 rounded-lg" style={{ background: 'rgba(255,255,255,0.02)' }}>
            <div className="text-2xl font-bold text-[#E2E8F0]">
              {comparisonData
                ? comparisonData.transformer.activeNeurons.toLocaleString()
                : "--"}
            </div>
            <div className="text-[#8B95A5] text-sm">active neurons</div>
            <div className="text-[#6B7280] text-xs mt-1">
              out of{" "}
              {comparisonData?.transformer.totalNeurons.toLocaleString() ||
                "--"}
            </div>
          </div>
        </div>
      </div>

      {/* Insight */}
      <div className="mt-8 card-interactive p-6">
        <h3 className="text-lg font-semibold mb-4 text-[#E2E8F0]">Key Insight</h3>
        <p className="text-[#8B95A5] text-sm">
          BDH achieves ~95% sparsity through architectural design, not
          regularization. After projecting to neuron space (D→N), the ReLU
          activation naturally kills most signals. This means each active neuron
          carries meaningful, interpretable information — unlike transformers
          where the dense activations make interpretation nearly impossible.
        </p>
      </div>
    </div>
  );
}


================================================================================
 FILE: pages\ArchitecturePage.tsx  (593 lines)
================================================================================

import { useState, useEffect, useCallback, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Play,
  Pause,
  RotateCcw,
  Info,
  Zap,
  SkipForward,
  SkipBack,
  ChevronRight,
} from "lucide-react";
import { BDHArchitectureDiagram } from "@/features/architecture/BDHArchitectureDiagram";
import { usePlaybackStore } from "@/stores/playbackStore";

// Must match STEPS in BDHArchitectureDiagram
const NUM_ARCH_STEPS = 13; // 0..12
const STEP_DURATION = 2000; // ms per architecture step
const OUTPUT_DWELL = 500; // extra ms to hold on the final prediction step

export function ArchitecturePage() {
  const [inputText, setInputText] = useState("The capital of France is Paris");
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [showTooltips, setShowTooltips] = useState(true);

  // === Sequential animation state ===
  const [currentTokenIdx, setCurrentTokenIdx] = useState(0);
  const [currentStep, setCurrentStep] = useState(0);
  const [stepProgress, setStepProgress] = useState(0);
  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const stepStartRef = useRef<number>(0);

  const {
    playbackData,
    isLoading,
    loadingMessage,
    error,
    mode,
    loadPlayback,
    setFrame,
    reset,
  } = usePlaybackStore();

  // Total number of tokens
  const numTokens = playbackData?.input_chars?.length ?? 0;

  // Find frame index for a specific token and layer
  const findFrameIndex = useCallback(
    (tokenIdx: number, layer: number): number => {
      if (!playbackData) return 0;
      const idx = playbackData.frames.findIndex(
        (f) => f.token_idx === tokenIdx && f.layer === layer,
      );
      return idx >= 0 ? idx : 0;
    },
    [playbackData],
  );

  // Current frame data for display
  const currentFrameData = playbackData
    ? playbackData.frames[findFrameIndex(currentTokenIdx, currentLayer)]
    : undefined;

  // Sync store frame when token/layer changes
  useEffect(() => {
    if (!playbackData) return;
    const idx = findFrameIndex(currentTokenIdx, currentLayer);
    setFrame(idx);
  }, [currentTokenIdx, currentLayer, playbackData, findFrameIndex, setFrame]);

  // Load playback data on mount
  useEffect(() => {
    loadPlayback(inputText);
  }, []);

  // === Master animation timer ===
  useEffect(() => {
    if (!isPlaying || !playbackData) {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
      return;
    }

    stepStartRef.current = Date.now();
    setStepProgress(0);
    let dwelling = false;
    let dwellStart = 0;

    timerRef.current = setInterval(() => {
      // During dwell period, wait then advance
      if (dwelling) {
        if (Date.now() - dwellStart >= OUTPUT_DWELL) {
          dwelling = false;
          setCurrentTokenIdx((prevToken) => {
            const nextToken = prevToken + 1;
            if (nextToken >= numTokens) {
              setIsPlaying(false);
              return prevToken;
            }
            return nextToken;
          });
          setCurrentStep(0);
          stepStartRef.current = Date.now();
          setStepProgress(0);
        }
        return;
      }

      const elapsed = Date.now() - stepStartRef.current;
      const progress = Math.min(elapsed / STEP_DURATION, 1);
      setStepProgress(progress);

      if (progress >= 1) {
        // Step complete — advance
        setCurrentStep((prev) => {
          const nextStep = prev + 1;
          if (nextStep >= NUM_ARCH_STEPS) {
            // All steps done — enter dwell on output
            dwelling = true;
            dwellStart = Date.now();
            return prev; // stay on output step during dwell
          }
          stepStartRef.current = Date.now();
          setStepProgress(0);
          return nextStep;
        });
      }
    }, 30);

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [isPlaying, playbackData, numTokens]);

  const handleRun = () => {
    setIsPlaying(false);
    setCurrentTokenIdx(0);
    setCurrentStep(0);
    setStepProgress(0);
    reset();
    loadPlayback(inputText);
  };

  const handlePlayPause = () => {
    if (isPlaying) {
      setIsPlaying(false);
    } else {
      // If we finished all tokens, restart
      if (
        currentTokenIdx >= numTokens - 1 &&
        currentStep >= NUM_ARCH_STEPS - 1
      ) {
        setCurrentTokenIdx(0);
        setCurrentStep(0);
      }
      setIsPlaying(true);
    }
  };

  const handleReset = () => {
    setIsPlaying(false);
    setCurrentTokenIdx(0);
    setCurrentStep(0);
    setStepProgress(0);
  };

  const handleNextToken = () => {
    setIsPlaying(false);
    if (currentTokenIdx < numTokens - 1) {
      setCurrentTokenIdx((p) => p + 1);
      setCurrentStep(0);
      setStepProgress(0);
    }
  };

  const handlePrevToken = () => {
    setIsPlaying(false);
    if (currentTokenIdx > 0) {
      setCurrentTokenIdx((p) => p - 1);
      setCurrentStep(0);
      setStepProgress(0);
    }
  };

  const handleNextStep = () => {
    setIsPlaying(false);
    if (currentStep < NUM_ARCH_STEPS - 1) {
      setCurrentStep((p) => p + 1);
      setStepProgress(1);
    } else if (currentTokenIdx < numTokens - 1) {
      setCurrentTokenIdx((p) => p + 1);
      setCurrentStep(0);
      setStepProgress(0);
    }
  };

  const handleStepClick = (stepIdx: number) => {
    setIsPlaying(false);
    setCurrentStep(stepIdx);
    setStepProgress(1);
  };

  const handleTokenClick = (tokenIdx: number) => {
    setIsPlaying(false);
    setCurrentTokenIdx(tokenIdx);
    setCurrentStep(0);
    setStepProgress(0);
  };

  return (
    <div className="min-h-screen p-8" style={{ background: '#070D12' }}>
      {/* Loading overlay */}
      <AnimatePresence>
        {isLoading && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 flex items-center justify-center backdrop-blur-sm"
            style={{ background: 'rgba(7,13,18,0.85)' }}
          >
            <div className="flex flex-col items-center gap-4 max-w-md text-center">
              <div className="relative w-16 h-16">
                <div className="absolute inset-0 rounded-full border-4" style={{ borderColor: 'rgba(255,255,255,0.08)' }} />
                <div className="absolute inset-0 rounded-full border-4 border-t-[#00C896] border-r-transparent border-b-transparent border-l-transparent animate-spin" />
              </div>
              <p className="text-[#E2E8F0] text-sm font-medium">
                {loadingMessage || "Running inference on model..."}
              </p>
              <p className="text-[#6B7280] text-xs">
                The model processes each token through 8 layers with full
                activation extraction. This typically takes 10-30 seconds.
              </p>
              <LoadingTimer />
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Error display */}
      {error && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          className="mb-4 p-4 bg-red-500/20 border border-red-500/50 rounded-lg"
        >
          <div className="flex items-start justify-between gap-3">
            <div>
              <p className="text-red-300 font-medium mb-1">Inference Failed</p>
              <p className="text-red-400/80 text-sm">{error}</p>
            </div>
            <button
              onClick={handleRun}
              className="px-4 py-2 bg-red-500/30 hover:bg-red-500/50 text-red-200 rounded-lg text-sm font-medium transition-colors whitespace-nowrap"
            >
              Retry
            </button>
          </div>
        </motion.div>
      )}

      {/* Mode indicator */}
      {playbackData && mode === "live" && (
        <div className="mb-4 flex items-center gap-2">
          <span className="px-2 py-1 rounded text-xs font-medium bg-green-500/20 text-green-400 border border-green-500/50">
            Live API
          </span>
          <span className="text-xs text-[#4A5568]">
            Real model inference — {playbackData.frames.length} frames extracted
          </span>
        </div>
      )}

      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: -20, filter: 'blur(4px)' }}
        animate={{ opacity: 1, y: 0, filter: 'blur(0px)' }}
        transition={{ type: 'spring', stiffness: 120, damping: 18, mass: 0.9 }}
        className="mb-8"
      >
        <h1 className="text-3xl font-bold mb-2 text-[#E2E8F0]">
          Interactive <span className="text-[#00C896]">Architecture</span>
        </h1>
        <p className="text-[#8B95A5]">
          Explore BDH's data flow with animated visualizations. Watch how ~95%
          of paths go dark at the ReLU — that's sparsity in action.
        </p>
      </motion.div>

      {/* Input Section */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
        className="glass-card p-6 mb-6"
      >
        <div className="flex gap-4">
          <input
            type="text"
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            placeholder="Enter text to visualize..."
            className="input-field flex-1"
          />
          <button
            onClick={handleRun}
            disabled={isLoading}
            className="btn-primary disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isLoading ? (
              <>
                <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin mr-2" />
                Running...
              </>
            ) : (
              <>
                <Zap size={18} className="mr-2" />
                Run
              </>
            )}
          </button>
        </div>

        {playbackData && (
          <div className="mt-4 flex items-center gap-4">
            {/* Token display - click to select */}
            <div className="flex-1 flex flex-wrap gap-1">
              {playbackData.input_chars.map((char, idx) => (
                <motion.span
                  key={idx}
                  onClick={() => handleTokenClick(idx)}
                  className={`px-2 py-1 rounded font-mono text-sm cursor-pointer transition-all hover:ring-2 hover:ring-[#00C896]/40 ${
                    currentTokenIdx === idx
                      ? "text-[#070D12] font-semibold"
                      : idx < currentTokenIdx
                        ? "text-[#8B95A5]"
                        : "text-[#4A5568]"
                  }`}
                  style={{
                    background: currentTokenIdx === idx ? '#00C896' : idx < currentTokenIdx ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.03)',
                    boxShadow: currentTokenIdx === idx ? '0 0 16px rgba(0,200,150,0.3)' : 'none',
                  }}
                  initial={{ scale: 0.8 }}
                  animate={{ scale: 1 }}
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                  transition={{ delay: idx * 0.02 }}
                >
                  {char === " " ? "␣" : char}
                </motion.span>
              ))}
            </div>

            {/* Playback controls */}
            <div className="flex items-center gap-2">
              <button
                onClick={handlePrevToken}
                disabled={currentTokenIdx === 0}
                className="p-2 rounded-lg transition-all duration-200 disabled:opacity-30 hover:scale-105"
                style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.06)' }}
                title="Previous token"
              >
                <SkipBack size={18} />
              </button>
              <button
                onClick={handlePlayPause}
                className="p-2 rounded-lg transition-all duration-200 hover:scale-105"
                style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.06)' }}
                title={isPlaying ? "Pause" : "Play (step-by-step)"}
              >
                {isPlaying ? <Pause size={20} /> : <Play size={20} />}
              </button>
              <button
                onClick={handleNextStep}
                className="p-2 rounded-lg transition-all duration-200 hover:scale-105"
                style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.06)' }}
                title="Next step"
              >
                <ChevronRight size={20} />
              </button>
              <button
                onClick={handleNextToken}
                disabled={currentTokenIdx >= numTokens - 1}
                className="p-2 rounded-lg transition-all duration-200 disabled:opacity-30 hover:scale-105"
                style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.06)' }}
                title="Next token"
              >
                <SkipForward size={18} />
              </button>
              <button
                onClick={handleReset}
                className="p-2 rounded-lg transition-all duration-200 hover:scale-105"
                style={{ background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.06)' }}
                title="Reset"
              >
                <RotateCcw size={18} />
              </button>
            </div>
          </div>
        )}

        {/* Progress indicator */}
        {playbackData && (
          <div className="mt-3 flex items-center gap-3 text-xs text-[#6B7280]">
            <span>
              Token{" "}
              <span className="text-[#00C896] font-bold">
                {currentTokenIdx + 1}
              </span>
              /{numTokens}
            </span>
            <span className="text-[#2D3748]">|</span>
            <span>
              Step{" "}
              <span className="text-[#00C896] font-bold">
                {currentStep + 1}
              </span>
              /{NUM_ARCH_STEPS}
            </span>
            <span className="text-[#2D3748]">|</span>
            <span>
              Layer{" "}
              <span className="text-[#00C896] font-bold">
                {currentLayer + 1}
              </span>
            </span>
            <div className="flex-1" />
            {isPlaying && (
              <span className="text-green-400 flex items-center gap-1">
                <span className="w-2 h-2 rounded-full bg-green-400 animate-pulse" />
                Playing
              </span>
            )}
          </div>
        )}
      </motion.div>

      {/* Main Diagram */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.2 }}
        className="glass-card p-6 mb-6 overflow-x-auto"
      >
        <BDHArchitectureDiagram
          frameData={currentFrameData}
          playbackData={playbackData ?? undefined}
          currentLayer={currentLayer}
          isAnimating={isPlaying}
          currentStep={currentStep}
          onStepChange={handleStepClick}
        />
      </motion.div>

      {/* Layer selector */}
      {playbackData && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="glass-card p-6"
        >
          <h3 className="text-lg font-semibold mb-4">Layer Selection</h3>
          <div className="flex gap-2 flex-wrap">
            {Array.from({ length: playbackData.num_layers }, (_, i) => (
              <button
                key={i}
                onClick={() => {
                  setCurrentLayer(i);
                  setIsPlaying(false);
                }}
                className={`px-4 py-2 rounded-lg font-mono transition-all duration-200 ${
                  currentLayer === i
                    ? "text-[#070D12] font-semibold"
                    : "text-[#6B7280]"
                }`}
                style={{
                  background: currentLayer === i ? '#00C896' : 'rgba(255,255,255,0.04)',
                  boxShadow: currentLayer === i ? '0 0 20px rgba(0,200,150,0.25)' : 'none',
                  border: '1px solid ' + (currentLayer === i ? 'rgba(0,200,150,0.3)' : 'rgba(255,255,255,0.06)'),
                }}
              >
                L{i}
              </button>
            ))}
          </div>

          {/* Sparsity indicator */}
          {currentFrameData && (
            <div className="mt-4 grid grid-cols-2 gap-4">
              <div className="p-4 rounded-lg" style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.06)' }}>
                <div className="text-sm text-[#8B95A5] mb-1">X Sparsity</div>
                <div className="text-2xl font-bold text-[#00C896]">
                  {(currentFrameData.x_sparsity * 100).toFixed(1)}%
                </div>
                <div className="mt-2 h-2 rounded-full overflow-hidden" style={{ background: 'rgba(255,255,255,0.06)' }}>
                  <motion.div
                    className="h-full rounded-full"
                    style={{ background: '#00C896', boxShadow: '0 0 8px rgba(0,200,150,0.4)' }}
                    initial={{ width: 0 }}
                    animate={{ width: `${currentFrameData.x_sparsity * 100}%` }}
                    transition={{ type: 'spring', stiffness: 120, damping: 18 }}
                  />
                </div>
              </div>
              <div className="p-4 rounded-lg" style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.06)' }}>
                <div className="text-sm text-[#8B95A5] mb-1">Y Sparsity</div>
                <div className="text-2xl font-bold text-[#2A7FFF]">
                  {(currentFrameData.y_sparsity * 100).toFixed(1)}%
                </div>
                <div className="mt-2 h-2 rounded-full overflow-hidden" style={{ background: 'rgba(255,255,255,0.06)' }}>
                  <motion.div
                    className="h-full rounded-full"
                    style={{ background: '#2A7FFF', boxShadow: '0 0 8px rgba(42,127,255,0.4)' }}
                    initial={{ width: 0 }}
                    animate={{ width: `${currentFrameData.y_sparsity * 100}%` }}
                    transition={{ type: 'spring', stiffness: 120, damping: 18 }}
                  />
                </div>
              </div>
            </div>
          )}
        </motion.div>
      )}

      {/* Key Insights Panel */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.4 }}
        className="mt-6 glass-card p-6"
      >
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2 text-[#E2E8F0]">
          <Zap size={20} className="text-[#00C896]" />
          Key Insights
        </h3>
        <div className="grid md:grid-cols-2 gap-4">
          <InsightCard
            title="Sparsification at ReLU"
            description="Watch the yellow encoder path expand from D=256 to N=8192 dimensions, then ReLU kills ~95% of activations. The diagram literally shows paths going dark."
          />
          <InsightCard
            title="Linear Attention"
            description="The blue attention block computes ϱ += x^T v — a rank-1 update that's O(T) not O(T²). This is why BDH scales to unlimited context."
          />
          <InsightCard
            title="Hebbian State"
            description="The attention state ϱ accumulates co-activation patterns. This IS the Hebbian memory — neurons that fire together strengthen their connection."
          />
          <InsightCard
            title="Gating (x × y)"
            description="The element-wise multiplication of sparse x and y creates even sparser output. Only paths active in BOTH survive — biological-like signal gating."
          />
        </div>
      </motion.div>
    </div>
  );
}

function InsightCard({
  title,
  description,
}: {
  title: string;
  description: string;
}) {
  return (
    <div className="p-4 rounded-lg transition-all duration-300 hover:translate-y-[-2px]" style={{ background: 'rgba(255,255,255,0.02)', border: '1px solid rgba(255,255,255,0.06)' }}>
      <h4 className="font-medium text-[#00C896] mb-2">{title}</h4>
      <p className="text-sm text-[#8B95A5]">{description}</p>
    </div>
  );
}

/** Shows elapsed time during loading */
function LoadingTimer() {
  const [elapsed, setElapsed] = useState(0);
  useEffect(() => {
    const start = Date.now();
    const id = setInterval(
      () => setElapsed(Math.floor((Date.now() - start) / 1000)),
      500,
    );
    return () => clearInterval(id);
  }, []);
  return <p className="text-[#4A5568] text-xs font-mono">Elapsed: {elapsed}s</p>;
}


================================================================================
 FILE: pages\GraphPage.tsx  (977 lines)
================================================================================

import { useState, useEffect, useRef, useCallback, useMemo } from "react";
import {
  Play,
  Pause,
  RotateCcw,
  Loader2,
  AlertCircle,
  Send,
  Zap,
  Activity,
  Eye,
  ChevronDown,
  ChevronUp,
  Info,
  SkipForward,
  Square,
  Brain,
} from "lucide-react";
import ForceGraph3D from "react-force-graph-3d";
import * as THREE from "three";
import { api } from "../utils/api";

// ─── Types ─────────────────────────────────────────────────────────────
interface ClusterMeta {
  cluster_id: number;
  neuron_count: number;
  avg_out_degree: number;
  avg_in_degree: number;
  internal_edges: number;
  internal_weight: number;
  hub_neurons: Array<{ neuron: number; degree: number }>;
  label: string | null;
  label_confidence?: number;
  top_trigger_words?: string[];
}
interface ClusterData {
  n_neurons: number;
  n_display_nodes: number;
  n_display_edges: number;
  n_total_edges: number;
  num_clusters: number;
  modularity: number;
  beta: number;
  beta_effective?: number;
  nodes: Array<{
    id: number;
    cluster: number;
    degree: number;
    is_hub: boolean;
  }>;
  edges: Array<{
    source: number;
    target: number;
    weight: number;
    same_cluster: boolean;
  }>;
  clusters: ClusterMeta[];
  histogram: Array<{ x: number; y: number }>;
}
interface TokenAct {
  token_idx: number;
  byte: number;
  char: string;
  cluster_activations: Array<{
    cluster_id: number;
    activation: number;
    normalized: number;
    active_neurons: number;
  }>;
  node_activations?: Record<string, number>;
}
interface ActResult {
  input_chars: string[];
  num_tokens: number;
  per_token: TokenAct[];
  cumulative_cluster_activations: Array<{
    cluster_id: number;
    normalized: number;
  }>;
  node_activations: Record<string, number>;
}

// ─── Colors ────────────────────────────────────────────────────────────
const CC = [
  "#3a3f4b",
  "#8B5CF6",
  "#3B82F6",
  "#10B981",
  "#F59E0B",
  "#EF4444",
  "#EC4899",
  "#06B6D4",
  "#84CC16",
  "#F97316",
  "#6366F1",
  "#14B8A6",
  "#E879F9",
  "#FB923C",
  "#A78BFA",
  "#34D399",
  "#FBBF24",
  "#F472B6",
  "#22D3EE",
  "#A3E635",
];

const ci = (cid: number) => (cid <= 0 ? 0 : ((cid - 1) % (CC.length - 1)) + 1);

function hexToRgb(hex: string): [number, number, number] {
  const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return r ? [parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16)] : [128, 128, 128];
}

// ─── Histogram ─────────────────────────────────────────────────────────
function Hist({
  data,
  beta,
}: {
  data: Array<{ x: number; y: number }>;
  beta: number;
}) {
  if (!data?.length) return null;
  const my = Math.max(...data.map((d) => d.y), 1);
  const mx = Math.max(...data.map((d) => d.x)),
    mn = Math.min(...data.map((d) => d.x));
  const bp = mx > mn ? ((beta - mn) / (mx - mn)) * 100 : 50;
  return (
    <div className="mt-1.5">
      <div className="text-[9px] text-gray-600 mb-0.5">
        G* weight distribution
      </div>
      <div className="relative h-8 bg-gray-900/40 rounded overflow-hidden border border-gray-800/40">
        <div className="absolute inset-0 flex items-end">
          {data.map((d, i) => (
            <div
              key={i}
              className="flex-1"
              style={{
                height: `${(d.y / my) * 100}%`,
                backgroundColor:
                  d.x >= beta ? "rgba(139,92,246,0.5)" : "rgba(75,85,99,0.3)",
              }}
            />
          ))}
        </div>
        <div
          className="absolute top-0 bottom-0 w-px bg-red-500/70"
          style={{ left: `${Math.min(Math.max(bp, 0), 100)}%` }}
        />
      </div>
    </div>
  );
}

// ─── Cluster Pill ──────────────────────────────────────────────────────
function Pill({
  c,
  act,
  blink,
  open,
  dimmed,
  selected,
  onClick,
}: {
  c: ClusterMeta;
  act: number;
  blink: boolean;
  open: boolean;
  dimmed: boolean;
  selected: boolean;
  onClick: () => void;
}) {
  const color = CC[ci(c.cluster_id)];
  const effectiveAct = dimmed ? 0 : act;
  const effectiveBlink = dimmed ? false : blink;
  const isGlowing = selected || effectiveBlink || effectiveAct > 0.3;
  return (
    <div
      onClick={onClick}
      className="cursor-pointer rounded-lg border transition-all duration-500"
      style={{
        borderColor: isGlowing ? color : "#1f2937",
        backgroundColor: isGlowing
          ? `${color}18`
          : dimmed
            ? "#0a0a0f"
            : "#111827",
        boxShadow: selected
          ? `0 0 20px ${color}60, 0 0 40px ${color}20`
          : effectiveBlink
            ? `0 0 14px ${color}50`
            : effectiveAct > 0.3
              ? `0 0 8px ${color}30`
              : "none",
        opacity: dimmed ? 0.15 : 1,
        transform: isGlowing ? "scale(1.02)" : "scale(1)",
      }}
    >
      <div className="p-1.5 flex items-center gap-1.5">
        <div className="relative flex-shrink-0">
          <div
            className="w-2.5 h-2.5 rounded-full"
            style={{ backgroundColor: dimmed ? "#1a1a2e" : color }}
          />
          {(effectiveBlink || selected) && (
            <div
              className="absolute inset-0 rounded-full animate-ping"
              style={{ backgroundColor: color, opacity: 0.35 }}
            />
          )}
        </div>
        <span
          className={`text-[10px] font-medium truncate flex-1 ${dimmed ? "text-gray-700" : "text-gray-300"}`}
        >
          {c.label || `Cluster ${c.cluster_id}`}
        </span>
        <span className="text-[8px] text-gray-600">{c.neuron_count}n</span>
        {effectiveAct > 0.05 && (
          <span className="text-[9px] font-mono" style={{ color }}>
            {(effectiveAct * 100) | 0}%
          </span>
        )}
        {open ? (
          <ChevronUp size={9} className="text-gray-600" />
        ) : (
          <ChevronDown size={9} className="text-gray-600" />
        )}
      </div>
      {effectiveAct > 0.05 && (
        <div className="mx-1.5 mb-1 h-0.5 rounded-full bg-gray-800 overflow-hidden">
          <div
            className="h-full rounded-full transition-all duration-500"
            style={{ backgroundColor: color, width: `${effectiveAct * 100}%` }}
          />
        </div>
      )}
      {open && !dimmed && (
        <div className="px-1.5 pb-1.5 space-y-1">
          <div className="grid grid-cols-2 gap-1 text-[8px]">
            <div className="p-1 bg-gray-900/40 rounded">
              <span className="text-gray-600">Out° </span>
              {c.avg_out_degree}
            </div>
            <div className="p-1 bg-gray-900/40 rounded">
              <span className="text-gray-600">In° </span>
              {c.avg_in_degree}
            </div>
          </div>
          {c.label_confidence != null && c.label_confidence > 0 && (
            <div className="text-[7px] text-gray-500">
              Confidence: {(c.label_confidence * 100).toFixed(0)}%
            </div>
          )}
          {c.hub_neurons.length > 0 && (
            <div className="p-1 bg-gray-900/40 rounded flex gap-0.5 flex-wrap text-[8px]">
              {c.hub_neurons.map((h) => (
                <span
                  key={h.neuron}
                  className="px-0.5 rounded bg-gray-800 font-mono text-gray-500"
                >
                  #{h.neuron}
                </span>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════════
export function GraphPage() {
  const [cd, setCd] = useState<ClusterData | null>(null);
  const [ar, setAr] = useState<ActResult | null>(null);
  const [loading, setLoading] = useState(false);
  const [activating, setActivating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [head, setHead] = useState(0);
  const [beta, setBeta] = useState(0.1);
  const [layer, setLayer] = useState(-1);
  const [text, setText] = useState("");
  const [edges, setEdges] = useState(true);
  const [expCl, setExpCl] = useState<number | null>(null);

  // hlCl = cluster highlighted by click (non-inference mode)
  const [hlCl, setHlCl] = useState<number | null>(null);

  // Playback
  const [pIdx, setPIdx] = useState(-1);
  const [playing, setPlaying] = useState(false);
  const pTimer = useRef<any>(null);
  const gRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const bTimer = useRef<any>(null);

  const PLAYBACK_DELAY = 400; // ms per token

  // ── Load clusters ──
  const load = useCallback(async (h: number, b: number) => {
    setLoading(true);
    setError(null);
    setAr(null);
    setPIdx(-1);
    setPlaying(false);
    setHlCl(null);
    try {
      const r = await api.get("/graph/clusters/french", {
        params: { head: h, beta: b, max_nodes: 800 },
        timeout: 60000,
      });
      setCd(r.data);
      hasZoomed.current = false;
    } catch (e: any) {
      setError(e?.response?.data?.detail || e?.message || "Failed");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    load(head, beta);
  }, [head]); // eslint-disable-line



  // ── Auto-fit camera ONCE to show full brain ──
  const hasZoomed = useRef(false);
  const doZoomToFit = useCallback(() => {
    if (hasZoomed.current) return;
    const fg = gRef.current;
    if (!fg) return;
    fg.zoomToFit(800, 80); // generous padding to show entire brain
    hasZoomed.current = true;
  }, []);
  const handleEngineStop = useCallback(() => {
    doZoomToFit();
  }, [doZoomToFit]);
  useEffect(() => {
    if (!cd || hasZoomed.current) return;
    const t = setTimeout(() => doZoomToFit(), 2500);
    return () => clearTimeout(t);
  }, [cd, doZoomToFit]);

  // ── Beta debounce ──
  useEffect(() => {
    if (bTimer.current) clearTimeout(bTimer.current);
    bTimer.current = setTimeout(() => load(head, beta), 700);
    return () => clearTimeout(bTimer.current);
  }, [beta]); // eslint-disable-line

  // ── Inference: run text, then start auto-playback ──
  const run = useCallback(async () => {
    if (!text.trim() || !cd) return;
    setActivating(true);
    setPIdx(-1);
    setPlaying(false);
    setHlCl(null);
    try {
      const r = await api.post("/graph/activate", {
        text,
        model_name: "french",
        head,
        layer,
      });
      setAr(r.data);
      // Auto-start playback
      setPIdx(0);
      setPlaying(true);
    } catch (e: any) {
      setError(e?.response?.data?.detail || e?.message || "Failed");
    } finally {
      setActivating(false);
    }
  }, [text, head, layer, cd]);

  // ── Auto-play timer — advances token index automatically ──
  useEffect(() => {
    if (pTimer.current) clearInterval(pTimer.current);
    if (playing && ar && pIdx >= 0) {
      pTimer.current = setInterval(() => {
        setPIdx((p) => {
          if (p >= ar.num_tokens - 1) {
            setPlaying(false);
            return p;
          }
          return p + 1;
        });
      }, PLAYBACK_DELAY);
    }
    return () => {
      if (pTimer.current) clearInterval(pTimer.current);
    };
  }, [playing, ar]); // eslint-disable-line

  // ── Current token data ──
  const curTok =
    pIdx >= 0 && ar && pIdx < ar.per_token.length ? ar.per_token[pIdx] : null;
  const curMap: Record<number, number> = {};
  const blinkIds = new Set<number>();
  if (curTok) {
    // Sort activations to find the top cluster
    const sorted = [...curTok.cluster_activations]
      .filter(ca => ca.cluster_id > 0 && ca.activation > 0)
      .sort((a, b) => b.activation - a.activation);
    const topAct = sorted.length > 0 ? sorted[0].activation : 1;
    for (const ca of curTok.cluster_activations) {
      curMap[ca.cluster_id] = ca.normalized;
      // Only blink if this cluster has >= 40% of the top cluster's activation
      if (ca.activation >= topAct * 0.4 && ca.activation > 0) blinkIds.add(ca.cluster_id);
    }
  }

  // ── Node → cluster lookup ──
  const nodeClMap = useMemo(() => {
    const m: Record<number, number> = {};
    if (cd) for (const n of cd.nodes) m[n.id] = n.cluster;
    return m;
  }, [cd]);



  // ── Active clusters for current token (top-N by activation, not threshold) ──
  const activeClusters = useMemo(() => {
    const s = new Set<number>();
    if (!curTok || !cd) return s;
    // Sort cluster activations descending, pick only top clusters that are truly firing
    const sorted = [...curTok.cluster_activations]
      .filter(ca => ca.cluster_id > 0 && ca.activation > 0)
      .sort((a, b) => b.activation - a.activation);
    if (sorted.length === 0) return s;
    // Take top cluster, then include others only if they have >= 30% of top's activation
    const topAct = sorted[0].activation;
    for (const ca of sorted) {
      if (ca.activation >= topAct * 0.3) {
        s.add(ca.cluster_id);
      }
    }
    return s;
  }, [curTok, cd, nodeClMap]);

  const isPlayback = pIdx >= 0 && !!curTok;



  // ═══ GRAPH DATA — nodes with cumulative activation, no pinned positions ═══
  const graphData = useMemo(() => {
    if (!cd) return { nodes: [], links: [] };
    const nodeActs = ar?.node_activations || {};
    const nodes = cd.nodes.map((n) => ({
      ...n,
      activation: nodeActs[String(n.id)] ? Number(nodeActs[String(n.id)]) : 0,
    }));
    const links = edges
      ? cd.edges.map((e) => ({
          source: typeof e.source === "object" ? (e.source as any).id : e.source,
          target: typeof e.target === "object" ? (e.target as any).id : e.target,
          weight: e.weight,
          same_cluster: e.same_cluster,
        }))
      : [];
    return { nodes, links };
  }, [cd, ar, edges]);

  // ═══ NODE THREE OBJECT — 3D spheres with emissive glow (Nilay style) ═══
  const nodeThreeObject = useCallback(
    (node: any) => {
      const cluster = node.cluster || 0;
      const isHub = node.is_hub;
      const activation = node.activation || 0;
      const isHl = hlCl !== null && cluster === hlCl;
      const color = CC[ci(cluster)];
      const [r, g, b] = hexToRgb(color);

      // Cluster blinking from per-token data
      const isBlinking = blinkIds.has(cluster);
      const blinkBoost = isBlinking ? 1.8 : 1;

      const baseSize = isHub ? 3 : 1.5;
      const actBoost = activation > 0 ? 1 + activation * 2.5 : 0;
      const hlBoost = isHl ? 1.4 : 1;
      const size = (baseSize + actBoost) * hlBoost * blinkBoost;

      const dim = hlCl !== null && !isHl ? 0.12 : 1.0;
      const emissiveStr = Math.max(
        activation > 0.1 ? activation * 0.7 : 0,
        isHl ? 0.25 : 0,
        isBlinking ? 0.6 : 0,
      );

      const geo = new THREE.SphereGeometry(size, 10, 10);
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(r / 255 * dim, g / 255 * dim, b / 255 * dim),
        emissive: new THREE.Color(
          r / 255 * emissiveStr,
          g / 255 * emissiveStr,
          b / 255 * emissiveStr,
        ),
        transparent: dim < 1,
        opacity: dim < 1 ? 0.25 : 1,
      });
      return new THREE.Mesh(geo, mat);
    },
    [hlCl, blinkIds],
  );

  // ── Link color ──
  const linkColor = useCallback(
    (link: any) => {
      if (!edges) return "rgba(0,0,0,0)";
      const sid =
        typeof link.source === "object" ? link.source.id : link.source;
      if (link.same_cluster) {
        const sc = nodeClMap[sid] ?? 0;
        const dimmed = hlCl !== null && sc !== hlCl;
        return dimmed ? "rgba(40,40,55,0.04)" : `${CC[ci(sc)]}44`;
      }
      return hlCl !== null ? "rgba(40,40,55,0.03)" : "rgba(120,120,150,0.12)";
    },
    [nodeClMap, hlCl, edges],
  );

  const onKey = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      run();
    }
  };

  // ── Stop playback and clear when clicking cluster during playback ──
  const handleClusterClick = useCallback(
    (cid: number) => {
      if (isPlayback) {
        // During playback, clicking a cluster stops it and selects that cluster
        setPlaying(false);
        setPIdx(-1);
        setAr(null);
        setHlCl(cid);
        setExpCl((prev) => (prev === cid ? null : cid));
      } else {
        // Non-playback: toggle cluster highlight
        setHlCl((prev) => (prev === cid ? null : cid));
        setExpCl((prev) => (prev === cid ? null : cid));
      }
    },
    [isPlayback],
  );

  // ═════════════════════════════════════════════════════════════════════
  return (
    <div
      className="h-full flex flex-row"
      style={{ height: "100%", minHeight: 0 }}
    >
      {/* LEFT — graph + controls */}
      <div className="flex-1 flex flex-col min-w-0 overflow-hidden">
        {/* Header */}
        <div className="px-5 pt-3 pb-0.5 flex-shrink-0">
          <div className="flex items-center gap-2">
            <Brain size={20} className="text-bdh-accent" />
            <h1 className="text-xl font-bold">
              <span className="gradient-text">Neural Graph</span> Explorer
            </h1>
          </div>
          <p className="text-gray-600 text-[11px]">
            G*=D<sub>x</sub>E neuron interaction graph · Louvain clusters ·
            French model
            {isPlayback && (
              <span className="text-bdh-accent ml-2">
                ● LIVE — watching the brain think
              </span>
            )}
          </p>
        </div>

        {/* Controls */}
        <div className="px-5 py-1.5 flex flex-wrap items-center gap-2 flex-shrink-0">
          <div className="flex items-center gap-1">
            <span className="text-[9px] text-gray-500 uppercase">Head</span>
            {[0, 1, 2, 3].map((h) => (
              <button
                key={h}
                onClick={() => setHead(h)}
                className={`w-6 h-6 rounded text-[10px] font-mono font-bold ${head === h ? "bg-bdh-accent text-white" : "bg-gray-800 text-gray-500 hover:bg-gray-700"}`}
              >
                {h + 1}
              </button>
            ))}
          </div>
          <div className="w-px h-4 bg-gray-800" />
          <div className="flex items-center gap-1 flex-1 max-w-[200px]">
            <span className="text-[9px] text-gray-500">β</span>
            <input
              type="range"
              min={0.01}
              max={0.5}
              step={0.005}
              value={beta}
              onChange={(e) => setBeta(parseFloat(e.target.value))}
              className="flex-1 h-1 appearance-none rounded-full bg-gray-800
                [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-3 [&::-webkit-slider-thumb]:h-3
                [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-bdh-accent [&::-webkit-slider-thumb]:cursor-pointer"
            />
            <span className="text-[9px] font-mono text-bdh-accent w-8 text-right">
              {beta.toFixed(3)}
            </span>
          </div>
          <div className="w-px h-4 bg-gray-800" />
          <button
            onClick={() => setEdges(!edges)}
            className={`p-1 rounded ${edges ? "bg-gray-700 text-gray-200" : "bg-gray-800/50 text-gray-600"}`}
          >
            <Eye size={13} />
          </button>
          <button
            onClick={() => {
              gRef.current?.zoomToFit(600, 80);
            }}
            className="p-1 rounded bg-gray-800/50 text-gray-500 hover:bg-gray-700"
          >
            <RotateCcw size={13} />
          </button>
          {hlCl !== null && !isPlayback && (
            <button
              onClick={() => setHlCl(null)}
              className="px-2 py-0.5 rounded text-[9px] bg-gray-700 text-gray-300 hover:bg-gray-600"
            >
              Show All
            </button>
          )}
        </div>

        {error && (
          <div className="mx-5 mb-1 p-1.5 bg-red-500/10 border border-red-500/30 rounded text-red-300 text-[10px] flex items-center gap-1 flex-shrink-0">
            <AlertCircle size={12} />
            {error}
            <button
              onClick={() => setError(null)}
              className="ml-auto text-red-400"
            >
              ✕
            </button>
          </div>
        )}

        {cd &&
          cd.beta_effective != null &&
          Math.abs(cd.beta_effective - beta) > 0.001 && (
            <div className="mx-5 mb-1 p-1.5 bg-yellow-500/10 border border-yellow-500/30 rounded text-yellow-300 text-[10px] flex items-center gap-1 flex-shrink-0">
              <Info size={12} />
              <span>
                β auto-adjusted: {beta.toFixed(3)} →{" "}
                {cd.beta_effective.toFixed(3)} for visibility
              </span>
              <button
                onClick={() => setBeta(cd.beta_effective!)}
                className="ml-auto text-yellow-400 text-[9px] underline"
              >
                Apply
              </button>
            </div>
          )}

        {/* ── 3D Graph ── */}
        <div
          ref={containerRef}
          className="flex-1 relative mx-5 mb-1.5 rounded-xl overflow-hidden border border-gray-800/40 bg-[#07070c]"
        >
          {loading ? (
            <div className="absolute inset-0 flex items-center justify-center z-10">
              <Loader2 className="w-7 h-7 text-bdh-accent animate-spin" />
            </div>
          ) : graphData.nodes.length > 0 ? (
            <ForceGraph3D
              ref={gRef}
              graphData={graphData}
              nodeThreeObject={nodeThreeObject}
              nodeThreeObjectExtend={false}
              linkColor={linkColor}
              linkOpacity={0.25}
              linkWidth={0.4}
              backgroundColor="#07070c"
              enableNodeDrag={true}
              enableNavigationControls={true}
              controlType="orbit"
              nodeLabel={(n: any) =>
                `#${n.id} · Cluster ${n.cluster} · Deg ${n.degree}${n.is_hub ? " (HUB)" : ""}`
              }
              onNodeClick={(n: any) =>
                setHlCl((prev) => (prev === n.cluster ? null : n.cluster))
              }
              onBackgroundClick={() => setHlCl(null)}
              onEngineStop={handleEngineStop}
              showNavInfo={false}
              d3AlphaDecay={0.025}
              d3VelocityDecay={0.3}
              warmupTicks={60}
              cooldownTicks={180}
              width={undefined}
              height={undefined}
            />
          ) : (
            !loading && (
              <div className="absolute inset-0 flex items-center justify-center">
                <p className="text-gray-700 text-[10px]">
                  No data — start the backend
                </p>
              </div>
            )
          )}

          {/* Overlay stats */}
          {cd && !loading && (
            <div className="absolute top-2 left-2 flex gap-1 pointer-events-none">
              <div className="px-1.5 py-0.5 rounded bg-black/60 text-[8px] font-mono text-gray-500">
                {cd.n_display_nodes}n·{cd.n_display_edges}e
              </div>
              <div className="px-1.5 py-0.5 rounded bg-black/60 text-[8px] font-mono text-bdh-accent/80">
                {cd.num_clusters}cl Q={cd.modularity.toFixed(3)}
              </div>
            </div>
          )}

          {/* Token bar during playback */}
          {curTok && ar && (
            <div className="absolute bottom-1.5 left-2 right-2 pointer-events-none">
              <div className="px-2 py-1.5 rounded-lg bg-black/80 backdrop-blur flex items-center gap-0.5 overflow-x-auto">
                <span className="text-[7px] text-gray-600 mr-1 flex-shrink-0 uppercase">
                  Token
                </span>
                {ar.input_chars.map((ch, i) => (
                  <span
                    key={i}
                    className={`px-0.5 text-[10px] font-mono rounded flex-shrink-0 transition-all duration-300 ${
                      i === pIdx
                        ? "bg-bdh-accent text-white px-1.5 py-0.5 scale-110"
                        : i < pIdx
                          ? "text-gray-500"
                          : "text-gray-700"
                    }`}
                  >
                    {ch}
                  </span>
                ))}
                {(() => {
                  const total = cd?.nodes.length ?? 0;
                  const na = ar?.node_activations || {};
                  const firing =
                    total > 0
                      ? cd!.nodes.filter((n) => (na[String(n.id)] ?? 0) > 0)
                          .length
                      : 0;
                  const pct =
                    total > 0 ? ((1 - firing / total) * 100).toFixed(0) : "—";
                  return (
                    <span className="ml-auto text-[7px] text-bdh-accent/70 flex-shrink-0 whitespace-nowrap">
                      {firing}/{total} fire · {pct}% sparse
                    </span>
                  );
                })()}
              </div>
            </div>
          )}
        </div>

        {/* ── Inference input ── */}
        <div className="px-5 pb-3 flex-shrink-0">
          <div className="glass-card p-2">
            <div className="flex items-center gap-1 mb-1">
              <Zap size={11} className="text-bdh-accent" />
              <span className="text-[9px] font-semibold text-gray-400">
                Live Inference — type text, watch the brain think
              </span>
              {ar && (
                <div className="ml-auto flex gap-0.5">
                  <button
                    onClick={() => {
                      setPIdx(0);
                      setPlaying(true);
                    }}
                    className="p-0.5 rounded bg-gray-800 text-gray-500 hover:text-gray-300"
                  >
                    <RotateCcw size={9} />
                  </button>
                  <button
                    onClick={() => setPlaying(!playing)}
                    className={`p-0.5 rounded ${playing ? "bg-bdh-accent/20 text-bdh-accent" : "bg-gray-800 text-gray-500"}`}
                  >
                    {playing ? <Pause size={9} /> : <Play size={9} />}
                  </button>
                  <button
                    onClick={() =>
                      setPIdx((p) => Math.min(p + 1, (ar?.num_tokens || 1) - 1))
                    }
                    className="p-0.5 rounded bg-gray-800 text-gray-500 hover:text-gray-300"
                  >
                    <SkipForward size={9} />
                  </button>
                  <button
                    onClick={() => {
                      setPlaying(false);
                      setPIdx(-1);
                      setAr(null);
                      setHlCl(null);
                    }}
                    className="p-0.5 rounded bg-gray-800 text-gray-500 hover:text-gray-300"
                  >
                    <Square size={9} />
                  </button>
                </div>
              )}
            </div>
            <div className="flex gap-1.5">
              <input
                type="text"
                value={text}
                onChange={(e) => setText(e.target.value)}
                onKeyDown={onKey}
                placeholder="e.g. The price in euros was 50 francs"
                className="input-field flex-1 text-[10px] !py-1.5"
              />
              <select
                value={layer}
                onChange={(e) => setLayer(+e.target.value)}
                className="px-1 rounded bg-gray-800 border border-gray-700 text-[8px] text-gray-400"
              >
                <option value={-1}>All</option>
                {[0, 1, 2, 3, 4, 5, 6, 7].map((l) => (
                  <option key={l} value={l}>
                    L{l}
                  </option>
                ))}
              </select>
              <button
                onClick={run}
                disabled={activating || !text.trim()}
                className="btn-primary flex items-center gap-1 text-[9px] disabled:opacity-40 !py-1 !px-2.5"
              >
                {activating ? (
                  <Loader2 size={11} className="animate-spin" />
                ) : (
                  <Send size={11} />
                )}{" "}
                Run
              </button>
            </div>
            <div className="mt-1 flex flex-wrap gap-1">
              {[
                "The price in euros was 50 francs",
                "Germany and France signed the treaty",
                "Le dollar américain",
                "The European Parliament",
                "le changement climatique menace",
              ].map((ex) => (
                <button
                  key={ex}
                  onClick={() => setText(ex)}
                  className="px-1 py-0.5 text-[7px] bg-gray-800/40 hover:bg-gray-700 rounded text-gray-600 hover:text-gray-400 truncate max-w-[150px]"
                >
                  {ex}
                </button>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* ── RIGHT SIDEBAR ── */}
      <aside className="w-64 border-l border-gray-800/50 bg-gray-900/30 flex flex-col overflow-hidden flex-shrink-0">
        <div className="p-2 border-b border-gray-800/50 flex-shrink-0">
          <div className="flex items-center justify-between">
            <h2 className="text-[9px] font-bold text-gray-400 uppercase tracking-wider flex items-center gap-1">
              <Activity size={9} className="text-bdh-accent" /> Clusters
            </h2>
            {cd && (
              <span className="text-[7px] font-mono text-gray-700">
                {cd.n_neurons.toLocaleString()}n
              </span>
            )}
          </div>
          {curTok && (
            <div className="mt-1 px-1.5 py-1 rounded bg-bdh-accent/10 border border-bdh-accent/20">
              <div className="text-[7px] text-bdh-accent/60 uppercase">
                Token {curTok.token_idx + 1}/{ar?.num_tokens}
              </div>
              <div className="text-sm font-mono text-white">
                '{curTok.char}'
              </div>
              <div className="text-[7px] text-gray-500 mt-0.5">
                {activeClusters.size} cluster
                {activeClusters.size !== 1 ? "s" : ""} active
              </div>
            </div>
          )}
          {hlCl !== null && !isPlayback && (
            <div
              className="mt-1 px-1.5 py-1 rounded border border-gray-700"
              style={{
                borderColor: CC[ci(hlCl)] + "40",
                backgroundColor: CC[ci(hlCl)] + "08",
              }}
            >
              <div
                className="text-[7px] uppercase"
                style={{ color: CC[ci(hlCl)] }}
              >
                Selected Cluster
              </div>
              <div className="text-sm font-mono text-white">
                {cd?.clusters.find((c) => c.cluster_id === hlCl)?.label ||
                  `Cluster ${hlCl}`}
              </div>
            </div>
          )}
        </div>
        {cd && (
          <div className="px-2 flex-shrink-0">
            <Hist data={cd.histogram} beta={beta} />
          </div>
        )}
        <div className="flex-1 overflow-y-auto px-2 py-1 space-y-0.5">
          {cd?.clusters
            .filter((c) => c.cluster_id > 0)
            .map((c) => (
              <Pill
                key={c.cluster_id}
                c={c}
                act={
                  curMap[c.cluster_id] ??
                  (ar
                    ? (ar.cumulative_cluster_activations.find(
                        (x) => x.cluster_id === c.cluster_id,
                      )?.normalized ?? 0)
                    : 0)
                }
                blink={blinkIds.has(c.cluster_id)}
                open={expCl === c.cluster_id}
                selected={hlCl === c.cluster_id && !isPlayback}
                dimmed={
                  (isPlayback &&
                    activeClusters.size > 0 &&
                    !activeClusters.has(c.cluster_id)) ||
                  (hlCl !== null && !isPlayback && hlCl !== c.cluster_id)
                }
                onClick={() => handleClusterClick(c.cluster_id)}
              />
            ))}
          {cd?.clusters.find((c) => c.cluster_id === 0) && (
            <div className="pt-0.5 border-t border-gray-800/40 text-[7px] text-gray-700 flex items-center gap-0.5">
              <Info size={7} />{" "}
              {cd.clusters.find((c) => c.cluster_id === 0)?.neuron_count}{" "}
              isolated
            </div>
          )}
        </div>
        <div className="p-2 border-t border-gray-800/50 bg-gray-950/50 flex-shrink-0">
          <p className="text-[8px] text-gray-600">
            Head {head + 1}/4 · β={beta.toFixed(3)}
            {cd?.beta_effective != null &&
              Math.abs(cd.beta_effective - beta) > 0.001 && (
                <span className="text-yellow-500">
                  {" "}
                  → eff={cd.beta_effective.toFixed(3)}
                </span>
              )}
          </p>
          <p className="text-[7px] text-gray-700 mt-0.5">
            Click cluster to isolate · Enter text to watch brain activate
          </p>
        </div>
      </aside>
    </div>
  );
}


================================================================================
 FILE: pages\MonosemanticityPage.tsx  (3368 lines)
================================================================================

import React, {
  useState,
  useCallback,
  useMemo,
  useRef,
  useEffect,
} from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Brain,
  Plus,
  X,
  Loader2,
  Layers,
  Zap,
  Eye,
  BarChart3,
  GitCompare,
  Network,
  Star,
  Search,
  Info,
  Activity,
  BarChart2,
  ChevronDown,
} from "lucide-react";
import * as d3 from "d3";
import { analysis } from "../utils/api";

/* ================================================================== */
/*  Type definitions                                                    */
/* ================================================================== */
interface TopNeuron {
  idx: number;
  val: number;
  raw?: number;
}
interface HeadFingerprint {
  head: number;
  x_ds: number[];
  x_active: number;
  top_neurons: TopNeuron[];
}
interface LayerFingerprint {
  layer: number;
  heads: HeadFingerprint[];
}
interface WordFingerprint {
  word: string;
  layers: LayerFingerprint[];
}
interface SharedNeuron {
  layer: number;
  head: number;
  neuron: number;
  mean_activation: number;
  active_in: number;
  per_word: number[];
}
interface MonosemanticNeuron {
  layer: number;
  head: number;
  neuron: number;
  selectivity: number;
  mean_in: number;
  mean_out: number;
  p_value: number;
  per_word: number[];
}
interface FingerprintResult {
  concept: string;
  words: WordFingerprint[];
  similarity: Record<string, number[][]>;
  shared_neurons: SharedNeuron[];
  monosemantic_neurons?: MonosemanticNeuron[];
  model_info: { n_layers: number; n_heads: number; n_neurons: number };
}
interface CrossConceptEntry {
  primary: string;
  secondary: string;
  distinctness_per_layer: number[];
  secondary_result: FingerprintResult;
}
interface SelectivityHistBin {
  bin_start: number;
  bin_end: number;
  count: number;
}
interface TrackedSynapse {
  id: string;
  label: string;
  layer: number;
  head: number;
  i: number;
  j: number;
  selectivity: number;
}
interface WordTimelineEntry {
  word: string;
  byte_start: number;
  byte_end: number;
  is_concept: boolean;
  sigma: Record<string, number>;
  delta_sigma: Record<string, number>;
}
interface SentenceTrack {
  sentence: string;
  n_bytes: number;
  words: WordTimelineEntry[];
}
interface ConceptTracking {
  synapses: TrackedSynapse[];
  sentences: SentenceTrack[];
}
interface PrecomputedData {
  model_info: { n_layers: number; n_heads: number; n_neurons: number };
  best_layer: number;
  concepts: Record<string, FingerprintResult>;
  cross_concept: CrossConceptEntry[];
  selectivity?: {
    histogram: SelectivityHistBin[];
    total_neurons: number;
    total_selective: number;
    mean_selectivity: number;
  };
  synapse_tracking?: Record<string, ConceptTracking>;
}

/* ================================================================== */
/*  Constants — presets, colors, etc.                                   */
/* ================================================================== */
const PRESETS = [
  { id: "currencies", name: "Currencies", color: "#34d399" },
  { id: "countries", name: "Countries", color: "#60a5fa" },
  { id: "languages", name: "Languages", color: "#c084fc" },
  { id: "politics", name: "Politics", color: "#fbbf24" },
];

const CONCEPT_COLORS: Record<string, string> = {
  currencies: "#34d399",
  countries: "#60a5fa",
  languages: "#c084fc",
  politics: "#fbbf24",
};

const WORD_COLORS = [
  "#34d399",
  "#60a5fa",
  "#c084fc",
  "#fbbf24",
  "#f472b6",
  "#38bdf8",
  "#a78bfa",
  "#fb923c",
];

const HEAD_COLORS = ["#34d399", "#60a5fa", "#c084fc", "#fbbf24"];

const SYNAPSE_COLORS = ["#34d399", "#60a5fa", "#c084fc", "#fbbf24", "#f472b6"];

function presetOf(id: string) {
  return PRESETS.find((p) => p.id === id);
}

/* ================================================================== */
/*  Color helpers                                                       */
/* ================================================================== */
function simColor(t: number): string {
  if (t < 0.3) return `rgba(59,130,246,${(0.15 + t * 0.5).toFixed(2)})`;
  if (t < 0.6) return `rgba(16,185,129,${(0.2 + (t - 0.3) * 1.5).toFixed(2)})`;
  return `rgba(250,204,21,${(0.3 + (t - 0.6) * 1.5).toFixed(2)})`;
}

function sciColor(t: number): string {
  if (t < 0.2) {
    const u = t / 0.2;
    return `rgba(${Math.round(40 + u * 50)}, ${Math.round(10 + u * 20)}, ${Math.round(80 + u * 80)}, ${(0.4 + u * 0.2).toFixed(2)})`;
  }
  if (t < 0.4) {
    const u = (t - 0.2) / 0.2;
    return `rgba(${Math.round(90 - u * 40)}, ${Math.round(30 + u * 60)}, ${Math.round(160 + u * 40)}, ${(0.6 + u * 0.1).toFixed(2)})`;
  }
  if (t < 0.6) {
    const u = (t - 0.4) / 0.2;
    return `rgba(${Math.round(50 - u * 20)}, ${Math.round(90 + u * 80)}, ${Math.round(200 - u * 50)}, ${(0.7 + u * 0.1).toFixed(2)})`;
  }
  if (t < 0.8) {
    const u = (t - 0.6) / 0.2;
    return `rgba(${Math.round(30 + u * 80)}, ${Math.round(170 + u * 50)}, ${Math.round(150 - u * 80)}, ${(0.8 + u * 0.1).toFixed(2)})`;
  }
  const u = (t - 0.8) / 0.2;
  return `rgba(${Math.round(110 + u * 145)}, ${Math.round(220 + u * 35)}, ${Math.round(70 + u * 30)}, ${(0.9 + u * 0.1).toFixed(2)})`;
}

/* ================================================================== */
/*  View tabs                                                          */
/* ================================================================== */
type ViewTab =
  | "similarity"
  | "crossConcept"
  | "intersection"
  | "neuronGraph"
  | "synapseTracking"
  | "selectivity";

const VIEW_TABS: {
  id: ViewTab;
  label: string;
  blurb: string;
  narrative: string;
}[] = [
  {
    id: "synapseTracking",
    label: "Synapse Tracking",
    blurb: "Watch synapses grow at concept words",
    narrative:
      "Each synapse σ(i,j) strengthens when two neurons fire together (Hebbian learning). If a synapse spikes at currency words but stays flat at other words, it has learned that concept.",
  },
  {
    id: "selectivity",
    label: "Selectivity",
    blurb: "Statistical proof of specialization",
    narrative:
      "Selectivity measures how much more a neuron fires for its concept vs. everything else (1.0 = perfectly exclusive). Mann-Whitney U test confirms this isn't random (p < 0.05).",
  },
  {
    id: "similarity",
    label: "Sparse Fingerprinting",
    blurb: "Same concept → similar activation",
    narrative:
      "If the model truly encodes concepts, words from the same category should activate similar neurons. High cosine similarity between their sparse vectors confirms this.",
  },
  {
    id: "crossConcept",
    label: "Cross-Concept",
    blurb: "Are concepts cleanly separated?",
    narrative:
      "We compare the top active neurons between different concepts. Low overlap (high distinctness) means the model uses different neurons for different ideas — a sign of structure.",
  },
  {
    id: "intersection",
    label: "Shared Neurons",
    blurb: "Which exact neurons are shared?",
    narrative:
      "Pick a reference word and see which of its top neurons also fire for other same-concept words (green = shared, dim = unique to that word).",
  },
  {
    id: "neuronGraph",
    label: "Neuron Graph",
    blurb: "Visualize neuron connectivity",
    narrative:
      "A force-directed graph linking words to their top neurons. Hub neurons (connected to multiple words) reveal shared concept encoding at a glance.",
  },
];

/* ================================================================== */
/*  LAYER SELECTOR                                                      */
/* ================================================================== */
function LayerSelector({
  nLayers,
  selected,
  onChange,
  bestLayer,
}: {
  nLayers: number;
  selected: number;
  onChange: (l: number) => void;
  bestLayer: number;
}) {
  return (
    <div className="flex items-center gap-1 bg-[#0B1216]/60 rounded-xl p-1 border border-white/[0.06]">
      <Layers size={14} className="text-[#4A5568] ml-2 mr-1" />
      {Array.from({ length: nLayers }, (_, i) => (
        <button
          key={i}
          onClick={() => onChange(i)}
          className={`relative px-3 py-1.5 rounded-lg text-xs font-mono font-semibold transition-all ${
            selected === i
              ? "bg-[#00C896]/15 text-[#00C896]"
              : "text-[#8B95A5] hover:text-[#E2E8F0] hover:bg-white/\[0.03\]"
          }`}
        >
          L{i}
          {i === bestLayer && (
            <Star
              size={8}
              className="absolute -top-1 -right-1 text-[#00C896] fill-[#00C896]"
            />
          )}
        </button>
      ))}
      <span className="text-[9px] text-[#4A5568] ml-2 hidden sm:inline">
        <Star
          size={7}
          className="inline text-[#00C896] fill-[#00C896] mr-0.5"
        />
        = peak monosemanticity
      </span>
    </div>
  );
}

/* ================================================================== */
/*  NEURON STRIP — renders actual neuron positions                     */
/* ================================================================== */
function NeuronStrip({
  neurons,
  label,
  delay = 0,
  highlightNeurons,
  color,
}: {
  neurons: TopNeuron[];
  totalNeurons?: number;
  label: string;
  delay?: number;
  highlightNeurons?: Set<number>;
  color?: string;
}) {
  const sorted = useMemo(
    () => [...neurons].sort((a, b) => b.val - a.val),
    [neurons],
  );
  const maxVal = useMemo(
    () => Math.max(1e-6, ...sorted.map((n) => n.val)),
    [sorted],
  );
  const sharedCount =
    highlightNeurons !== undefined
      ? neurons.filter((n) => highlightNeurons.has(n.idx)).length
      : null;

  const topN = Math.min(5, sorted.length);

  return (
    <motion.div
      initial={{ opacity: 0, x: -6 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ delay, duration: 0.3 }}
    >
      <div className="flex items-center gap-2">
        <span className="text-[10px] font-mono text-[#4A5568] w-7 shrink-0 text-right">
          {label}
        </span>
        <div
          className="flex-1 grid items-end h-9 rounded-md overflow-hidden border border-white/[0.04] px-0.5"
          style={{
            gridTemplateColumns: `repeat(${sorted.length}, 1fr)`,
            gap: "1px",
            background:
              "linear-gradient(to right,rgba(15,23,42,0.3),rgba(15,23,42,0.5))",
          }}
        >
          {sorted.map((n, i) => {
            const t = n.val / maxVal;
            const isHL = highlightNeurons?.has(n.idx);
            const hPct = Math.max(5, t * 100);

            let bg: string;
            let shadow: string | undefined;

            if (highlightNeurons !== undefined) {
              bg = isHL
                ? `rgba(16,185,129,${(0.5 + t * 0.5).toFixed(2)})`
                : `rgba(100,116,139,${(0.03 + t * 0.04).toFixed(2)})`;
              shadow =
                isHL && t > 0.25 ? "0 0 5px rgba(16,185,129,0.35)" : undefined;
            } else {
              bg = color ?? sciColor(t);
              shadow =
                t > 0.4
                  ? `0 0 4px ${color ?? "rgba(139,92,246,0.3)"}`
                  : undefined;
            }

            return (
              <motion.div
                key={n.idx}
                className="rounded-t-[2px]"
                initial={{ scaleY: 0, opacity: 0 }}
                animate={{ scaleY: 1, opacity: 1 }}
                transition={{ delay: delay + i * 0.01, duration: 0.18 }}
                style={{
                  height: `${hPct}%`,
                  backgroundColor: bg,
                  transformOrigin: "bottom",
                  boxShadow: shadow,
                }}
                title={`#${n.idx} — ${n.val.toFixed(4)}`}
              />
            );
          })}
        </div>
        {sharedCount !== null && (
          <span className="text-[9px] font-mono text-[#00C896]/70 w-10 shrink-0 text-left">
            {sharedCount}/{neurons.length}
          </span>
        )}
      </div>
      <div className="flex items-center gap-2 mt-px">
        <span className="w-7 shrink-0" />
        <div className="flex gap-1.5">
          {sorted.slice(0, topN).map((n, i) => {
            const isHL = highlightNeurons?.has(n.idx);
            return (
              <span
                key={n.idx}
                className="text-[7px] font-mono leading-none"
                style={{
                  color:
                    highlightNeurons !== undefined
                      ? isHL
                        ? "#6ee7b7"
                        : "#27272a"
                      : i === 0
                        ? (color ?? "#a78bfa")
                        : "#52525b",
                  fontWeight: isHL || i < 2 ? 600 : 400,
                }}
              >
                #{n.idx}
              </span>
            );
          })}
        </div>
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  Helper: extract concept signature neurons                          */
/* ================================================================== */
function extractConceptSignature(
  result: FingerprintResult,
  layer: number,
): { head: number; idx: number; count: number; totalVal: number }[] {
  const agg = new Map<
    string,
    { head: number; idx: number; count: number; totalVal: number }
  >();
  result.words.forEach((w) => {
    const l = w.layers.find((la) => la.layer === layer);
    if (!l) return;
    l.heads.forEach((h) => {
      h.top_neurons.forEach((n) => {
        const key = `${h.head}_${n.idx}`;
        const existing = agg.get(key);
        if (existing) {
          existing.count++;
          existing.totalVal += n.val;
        } else {
          agg.set(key, {
            head: h.head,
            idx: n.idx,
            count: 1,
            totalVal: n.val,
          });
        }
      });
    });
  });
  return [...agg.values()]
    .filter((n) => n.count >= 2)
    .sort((a, b) => b.count - a.count || b.totalVal - a.totalVal);
}

/* ================================================================== */
/*  1. SIMILARITY VIEW                                                 */
/* ================================================================== */
function SimilarityView({
  concepts,
  activeConcept,
  setActiveConcept,
  selectedLayer,
}: {
  concepts: Record<string, FingerprintResult>;
  activeConcept: string;
  setActiveConcept: (c: string) => void;
  selectedLayer: number;
}) {
  const result = concepts[activeConcept];
  if (!result) return null;

  const simKey = String(selectedLayer);
  const matrix = result.similarity[simKey];
  if (!matrix) return null;

  const words = result.words.map((w) => w.word);
  const n = words.length;
  const offDiag: number[] = [];
  for (let i = 0; i < n; i++)
    for (let j = 0; j < n; j++) if (i !== j) offDiag.push(matrix[i][j]);
  const avgSim =
    offDiag.length > 0
      ? offDiag.reduce((a, b) => a + b, 0) / offDiag.length
      : 0;

  const allVals = matrix.flat();
  const matMin = Math.min(...allVals);
  const matMax = Math.max(...allVals);
  const matRange = matMax - matMin || 1;
  const rescale = (v: number) =>
    Math.max(0, Math.min(1, (v - matMin) / matRange));

  const allAvgs = useMemo(() => {
    const out: Record<string, number> = {};
    Object.entries(concepts).forEach(([cid, cr]) => {
      const m = cr.similarity[simKey];
      if (!m) return;
      const n2 = m.length;
      let sum = 0,
        cnt = 0;
      for (let i = 0; i < n2; i++)
        for (let j = 0; j < n2; j++)
          if (i !== j) {
            sum += m[i][j];
            cnt++;
          }
      out[cid] = cnt > 0 ? sum / cnt : 0;
    });
    return out;
  }, [concepts, simKey]);

  return (
    <div className="space-y-4">
      <div className="flex flex-wrap gap-2">
        {Object.entries(concepts).map(([cid]) => {
          const preset = PRESETS.find((p) => p.id === cid);
          const avg = allAvgs[cid] ?? 0;
          const isActive = cid === activeConcept;
          return (
            <motion.button
              key={cid}
              onClick={() => setActiveConcept(cid)}
              className={`px-4 py-2.5 rounded-xl text-sm font-semibold border transition-all ${
                isActive
                  ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
                  : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
              }`}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {preset?.name ?? cid}
              <span
                className={`ml-2 text-xs font-mono ${avg > 0.6 ? "text-[#00C896]" : avg > 0.4 ? "text-[#CBD5E0]" : "text-[#4A5568]"}`}
              >
                {avg.toFixed(2)}
              </span>
            </motion.button>
          );
        })}
      </div>

      <motion.div
        className="glass-card p-5"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        key={activeConcept + simKey}
      >
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <BarChart3 size={16} className="text-[#8B95A5]" />
            <span className="text-sm font-semibold">
              Encoder Alignment — {result.concept}
            </span>
          </div>
          <span
            className={`text-xs font-mono font-bold ${avgSim > 0.6 ? "text-[#00C896]" : avgSim > 0.4 ? "text-[#CBD5E0]" : "text-[#4A5568]"}`}
          >
            avg: {avgSim.toFixed(3)}
          </span>
        </div>

        <div className="overflow-x-auto">
          <div
            className="grid gap-[3px] mx-auto"
            style={{
              gridTemplateColumns: `48px repeat(${n}, minmax(60px, 1fr))`,
              maxWidth: 48 + n * 80,
            }}
          >
            <div />
            {words.map((w, j) => (
              <div
                key={`h-${j}`}
                className="text-center text-[10px] font-mono font-bold truncate px-1"
                style={{ color: WORD_COLORS[j % WORD_COLORS.length] }}
              >
                {w}
              </div>
            ))}
            {words.map((wi, i) => (
              <React.Fragment key={`r-${i}`}>
                <div
                  className="text-right text-[10px] font-mono font-bold pr-2 flex items-center justify-end"
                  style={{ color: WORD_COLORS[i % WORD_COLORS.length] }}
                >
                  {wi}
                </div>
                {matrix[i].map((val: number, j: number) => {
                  const t = rescale(val);
                  return (
                    <motion.div
                      key={`c-${i}-${j}`}
                      className="rounded-md flex items-center justify-center text-[11px] font-mono font-bold h-12"
                      style={{
                        backgroundColor: simColor(t),
                        color:
                          t > 0.6 ? "rgba(0,0,0,0.8)" : "rgba(255,255,255,0.9)",
                      }}
                      initial={{ scale: 0, opacity: 0 }}
                      animate={{ scale: 1, opacity: 1 }}
                      transition={{ delay: (i * n + j) * 0.015 }}
                    >
                      {val.toFixed(2)}
                    </motion.div>
                  );
                })}
              </React.Fragment>
            ))}
          </div>
        </div>

        <div className="flex items-center gap-2 mt-4">
          <span className="text-[10px] text-[#4A5568] font-mono">
            {matMin.toFixed(2)}
          </span>
          <div className="flex-1 h-3 rounded-full overflow-hidden flex">
            {Array.from({ length: 20 }, (_, i) => (
              <div
                key={i}
                className="flex-1 h-full"
                style={{ backgroundColor: simColor(i / 19) }}
              />
            ))}
          </div>
          <span className="text-[10px] text-[#4A5568] font-mono">
            {matMax.toFixed(2)}
          </span>
        </div>

        {avgSim > 0.5 && (
          <motion.div
            className="mt-4 p-3 rounded-xl bg-white/\[0.03\] border border-white/\[0.06\]"
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            <p className="text-xs text-[#CBD5E0]">
              Avg similarity <strong>{avgSim.toFixed(3)}</strong> — words in the{" "}
              <strong>{result.concept}</strong> category activate overlapping
              neuron populations. This is <strong>monosemantic encoding</strong>{" "}
              in action.
            </p>
          </motion.div>
        )}
      </motion.div>
    </div>
  );
}

/* ================================================================== */
/*  2. CROSS-CONCEPT VIEW                                              */
/* ================================================================== */
function CrossConceptView({
  crossPairs,
  concepts,
  selectedLayer,
}: {
  crossPairs: CrossConceptEntry[];
  concepts: Record<string, FingerprintResult>;
  selectedLayer: number;
}) {
  const [activePair, setActivePair] = useState(0);
  const pair = crossPairs[activePair];
  if (!pair) return null;

  const primaryResult = concepts[pair.primary];
  const secondaryResult = pair.secondary_result;
  if (!primaryResult || !secondaryResult) return null;

  const distinctness = pair.distinctness_per_layer;
  const avgDistinctness =
    distinctness.reduce((a, b) => a + b, 0) / distinctness.length;

  const pColor = CONCEPT_COLORS[pair.primary] ?? "#8b5cf6";
  const sColor = CONCEPT_COLORS[pair.secondary] ?? "#06b6d4";

  const pSignature = useMemo(
    () => extractConceptSignature(primaryResult, selectedLayer),
    [primaryResult, selectedLayer],
  );
  const sSignature = useMemo(
    () => extractConceptSignature(secondaryResult, selectedLayer),
    [secondaryResult, selectedLayer],
  );
  const signatureOverlapCount = useMemo(() => {
    const pSet = new Set(pSignature.map((n) => `${n.head}_${n.idx}`));
    return sSignature.filter((n) => pSet.has(`${n.head}_${n.idx}`)).length;
  }, [pSignature, sSignature]);

  return (
    <div className="space-y-4">
      <div className="flex flex-wrap gap-2">
        {crossPairs.map((cp, i) => {
          const pName =
            PRESETS.find((p) => p.id === cp.primary)?.name ?? cp.primary;
          const sName =
            PRESETS.find((p) => p.id === cp.secondary)?.name ?? cp.secondary;
          return (
            <motion.button
              key={i}
              onClick={() => setActivePair(i)}
              className={`px-3 py-2 rounded-xl text-xs font-semibold border transition-all ${
                i === activePair
                  ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
                  : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
              }`}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              {pName} <span className="text-[#4A5568] mx-1">vs</span> {sName}
            </motion.button>
          );
        })}
      </div>

      {/* Distinctness bar chart */}
      <motion.div
        className="glass-card p-5"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        key={activePair}
      >
        <div className="flex items-center justify-between mb-3">
          <div className="flex items-center gap-2">
            <GitCompare size={16} className="text-[#8B95A5]" />
            <span className="text-sm font-semibold">
              Neuron Distinctness per Layer
            </span>
          </div>
          <span
            className={`text-xs font-mono font-bold ${avgDistinctness > 0.5 ? "text-[#00C896]" : avgDistinctness > 0.3 ? "text-[#CBD5E0]" : "text-[#4A5568]"}`}
          >
            avg: {avgDistinctness.toFixed(3)}
          </span>
        </div>
        <p className="text-[10px] text-[#4A5568] mb-3">
          1 − Jaccard overlap of top-neuron sets. Higher = more distinct.
          Expected: 0.3–0.5 for byte-level models.
        </p>
        <div className="flex items-end gap-2 h-28">
          {distinctness.map((d, i) => (
            <motion.div
              key={i}
              className="flex-1 flex flex-col items-center gap-1"
              initial={{ scaleY: 0 }}
              animate={{ scaleY: 1 }}
              transition={{ delay: i * 0.06, duration: 0.4 }}
              style={{ transformOrigin: "bottom" }}
            >
              <span className="text-[9px] font-mono text-[#4A5568] mb-0.5">
                {d.toFixed(2)}
              </span>
              <div
                className="w-full rounded-t-md transition-all"
                style={{
                  height: `${d * 100}%`,
                  backgroundColor:
                    d > 0.7
                      ? "rgba(16,185,129,0.7)"
                      : d > 0.4
                        ? "rgba(245,158,11,0.7)"
                        : "rgba(239,68,68,0.5)",
                  boxShadow:
                    i === selectedLayer
                      ? "0 0 12px rgba(139,92,246,0.5)"
                      : undefined,
                  outline:
                    i === selectedLayer
                      ? "2px solid rgba(139,92,246,0.6)"
                      : undefined,
                }}
              />
              <span
                className={`text-[9px] font-mono ${i === selectedLayer ? "text-white font-bold" : "text-[#4A5568]"}`}
              >
                L{i}
              </span>
            </motion.div>
          ))}
        </div>

        {avgDistinctness > 0.65 ? (
          <motion.div
            className="mt-4 p-3 rounded-xl bg-white/\[0.03\] border border-white/\[0.06\]"
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
          >
            <p className="text-xs text-[#CBD5E0]">
              <strong>{(avgDistinctness * 100).toFixed(0)}%</strong> average
              distinctness — BDH dedicates <em>separate</em> neuron populations
              to each concept at the byte-pattern level.
            </p>
          </motion.div>
        ) : avgDistinctness > 0.25 ? (
          <motion.div
            className="mt-4 p-3 rounded-xl bg-white/\[0.03\] border border-white/\[0.06\]"
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
          >
            <p className="text-xs text-[#8B95A5]">
              <strong>{(avgDistinctness * 100).toFixed(0)}%</strong>{" "}
              distinctness — moderate overlap expected at byte-level. Full
              separation lives in the σ-matrix.
            </p>
          </motion.div>
        ) : null}
      </motion.div>

      {/* Concept Neuron Signatures */}
      <motion.div
        className="glass-card p-5"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.15 }}
        key={`sig-${activePair}-${selectedLayer}`}
      >
        <div className="flex items-center gap-2 mb-1">
          <Zap size={14} className="text-[#8B95A5]" />
          <span className="text-sm font-semibold">
            Concept Neuron Signatures — Layer {selectedLayer}
          </span>
        </div>
        <p className="text-[10px] text-[#4A5568] mb-4">
          Neurons firing for 2+ words in the same concept.
          {signatureOverlapCount > 0 ? (
            <span className="text-[#8B95A5]">
              {" "}
              {signatureOverlapCount} shared neurons.
            </span>
          ) : (
            <span className="text-[#00C896]"> ✓ Disjoint!</span>
          )}
        </p>

        <div className="grid gap-6 md:grid-cols-2 mb-4">
          {[
            { sig: pSignature, color: pColor, label: pair.primary },
            { sig: sSignature, color: sColor, label: pair.secondary },
          ].map(({ sig, color, label }) => {
            const preset = presetOf(label);
            const byHead: Record<number, typeof sig> = {};
            sig.forEach((n) => {
              (byHead[n.head] ??= []).push(n);
            });
            return (
              <div key={label}>
                <div className="flex items-center gap-2 mb-2">
                  <span
                    className="w-2 h-2 rounded-full"
                    style={{ backgroundColor: color }}
                  />
                  <span
                    className="text-xs font-bold uppercase tracking-wider"
                    style={{ color }}
                  >
                    {preset?.name ?? label}
                  </span>
                  <span className="text-[10px] text-[#4A5568] ml-auto font-mono">
                    {sig.length} signature neurons
                  </span>
                </div>
                {[0, 1, 2, 3].map((head) => {
                  const neurons = byHead[head] ?? [];
                  return (
                    <div key={head} className="flex items-center gap-1.5 mb-1">
                      <span className="text-[9px] font-mono text-[#4A5568] w-6 shrink-0">
                        H{head}
                      </span>
                      <div className="flex flex-wrap gap-1">
                        {neurons.length === 0 ? (
                          <span className="text-[8px] text-[#374151] italic">
                            none
                          </span>
                        ) : (
                          neurons.slice(0, 8).map((n) => (
                            <span
                              key={n.idx}
                              className="text-[8px] font-mono px-1.5 py-0.5 rounded-md"
                              style={{
                                backgroundColor: color + "18",
                                color,
                                border: `1px solid ${color}33`,
                              }}
                              title={`Shared by ${n.count} words, Σ act = ${n.totalVal.toFixed(3)}`}
                            >
                              #{n.idx}
                            </span>
                          ))
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            );
          })}
        </div>
      </motion.div>

      {/* Side-by-side word fingerprints */}
      <div className="grid gap-4 md:grid-cols-2">
        {[
          {
            result: primaryResult,
            color: pColor,
            label: pair.primary,
          },
          {
            result: secondaryResult,
            color: sColor,
            label: pair.secondary,
          },
        ].map(({ result: conceptResult, color, label }) => (
          <div key={label} className="space-y-3">
            <div className="flex items-center gap-2">
              <span
                className="text-xs font-bold uppercase tracking-wider"
                style={{ color }}
              >
                {presetOf(label)?.icon} {presetOf(label)?.name}
              </span>
            </div>
            {conceptResult.words.map((fp, i) => {
              const layer = fp.layers.find((l) => l.layer === selectedLayer);
              if (!layer) return null;
              const totalActive = layer.heads.reduce(
                (s, h) => s + h.x_active,
                0,
              );
              return (
                <motion.div
                  key={fp.word}
                  className="rounded-xl p-4 bg-[#0B1216]/50 border border-white/[0.06] backdrop-blur-sm"
                  style={{ borderLeftWidth: 3, borderLeftColor: color }}
                  initial={{
                    opacity: 0,
                    x: label === pair.primary ? -12 : 12,
                  }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: i * 0.06 }}
                >
                  <div className="flex items-center justify-between mb-2">
                    <span
                      className="text-sm font-mono font-bold"
                      style={{ color }}
                    >
                      {fp.word}
                    </span>
                    <span className="text-[10px] text-[#4A5568] font-mono">
                      {totalActive.toLocaleString()} active
                    </span>
                  </div>
                  <div className="space-y-1">
                    {layer.heads.map((h) => (
                      <NeuronStrip
                        key={h.head}
                        neurons={h.top_neurons}
                        label={`H${h.head}`}
                        color={color}
                      />
                    ))}
                  </div>
                </motion.div>
              );
            })}
          </div>
        ))}
      </div>
    </div>
  );
}

/* ================================================================== */
/*  3. SYNAPSE TRACKING VIEW (NEW)                                     */
/* ================================================================== */
function SynapseTrackingView({
  tracking,
  activeConcept,
  setActiveConcept,
}: {
  tracking: Record<string, ConceptTracking>;
  activeConcept: string;
  setActiveConcept: (c: string) => void;
}) {
  const [activeSentence, setActiveSentence] = useState(0);
  const [showDelta, setShowDelta] = useState(true);
  const conceptTrack = tracking[activeConcept];

  if (!conceptTrack || conceptTrack.sentences.length === 0) {
    return (
      <motion.div
        className="glass-card p-6 text-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        <Activity size={32} className="mx-auto text-[#4A5568] mb-3" />
        <p className="text-[#8B95A5] text-sm">
          No synapse tracking data available. Run the enhanced precompute script
          to generate timeseries data.
        </p>
      </motion.div>
    );
  }

  const sent = conceptTrack.sentences[activeSentence];
  const synapses = conceptTrack.synapses;
  const wordTimeline = sent?.words ?? [];

  // Max sigma or delta for normalization
  const { maxSigma, maxDelta } = useMemo(() => {
    let mxS = 1e-6;
    let mxD = 1e-6;
    wordTimeline.forEach((w) => {
      Object.values(w.sigma).forEach((v) => {
        if (Math.abs(v) > mxS) mxS = Math.abs(v);
      });
      Object.values(w.delta_sigma).forEach((v) => {
        if (Math.abs(v) > mxD) mxD = Math.abs(v);
      });
    });
    return { maxSigma: mxS, maxDelta: mxD };
  }, [wordTimeline]);

  const maxVal = showDelta ? maxDelta : maxSigma;

  // Contrast ratio: mean Δσ at concept words / mean Δσ at all words
  const contrastRatios = useMemo(() => {
    const ratios: Record<
      string,
      { ratio: number; conceptMean: number; allMean: number }
    > = {};
    synapses.forEach((syn) => {
      let conceptSum = 0,
        conceptCount = 0;
      let allSum = 0,
        allCount = 0;
      wordTimeline.forEach((w) => {
        const d = Math.abs(w.delta_sigma[syn.id] || 0);
        allSum += d;
        allCount += 1;
        if (w.is_concept) {
          conceptSum += d;
          conceptCount += 1;
        }
      });
      const conceptMean = conceptCount > 0 ? conceptSum / conceptCount : 0;
      const allMean = allCount > 0 ? allSum / allCount : 0;
      const ratio = allMean > 1e-10 ? conceptMean / allMean : 0;
      ratios[syn.id] = { ratio, conceptMean, allMean };
    });
    return ratios;
  }, [synapses, wordTimeline]);

  // Helper to get RGB components from hex color
  const hexToRgb = (hex: string) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `${r},${g},${b}`;
  };

  return (
    <div className="space-y-4">
      {/* Concept selector */}
      <div className="flex flex-wrap gap-2">
        {Object.keys(tracking).map((cid) => {
          const preset = presetOf(cid);
          const c = CONCEPT_COLORS[cid] ?? "#8b5cf6";
          return (
            <button
              key={cid}
              onClick={() => {
                setActiveConcept(cid);
                setActiveSentence(0);
              }}
              className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
                activeConcept === cid
                  ? "shadow-lg"
                  : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
              }`}
              style={
                activeConcept === cid
                  ? {
                      borderColor: `${c}50`,
                      backgroundColor: `${c}15`,
                      color: c,
                    }
                  : undefined
              }
            >
              {preset?.name ?? cid}
            </button>
          );
        })}
      </div>

      {/* Sentence selector */}
      <div className="flex flex-wrap gap-2">
        {conceptTrack.sentences.map((s, i) => (
          <button
            key={i}
            onClick={() => setActiveSentence(i)}
            className={`px-3 py-1.5 rounded-lg text-[11px] font-mono border transition-all max-w-xs truncate ${
              i === activeSentence
                ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
                : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#4A5568] hover:text-[#CBD5E0]"
            }`}
          >
            "{s.sentence}"
          </button>
        ))}
      </div>

      {/* Tracked synapses legend */}
      <motion.div
        className="glass-card p-4"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex items-center gap-2 mb-3">
          <Activity size={14} className="text-[#8B95A5]" />
          <span className="text-sm font-semibold">Tracked Synapses σ(i,j)</span>
          <span className="text-[10px] text-[#4A5568] ml-auto">
            Top monosemantic synapses for{" "}
            {presetOf(activeConcept)?.name ?? activeConcept}
          </span>
        </div>
        <p className="text-[10px] text-[#4A5568] mb-3">
          σ(i,j) = Σ y_sparse · x_sparse — Hebbian co-activation per word.
        </p>
        <div className="flex flex-wrap gap-3">
          {synapses.map((syn, i) => (
            <div
              key={syn.id}
              className="flex items-center gap-2 px-2.5 py-1.5 rounded-lg border"
              style={{
                borderColor: SYNAPSE_COLORS[i % SYNAPSE_COLORS.length] + "40",
                backgroundColor:
                  SYNAPSE_COLORS[i % SYNAPSE_COLORS.length] + "10",
              }}
            >
              <span
                className="w-3 h-3 rounded-full"
                style={{
                  backgroundColor: SYNAPSE_COLORS[i % SYNAPSE_COLORS.length],
                }}
              />
              <span
                className="text-[10px] font-mono font-bold"
                style={{
                  color: SYNAPSE_COLORS[i % SYNAPSE_COLORS.length],
                }}
              >
                {syn.id}
              </span>
              <span className="text-[9px] text-[#4A5568]">
                sel: {syn.selectivity.toFixed(2)}
              </span>
              {contrastRatios[syn.id] && contrastRatios[syn.id].ratio > 0 && (
                <span
                  className={`text-[9px] font-mono font-bold ${
                    contrastRatios[syn.id].ratio >= 2.0
                      ? "text-[#00C896]"
                      : contrastRatios[syn.id].ratio >= 1.3
                        ? "text-[#CBD5E0]"
                        : "text-[#4A5568]"
                  }`}
                >
                  {contrastRatios[syn.id].ratio.toFixed(1)}×
                </span>
              )}
            </div>
          ))}
        </div>
      </motion.div>

      {/* Contrast ratio summary */}
      {(() => {
        const ratioEntries = Object.entries(contrastRatios).filter(
          ([, v]) => v.ratio > 0,
        );
        const avgRatio =
          ratioEntries.length > 0
            ? ratioEntries.reduce((s, [, v]) => s + v.ratio, 0) /
              ratioEntries.length
            : 0;
        const bestEntry = ratioEntries.sort(
          (a, b) => b[1].ratio - a[1].ratio,
        )[0];
        if (avgRatio < 0.1) return null;
        return (
          <motion.div
            className={`p-3 rounded-xl border ${
              avgRatio >= 1.5
                ? "bg-white/\[0.03\] border-white/\[0.06\]"
                : "bg-white/\[0.02\] border-white/\[0.04\]"
            }`}
            initial={{ opacity: 0, y: 6 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
          >
            <p
              className={`text-xs ${avgRatio >= 1.5 ? "text-[#00C896]" : "text-[#8B95A5]"}`}
            >
              <strong>Contrast ratio</strong>: avg{" "}
              <strong>{avgRatio.toFixed(1)}×</strong>
              {bestEntry && (
                <>
                  {" "}
                  (best: <strong>{bestEntry[0]}</strong> at{" "}
                  <strong>{bestEntry[1].ratio.toFixed(1)}×</strong>)
                </>
              )}
              {avgRatio >= 1.5
                ? " — strong concept selectivity."
                : " — moderate preference."}
            </p>
          </motion.div>
        );
      })()}

      {/* Mode toggle: cumulative σ vs Δσ per word */}
      <div className="flex items-center gap-3">
        <button
          onClick={() => setShowDelta(false)}
          className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
            !showDelta
              ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
              : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:text-[#E2E8F0]"
          }`}
        >
          Cumulative σ (build-up)
        </button>
        <button
          onClick={() => setShowDelta(true)}
          className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
            showDelta
              ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
              : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:text-[#E2E8F0]"
          }`}
        >
          Δσ per word (jumps)
        </button>
      </div>

      {/* Word-level σ timeline */}
      <motion.div
        className="glass-card p-5"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
        key={`${activeConcept}-${activeSentence}-${showDelta}`}
      >
        <div className="flex items-center gap-2 mb-4">
          <Zap size={14} className="text-[#8B95A5]" />
          <span className="text-sm font-semibold">
            {showDelta
              ? "Δσ per Word (Synaptic Jump)"
              : "Cumulative σ (Synaptic Build-up)"}
          </span>
        </div>

        {/* Word strip */}
        <div className="flex gap-1 mb-2 overflow-x-auto pb-1">
          {wordTimeline.map((w, wi) => (
            <div
              key={wi}
              className="flex flex-col items-center"
              style={{ minWidth: 60 }}
            >
              <span
                className={`text-[11px] font-mono leading-tight px-1 py-0.5 rounded ${
                  w.is_concept
                    ? "text-[#8B95A5] font-bold bg-amber-500/15 border border-amber-500/30"
                    : "text-[#8B95A5]"
                }`}
              >
                {w.word}
              </span>
            </div>
          ))}
        </div>

        {/* Per-synapse heatmap rows (word-level) */}
        {synapses.map((syn, si) => {
          const synColor = SYNAPSE_COLORS[si % SYNAPSE_COLORS.length];
          const rgb = hexToRgb(synColor);
          return (
            <div key={syn.id} className="flex gap-1 mb-[3px] items-center">
              <span
                className="text-[8px] font-mono w-24 shrink-0 text-right pr-1"
                style={{ color: synColor }}
              >
                {syn.id}
              </span>
              <div className="flex gap-1 flex-1 overflow-x-auto">
                {wordTimeline.map((w, wi) => {
                  const val = showDelta
                    ? w.delta_sigma[syn.id] || 0
                    : w.sigma[syn.id] || 0;
                  const t = maxVal > 0 ? Math.abs(val) / maxVal : 0;
                  return (
                    <motion.div
                      key={wi}
                      className="rounded-sm"
                      style={{
                        minWidth: 60,
                        height: 18,
                        backgroundColor:
                          t > 0.02
                            ? `rgba(${rgb},${(0.1 + t * 0.9).toFixed(2)})`
                            : "rgba(30,30,40,0.3)",
                        boxShadow:
                          t > 0.3 ? `0 0 6px ${synColor}40` : undefined,
                        border:
                          w.is_concept && t > 0.1
                            ? `1px solid ${synColor}60`
                            : "1px solid transparent",
                      }}
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      transition={{ delay: wi * 0.02 }}
                      title={`${w.word}: ${showDelta ? "Δ" : ""}σ=${val.toFixed(6)}`}
                    />
                  );
                })}
              </div>
            </div>
          );
        })}

        {/* σ line chart — word-by-word */}
        <div className="mt-4 h-40 relative">
          <svg
            viewBox={`0 0 ${Math.max(wordTimeline.length * 62 + 80, 300)} 140`}
            className="w-full h-full"
            preserveAspectRatio="xMinYMin meet"
          >
            {/* Concept word highlight bands */}
            {wordTimeline.map((w, wi) =>
              w.is_concept ? (
                <rect
                  key={`bg-${wi}`}
                  x={80 + wi * 62}
                  y={0}
                  width={60}
                  height={140}
                  fill="rgba(245,158,11,0.06)"
                  rx={4}
                />
              ) : null,
            )}
            {/* Lines per synapse */}
            {synapses.map((syn, si) => {
              const synColor = SYNAPSE_COLORS[si % SYNAPSE_COLORS.length];
              const points = wordTimeline.map((w, wi) => {
                const val = showDelta
                  ? w.delta_sigma[syn.id] || 0
                  : w.sigma[syn.id] || 0;
                const x = 80 + wi * 62 + 30;
                const y = 125 - (Math.abs(val) / maxVal) * 110;
                return `${x},${y}`;
              });
              return (
                <g key={syn.id}>
                  <motion.polyline
                    points={points.join(" ")}
                    fill="none"
                    stroke={synColor}
                    strokeWidth="2.5"
                    strokeOpacity="0.9"
                    strokeLinejoin="round"
                    strokeLinecap="round"
                    initial={{ pathLength: 0 }}
                    animate={{ pathLength: 1 }}
                    transition={{ duration: 1, delay: si * 0.15 }}
                  />
                  {/* Dots at each word */}
                  {wordTimeline.map((w, wi) => {
                    const val = showDelta
                      ? w.delta_sigma[syn.id] || 0
                      : w.sigma[syn.id] || 0;
                    const x = 80 + wi * 62 + 30;
                    const y = 125 - (Math.abs(val) / maxVal) * 110;
                    const t = maxVal > 0 ? Math.abs(val) / maxVal : 0;
                    return t > 0.05 ? (
                      <motion.circle
                        key={wi}
                        cx={x}
                        cy={y}
                        r={w.is_concept ? 5 : 3}
                        fill={synColor}
                        fillOpacity={w.is_concept ? 1 : 0.6}
                        stroke={w.is_concept ? "white" : "none"}
                        strokeWidth={w.is_concept ? 1.5 : 0}
                        initial={{ scale: 0 }}
                        animate={{ scale: 1 }}
                        transition={{ delay: wi * 0.04 + si * 0.15 }}
                      />
                    ) : null;
                  })}
                </g>
              );
            })}
            {/* Y-axis labels */}
            <text
              x="0"
              y="18"
              fill="#6b7280"
              fontSize="9"
              fontFamily="monospace"
            >
              {maxVal.toFixed(3)}
            </text>
            <text
              x="0"
              y="128"
              fill="#6b7280"
              fontSize="9"
              fontFamily="monospace"
            >
              0.000
            </text>
            {/* Word labels at bottom */}
            {wordTimeline.map((w, wi) => (
              <text
                key={wi}
                x={80 + wi * 62 + 30}
                y={138}
                fill={w.is_concept ? "#fbbf24" : "#6b7280"}
                fontSize={w.is_concept ? "8" : "7"}
                fontFamily="monospace"
                textAnchor="middle"
                fontWeight={w.is_concept ? "bold" : "normal"}
              >
                {w.word.length > 8 ? w.word.slice(0, 7) + "…" : w.word}
              </text>
            ))}
          </svg>
        </div>

        <motion.div
          className="mt-3 p-3 rounded-xl bg-white/\[0.03\] border border-white/\[0.06\]"
          initial={{ opacity: 0, y: 6 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5 }}
        >
          <p className="text-xs text-[#8B95A5]">
            {showDelta ? (
              <>
                <strong>Δσ</strong> = per-word synaptic jump. Concept words
                (highlighted) cause the largest spikes.
              </>
            ) : (
              <>
                <strong>Cumulative σ</strong> builds up token-by-token. Steepest
                steps at concept words.
              </>
            )}
          </p>
        </motion.div>
      </motion.div>
    </div>
  );
}

/* ================================================================== */
/*  4. SELECTIVITY VIEW (NEW)                                          */
/* ================================================================== */
function SelectivityView({
  selectivity,
  concepts,
  activeConcept,
  setActiveConcept,
}: {
  selectivity: PrecomputedData["selectivity"];
  concepts: Record<string, FingerprintResult>;
  activeConcept: string;
  setActiveConcept: (c: string) => void;
}) {
  if (!selectivity) {
    return (
      <motion.div
        className="glass-card p-6 text-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        <BarChart2 size={32} className="mx-auto text-[#4A5568] mb-3" />
        <p className="text-[#8B95A5] text-sm">
          No selectivity data available. Run the enhanced precompute script with
          Mann-Whitney U test support.
        </p>
      </motion.div>
    );
  }

  const histogram = selectivity.histogram;
  const maxCount = Math.max(1, ...histogram.map((h) => h.count));
  const concept = concepts[activeConcept];
  const monoNeurons = concept?.monosemantic_neurons ?? [];
  const significantCount = monoNeurons.filter((n) => n.p_value < 0.05).length;

  return (
    <div className="space-y-4">
      {/* Concept selector */}
      <div className="flex flex-wrap gap-2">
        {Object.keys(concepts).map((cid) => {
          const preset = presetOf(cid);
          const c = CONCEPT_COLORS[cid] ?? "#8b5cf6";
          const nMono = concepts[cid]?.monosemantic_neurons?.length ?? 0;
          return (
            <button
              key={cid}
              onClick={() => setActiveConcept(cid)}
              className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
                activeConcept === cid
                  ? "shadow-lg"
                  : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
              }`}
              style={
                activeConcept === cid
                  ? {
                      borderColor: `${c}50`,
                      backgroundColor: `${c}15`,
                      color: c,
                    }
                  : undefined
              }
            >
              {preset?.name ?? cid}
              <span className="ml-1.5 text-[10px] opacity-70">({nMono})</span>
            </button>
          );
        })}
      </div>

      {/* Global selectivity histogram */}
      <motion.div
        className="glass-card p-5"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex items-center justify-between mb-3">
          <div className="flex items-center gap-2">
            <BarChart2 size={16} className="text-[#8B95A5]" />
            <span className="text-sm font-semibold">
              Selectivity Distribution (All Concepts)
            </span>
          </div>
          <div className="flex items-center gap-3 text-xs text-[#8B95A5]">
            <span>
              Total:{" "}
              <strong className="text-[#E2E8F0]">
                {selectivity.total_neurons.toLocaleString()}
              </strong>{" "}
              neurons
            </span>
            <span>
              Selective (&gt;0.6):{" "}
              <strong className="text-[#00C896]">
                {selectivity.total_selective.toLocaleString()}
              </strong>
            </span>
            <span>
              Mean:{" "}
              <strong className="text-[#00C896]">
                {selectivity.mean_selectivity.toFixed(3)}
              </strong>
            </span>
          </div>
        </div>
        <p className="text-[10px] text-[#4A5568] mb-3">
          Selectivity = mean_in / (mean_in + mean_out). Near 1.0 = exclusive.
          Near 0.5 = non-selective.
        </p>

        <div className="flex items-end gap-[3px] h-32">
          {histogram.map((bin, i) => {
            const h = (bin.count / maxCount) * 100;
            const isHighSel = bin.bin_start >= 0.75;
            const isMedSel = bin.bin_start >= 0.5;
            return (
              <motion.div
                key={i}
                className="flex-1 flex flex-col items-center"
                initial={{ scaleY: 0 }}
                animate={{ scaleY: 1 }}
                transition={{ delay: i * 0.03, duration: 0.3 }}
                style={{ transformOrigin: "bottom" }}
              >
                {bin.count > 0 && (
                  <span className="text-[7px] font-mono text-[#4A5568] mb-0.5">
                    {bin.count}
                  </span>
                )}
                <div
                  className="w-full rounded-t-sm"
                  style={{
                    height: `${Math.max(h, bin.count > 0 ? 3 : 0)}%`,
                    backgroundColor: isHighSel
                      ? "rgba(16,185,129,0.8)"
                      : isMedSel
                        ? "rgba(245,158,11,0.7)"
                        : "rgba(100,116,139,0.3)",
                    boxShadow: isHighSel
                      ? "0 0 8px rgba(16,185,129,0.3)"
                      : undefined,
                  }}
                  title={`${bin.bin_start.toFixed(2)}–${bin.bin_end.toFixed(2)}: ${bin.count}`}
                />
              </motion.div>
            );
          })}
        </div>
        <div className="flex justify-between mt-1">
          <span className="text-[9px] font-mono text-[#4A5568]">
            0.0 (non-selective)
          </span>
          <span className="text-[9px] font-mono text-[#00C896]">
            1.0 (exclusive)
          </span>
        </div>

        {/* Threshold markers */}
        <div className="flex items-center gap-4 mt-3 text-[10px] text-[#4A5568]">
          <span className="flex items-center gap-1">
            <span className="w-2 h-2 rounded-full bg-[#00C896]" /> ≥ 0.75
            (strong selectivity)
          </span>
          <span className="flex items-center gap-1">
            <span className="w-2 h-2 rounded-full bg-amber-500" /> ≥ 0.50
            (selective)
          </span>
          <span className="flex items-center gap-1">
            <span className="w-2 h-2 rounded-full bg-[#4A5568]" /> &lt; 0.50
            (non-selective)
          </span>
        </div>
      </motion.div>

      {/* Per-concept monosemantic neurons table */}
      <MonosemanticNeuronPanel
        neurons={monoNeurons}
        words={concept?.words.map((w) => w.word) ?? []}
        conceptName={presetOf(activeConcept)?.name ?? activeConcept}
      />

      {/* Statistical summary */}
      {significantCount > 0 && (
        <motion.div
          className="p-4 rounded-xl bg-white/\[0.03\] border border-white/\[0.06\]"
          initial={{ opacity: 0, y: 8 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
        >
          <p className="text-xs text-[#CBD5E0]">
            <strong>{significantCount}</strong> of {monoNeurons.length} neurons
            pass Mann-Whitney U (p &lt; 0.05) for{" "}
            <strong>{presetOf(activeConcept)?.name}</strong> — statistically
            significant selectivity.
          </p>
        </motion.div>
      )}
    </div>
  );
}

/* ================================================================== */
/*  5. INTERSECTION VIEW                                               */
/* ================================================================== */
function IntersectionView({
  result,
  selectedLayer,
}: {
  result: FingerprintResult;
  selectedLayer: number;
}) {
  const [refIdx, setRefIdx] = useState(0);
  const words = result.words;
  const refWord = words[refIdx];
  if (!refWord) return null;

  const refLayer = refWord.layers.find((l) => l.layer === selectedLayer);
  if (!refLayer) return null;

  const refActiveNeurons: Map<number, Set<number>> = useMemo(() => {
    const m = new Map<number, Set<number>>();
    refLayer.heads.forEach((h) => {
      const s = new Set<number>();
      h.top_neurons.forEach((n) => s.add(n.idx));
      m.set(h.head, s);
    });
    return m;
  }, [refLayer]);

  return (
    <div className="space-y-4">
      <motion.div
        className="glass-card p-4"
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex items-center gap-3 flex-wrap">
          <span className="text-xs text-[#8B95A5] font-semibold uppercase tracking-wider">
            Reference word:
          </span>
          {words.map((w, i) => (
            <button
              key={w.word}
              onClick={() => setRefIdx(i)}
              className={`px-3 py-1.5 rounded-lg text-sm font-mono font-semibold transition-all border ${
                i === refIdx
                  ? "bg-[#00C896]/20 border-[#00C896]/50 text-[#CBD5E0]"
                  : "bg-white/\[0.03\] border-white/10 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
              }`}
            >
              {w.word}
            </button>
          ))}
        </div>
        <p className="text-[11px] text-[#4A5568] mt-2">
          <span className="inline-block w-3 h-2 rounded-[1px] bg-[#00C896]/60 mr-1 align-middle" />
          Green = shared with <strong>"{refWord.word}"</strong>
          <span className="inline-block w-3 h-2 rounded-[1px] bg-[#4A5568]/20 ml-3 mr-1 align-middle" />
          Dim = unique to this word
        </p>
      </motion.div>

      <motion.div
        className="rounded-xl p-5 border border-[#00C896]/40 bg-gradient-to-br from-[#00C896]/5 to-[#0B1216]/50 backdrop-blur-sm"
        style={{ borderLeftWidth: 4, borderLeftColor: "#10b981" }}
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.05 }}
      >
        <div className="flex items-center gap-2 mb-3">
          <div
            className="w-3 h-3 rounded-full ring-2 ring-[#00C896]/30"
            style={{
              backgroundColor: WORD_COLORS[refIdx % WORD_COLORS.length],
            }}
          />
          <span
            className="font-mono font-bold text-lg"
            style={{ color: WORD_COLORS[refIdx % WORD_COLORS.length] }}
          >
            "{refWord.word}"
          </span>
          <span className="text-[10px] uppercase tracking-wider bg-[#00C896]/15 text-[#CBD5E0] font-bold px-2 py-0.5 rounded-full ml-2">
            REFERENCE
          </span>
        </div>
        <div className="space-y-1">
          {refLayer.heads.map((h, hi) => (
            <NeuronStrip
              key={hi}
              neurons={h.top_neurons}
              label={`H${h.head}`}
              delay={hi * 0.02}
              color="rgba(16,185,129,0.8)"
            />
          ))}
        </div>
      </motion.div>

      {words
        .filter((_, i) => i !== refIdx)
        .map((fp, ci) => {
          const layer = fp.layers.find((l) => l.layer === selectedLayer);
          if (!layer) return null;
          const origIdx = words.indexOf(fp);
          const color = WORD_COLORS[origIdx % WORD_COLORS.length];

          let sharedCount = 0,
            totalActive = 0;
          layer.heads.forEach((h) => {
            const refSet = refActiveNeurons.get(h.head);
            h.top_neurons.forEach((n) => {
              totalActive++;
              if (refSet?.has(n.idx)) sharedCount++;
            });
          });
          const overlapPct =
            totalActive > 0
              ? ((sharedCount / totalActive) * 100).toFixed(0)
              : "0";

          return (
            <motion.div
              key={fp.word}
              className="rounded-xl p-4 overflow-hidden bg-[#0B1216]/50 border border-white/[0.06] backdrop-blur-sm"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: ci * 0.08 + 0.1 }}
            >
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-2">
                  <div
                    className="w-3 h-3 rounded-full"
                    style={{ backgroundColor: color }}
                  />
                  <span
                    className="font-mono font-bold text-base"
                    style={{ color }}
                  >
                    "{fp.word}"
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-16 h-2 bg-white/5 rounded-full overflow-hidden">
                    <motion.div
                      className="h-full rounded-full bg-gradient-to-r from-[#00C896] to-[#00C896]"
                      initial={{ width: 0 }}
                      animate={{ width: `${overlapPct}%` }}
                      transition={{ delay: ci * 0.1 + 0.3, duration: 0.5 }}
                    />
                  </div>
                  <span className="text-xs font-bold text-[#CBD5E0] font-mono w-10 text-right">
                    {overlapPct}%
                  </span>
                </div>
              </div>
              <div className="space-y-1">
                {layer.heads.map((h, hi) => (
                  <NeuronStrip
                    key={hi}
                    neurons={h.top_neurons}
                    label={`H${h.head}`}
                    delay={ci * 0.08 + hi * 0.02 + 0.1}
                    highlightNeurons={refActiveNeurons.get(h.head)}
                  />
                ))}
              </div>
            </motion.div>
          );
        })}
    </div>
  );
}

/* ================================================================== */
/*  6. NEURON GRAPH VIEW                                               */
/* ================================================================== */
interface GraphNode {
  id: string;
  label: string;
  type: "neuron" | "word";
  color: string;
  radius: number;
  x: number;
  y: number;
  val?: number;
  wordCount?: number;
  head?: number;
}
interface GraphEdge {
  source: string;
  target: string;
  color: string;
  width: number;
  shared: boolean;
}

function NeuronGraphView({
  result,
  selectedLayer,
}: {
  result: FingerprintResult;
  selectedLayer: number;
}) {
  const containerRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement>(null);
  const [dims, setDims] = useState({ w: 900, h: 620 });
  const [hoveredNode, setHoveredNode] = useState<string | null>(null);
  const [filterHead, setFilterHead] = useState<number | null>(null);

  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const obs = new ResizeObserver((entries) => {
      const { width } = entries[0].contentRect;
      setDims({ w: width, h: Math.max(520, Math.min(width * 0.68, 720)) });
    });
    obs.observe(el);
    return () => obs.disconnect();
  }, []);

  const { nodes, edges, headCounts, totalShared, totalUnique } = useMemo(() => {
    const words = result.words;
    const cx = dims.w / 2;
    const cy = dims.h / 2;

    const neuronAgg = new Map<
      string,
      {
        head: number;
        idx: number;
        totalVal: number;
        wordCount: number;
        words: Map<string, number>;
      }
    >();
    words.forEach((w) => {
      const layer = w.layers.find((l) => l.layer === selectedLayer);
      if (!layer) return;
      layer.heads.forEach((h) => {
        h.top_neurons.forEach((n) => {
          const key = `n_H${h.head}_N${n.idx}`;
          const existing = neuronAgg.get(key);
          if (existing) {
            existing.totalVal += n.val;
            existing.wordCount++;
            existing.words.set(w.word, n.val);
          } else {
            neuronAgg.set(key, {
              head: h.head,
              idx: n.idx,
              totalVal: n.val,
              wordCount: 1,
              words: new Map([[w.word, n.val]]),
            });
          }
        });
      });
    });

    let shared = [...neuronAgg.entries()].filter(([, n]) => n.wordCount >= 2);
    const uniqueCount = neuronAgg.size - shared.length;

    if (filterHead !== null) {
      shared = shared.filter(([, n]) => n.head === filterHead);
    }

    shared.sort((a, b) =>
      b[1].wordCount !== a[1].wordCount
        ? b[1].wordCount - a[1].wordCount
        : b[1].totalVal - a[1].totalVal,
    );

    const topShared = shared.slice(0, 20);
    const maxVal = Math.max(1e-6, ...topShared.map(([, n]) => n.totalVal));

    const headCountsMap: Record<number, number> = {};
    shared.forEach(([, n]) => {
      headCountsMap[n.head] = (headCountsMap[n.head] || 0) + 1;
    });

    const outerR = Math.min(dims.w, dims.h) * 0.4;
    const innerR = Math.min(dims.w, dims.h) * 0.18;

    const nodeArr: GraphNode[] = [];
    const edgeList: GraphEdge[] = [];

    words.forEach((w, i) => {
      const angle = (2 * Math.PI * i) / words.length - Math.PI / 2;
      const color = WORD_COLORS[i % WORD_COLORS.length];
      nodeArr.push({
        id: `w_${w.word}`,
        label: w.word,
        type: "word",
        color,
        radius: 28,
        x: cx + Math.cos(angle) * outerR,
        y: cy + Math.sin(angle) * outerR,
      });
    });

    const hubsSortedByHead = [...topShared].sort(
      (a, b) => a[1].head - b[1].head,
    );
    hubsSortedByHead.forEach(([key, info], i) => {
      const angle = (2 * Math.PI * i) / hubsSortedByHead.length - Math.PI / 2;
      const r =
        10 +
        (info.wordCount / words.length) * 10 +
        (info.totalVal / maxVal) * 8;
      const headColor = HEAD_COLORS[info.head % HEAD_COLORS.length];

      nodeArr.push({
        id: key,
        label: `#${info.idx}`,
        type: "neuron",
        color: headColor,
        radius: Math.min(r, 26),
        x: cx + Math.cos(angle) * innerR,
        y: cy + Math.sin(angle) * innerR,
        val: info.totalVal,
        wordCount: info.wordCount,
        head: info.head,
      });

      info.words.forEach((act, wName) => {
        const wIdx = words.findIndex((w) => w.word === wName);
        const wordColor = WORD_COLORS[wIdx % WORD_COLORS.length];
        edgeList.push({
          source: `w_${wName}`,
          target: key,
          color: wordColor,
          width: 1.5 + (act / maxVal) * 2.5,
          shared: true,
        });
      });
    });

    const sim = d3
      .forceSimulation(nodeArr as any[])
      .force(
        "collide",
        d3
          .forceCollide<any>()
          .radius((d: any) => (d.radius || 10) + 6)
          .strength(0.8),
      )
      .force(
        "radial",
        d3
          .forceRadial(
            (d: any) => (d.type === "word" ? outerR : innerR),
            cx,
            cy,
          )
          .strength(0.6),
      )
      .force("charge", d3.forceManyBody().strength(-60))
      .stop();
    for (let i = 0; i < 180; i++) sim.tick();
    nodeArr.forEach((n) => {
      n.x = Math.max(n.radius + 12, Math.min(dims.w - n.radius - 12, n.x));
      n.y = Math.max(n.radius + 12, Math.min(dims.h - n.radius - 12, n.y));
    });

    return {
      nodes: nodeArr,
      edges: edgeList,
      headCounts: headCountsMap,
      totalShared: shared.length,
      totalUnique: uniqueCount,
    };
  }, [result, selectedLayer, dims, filterHead]);

  const nodeById = useMemo(() => {
    const m = new Map<string, GraphNode>();
    nodes.forEach((n) => m.set(n.id, n));
    return m;
  }, [nodes]);

  const hoveredEdges = useMemo(() => {
    if (!hoveredNode) return new Set<number>();
    const s = new Set<number>();
    edges.forEach((e, i) => {
      if (e.source === hoveredNode || e.target === hoveredNode) s.add(i);
    });
    return s;
  }, [hoveredNode, edges]);

  const hoveredNeighbors = useMemo(() => {
    if (!hoveredNode) return new Set<string>();
    const s = new Set<string>();
    edges.forEach((e) => {
      if (e.source === hoveredNode) s.add(e.target);
      if (e.target === hoveredNode) s.add(e.source);
    });
    s.add(hoveredNode);
    return s;
  }, [hoveredNode, edges]);

  const edgePath = useCallback((s: GraphNode, t: GraphNode) => {
    const dx = t.x - s.x;
    const dy = t.y - s.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) return `M${s.x},${s.y} L${t.x},${t.y}`;
    const curvature = Math.min(dist * 0.15, 35);
    const mx = (s.x + t.x) / 2 - (dy / dist) * curvature;
    const my = (s.y + t.y) / 2 + (dx / dist) * curvature;
    return `M${s.x},${s.y} Q${mx},${my} ${t.x},${t.y}`;
  }, []);

  const tooltipNode = hoveredNode ? nodeById.get(hoveredNode) : null;

  return (
    <motion.div
      ref={containerRef}
      className="glass-card p-5 overflow-hidden"
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
    >
      <div className="flex flex-wrap items-center justify-between gap-3 mb-4">
        <div className="flex items-center gap-2">
          <Network size={16} className="text-[#8B95A5]" />
          <span className="text-sm font-semibold">
            Shared-Neuron Hub Graph — Layer {selectedLayer}
          </span>
        </div>
        <div className="flex items-center gap-1.5 text-[10px]">
          <button
            onClick={() => setFilterHead(null)}
            className={`px-2 py-0.5 rounded-full border transition ${
              filterHead === null
                ? "border-white/\[0.12\] text-[#E2E8F0] bg-white/5"
                : "border-white/10 text-[#4A5568] hover:text-[#CBD5E0]"
            }`}
          >
            All Heads
          </button>
          {HEAD_COLORS.map((c, i) => (
            <button
              key={i}
              onClick={() => setFilterHead(filterHead === i ? null : i)}
              className={`px-2 py-0.5 rounded-full border transition ${
                filterHead === i
                  ? "bg-opacity-20 text-[#E2E8F0]"
                  : "border-white/10 text-[#4A5568] hover:text-[#CBD5E0]"
              }`}
              style={
                filterHead === i
                  ? { borderColor: c, backgroundColor: c + "22", color: c }
                  : {}
              }
            >
              H{i}
              {headCounts[i] ? ` (${headCounts[i]})` : ""}
            </button>
          ))}
        </div>
      </div>

      <div className="flex items-center gap-5 mb-3 text-[10px] text-[#8B95A5]">
        <span className="flex items-center gap-1.5">
          <span
            className="inline-block w-4 h-4 rounded-md border"
            style={{
              background: "rgba(139,92,246,0.25)",
              borderColor: "rgba(139,92,246,0.5)",
            }}
          />
          Word (outer ring)
        </span>
        {HEAD_COLORS.map((c, i) => (
          <span key={i} className="flex items-center gap-1">
            <span
              className="inline-block w-3 h-3 rounded-full"
              style={{ background: c, boxShadow: `0 0 6px ${c}55` }}
            />
            Head {i}
          </span>
        ))}
        <span className="ml-auto text-[#4A5568] font-mono">
          {totalShared} shared · {totalUnique} unique (hidden)
        </span>
      </div>

      <svg
        ref={svgRef}
        viewBox={`0 0 ${dims.w} ${dims.h}`}
        className="w-full"
        style={{ height: dims.h }}
      >
        <defs>
          <filter id="hub-glow">
            <feGaussianBlur stdDeviation="5" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
          </filter>
          <filter id="word-glow">
            <feGaussianBlur stdDeviation="4" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="over" />
          </filter>
          {WORD_COLORS.map((c, i) => (
            <radialGradient key={i} id={`wg-${i}`} cx="50%" cy="50%" r="50%">
              <stop offset="0%" stopColor={c} stopOpacity="0.9" />
              <stop offset="100%" stopColor={c} stopOpacity="0.45" />
            </radialGradient>
          ))}
          {HEAD_COLORS.map((c, i) => (
            <radialGradient key={i} id={`hg-${i}`} cx="40%" cy="35%" r="60%">
              <stop offset="0%" stopColor={c} stopOpacity="1" />
              <stop offset="100%" stopColor={c} stopOpacity="0.35" />
            </radialGradient>
          ))}
        </defs>

        <circle
          cx={dims.w / 2}
          cy={dims.h / 2}
          r={Math.min(dims.w, dims.h) * 0.18}
          fill="none"
          stroke="rgba(139,92,246,0.05)"
          strokeWidth="1"
          strokeDasharray="3 7"
        />
        <circle
          cx={dims.w / 2}
          cy={dims.h / 2}
          r={Math.min(dims.w, dims.h) * 0.4}
          fill="none"
          stroke="rgba(100,100,120,0.04)"
          strokeWidth="1"
          strokeDasharray="3 7"
        />

        {edges.map((e, i) => {
          const s = nodeById.get(e.source);
          const t = nodeById.get(e.target);
          if (!s || !t) return null;
          const isHoverActive = hoveredNode !== null;
          const isConnected = hoveredEdges.has(i);
          const opacity = isHoverActive ? (isConnected ? 0.85 : 0.04) : 0.35;

          return (
            <motion.path
              key={`e-${i}`}
              d={edgePath(s, t)}
              fill="none"
              stroke={e.color}
              strokeWidth={isConnected ? e.width + 1.5 : e.width}
              strokeOpacity={opacity}
              strokeLinecap="round"
              initial={{ pathLength: 0, opacity: 0 }}
              animate={{ pathLength: 1, opacity: 1 }}
              transition={{ delay: i * 0.008, duration: 0.5 }}
            />
          );
        })}

        {nodes.map((n, i) => {
          const isHoverActive = hoveredNode !== null;
          const isRelevant = hoveredNeighbors.has(n.id);
          const nodeOpacity = isHoverActive ? (isRelevant ? 1 : 0.12) : 1;
          const isWord = n.type === "word";
          const wordIdx = isWord
            ? result.words.findIndex((w) => `w_${w.word}` === n.id)
            : -1;

          return (
            <motion.g
              key={n.id}
              initial={{ opacity: 0, scale: 0 }}
              animate={{ opacity: nodeOpacity, scale: 1 }}
              transition={{ delay: i * 0.018, duration: 0.35 }}
              onMouseEnter={() => setHoveredNode(n.id)}
              onMouseLeave={() => setHoveredNode(null)}
              style={{ cursor: "pointer" }}
            >
              {isWord ? (
                <>
                  <circle
                    cx={n.x}
                    cy={n.y}
                    r={n.radius}
                    fill={`url(#wg-${wordIdx % WORD_COLORS.length})`}
                    stroke={n.color}
                    strokeWidth="2.5"
                    strokeOpacity="0.6"
                    filter="url(#word-glow)"
                  />
                  <text
                    x={n.x}
                    y={n.y + 4}
                    textAnchor="middle"
                    fill="white"
                    fontSize="11"
                    fontFamily="monospace"
                    fontWeight="800"
                    style={{ textShadow: "0 1px 3px rgba(0,0,0,0.7)" }}
                  >
                    {n.label}
                  </text>
                </>
              ) : (
                <>
                  <circle
                    cx={n.x}
                    cy={n.y}
                    r={n.radius + 4}
                    fill="none"
                    stroke={n.color}
                    strokeWidth="1.5"
                    strokeOpacity="0.2"
                    filter="url(#hub-glow)"
                  />
                  <circle
                    cx={n.x}
                    cy={n.y}
                    r={n.radius}
                    fill={`url(#hg-${(n.head ?? 0) % HEAD_COLORS.length})`}
                    stroke={n.color}
                    strokeWidth="2"
                    strokeOpacity="0.7"
                  />
                  <text
                    x={n.x}
                    y={n.y + 3.5}
                    textAnchor="middle"
                    fill="white"
                    fontSize={n.radius > 16 ? "9" : "7"}
                    fontFamily="monospace"
                    fontWeight="700"
                    style={{ textShadow: "0 1px 2px rgba(0,0,0,0.5)" }}
                  >
                    {n.label}
                  </text>
                  <text
                    x={n.x}
                    y={n.y - n.radius - 5}
                    textAnchor="middle"
                    fill={n.color}
                    fontSize="8"
                    fontFamily="monospace"
                    fontWeight="600"
                    opacity="0.75"
                  >
                    H{n.head}
                  </text>
                  {n.wordCount && n.wordCount >= 2 && (
                    <>
                      <circle
                        cx={n.x + n.radius * 0.72}
                        cy={n.y - n.radius * 0.72}
                        r={7}
                        fill="#18181b"
                        stroke={n.color}
                        strokeWidth="1.2"
                      />
                      <text
                        x={n.x + n.radius * 0.72}
                        y={n.y - n.radius * 0.72 + 3.5}
                        textAnchor="middle"
                        fill="white"
                        fontSize="8"
                        fontWeight="700"
                      >
                        {n.wordCount}
                      </text>
                    </>
                  )}
                </>
              )}
            </motion.g>
          );
        })}
      </svg>

      {tooltipNode && tooltipNode.type === "neuron" && (
        <motion.div
          className="mt-2 p-2.5 rounded-lg bg-[#0B1216]/90 border border-white/10 text-xs flex items-center gap-4"
          initial={{ opacity: 0, y: 8 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <span
            className="font-mono font-bold"
            style={{ color: tooltipNode.color }}
          >
            Head {tooltipNode.head} · Neuron {tooltipNode.label}
          </span>
          <span className="text-[#8B95A5]">
            Shared by{" "}
            <span className="text-white font-semibold">
              {tooltipNode.wordCount}
            </span>{" "}
            words
          </span>
          <span className="text-[#4A5568]">
            Σ activation:{" "}
            <span className="text-[#CBD5E0] font-mono">
              {tooltipNode.val?.toFixed(4)}
            </span>
          </span>
        </motion.div>
      )}

      <div className="flex items-center justify-between mt-3">
        <p className="text-xs text-[#4A5568]">
          <span className="text-white font-semibold">Hub neurons</span> fire for
          2+ words — shared concept encoding. Hover to trace.
        </p>
        <span className="text-[10px] text-[#4A5568] font-mono">
          {nodes.filter((n) => n.type === "neuron").length} hubs ·{" "}
          {edges.length} links
        </span>
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  MONOSEMANTIC NEURON TABLE (statistical selectivity)                */
/* ================================================================== */
function MonosemanticNeuronPanel({
  neurons,
  words,
  conceptName,
}: {
  neurons: MonosemanticNeuron[];
  words: string[];
  conceptName: string;
}) {
  if (!neurons || neurons.length === 0) {
    return (
      <motion.div
        className="glass-card p-4"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
      >
        <div className="flex items-center gap-2">
          {" "}
          <span className="text-sm text-[#4A5568]">
            No monosemantic neurons found for this concept (selectivity &gt;
            0.5)
          </span>
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className="glass-card p-4"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.2 }}
    >
      <div className="flex items-center gap-2 mb-1">
        {" "}
        <span className="text-sm font-semibold">Monosemantic Neurons</span>
        <span className="text-xs px-2 py-0.5 rounded-full bg-white/5 text-[#CBD5E0] font-mono">
          {neurons.length} found
        </span>
      </div>
      <p className="text-xs text-[#4A5568] mb-3">
        Selective neurons for{" "}
        <span className="text-white font-semibold">{conceptName}</span>.
        Selectivity = mean_in / (mean_in + mean_out). p-value via Mann-Whitney
        U.
      </p>
      <div className="overflow-x-auto">
        <table className="w-full text-xs">
          <thead>
            <tr className="text-[#4A5568] border-b border-white/[0.06]">
              <th className="text-left py-2 px-2">Location</th>
              <th className="text-right py-2 px-2">Selectivity</th>
              <th className="text-right py-2 px-2">In</th>
              <th className="text-right py-2 px-2">Out</th>
              <th className="text-right py-2 px-2">p-value</th>
              {words.map((w, i) => (
                <th
                  key={w}
                  className="text-right py-2 px-2 font-mono"
                  style={{ color: WORD_COLORS[i % WORD_COLORS.length] }}
                >
                  {w}
                </th>
              ))}
              <th className="py-2 px-2">Selectivity</th>
            </tr>
          </thead>
          <tbody>
            {neurons.slice(0, 20).map((n, i) => (
              <motion.tr
                key={`${n.layer}-${n.head}-${n.neuron}`}
                className="border-b border-white/[0.06] hover:bg-white/\[0.02\]"
                initial={{ opacity: 0, x: -10 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: i * 0.03 }}
              >
                <td className="py-2 px-2 font-mono">
                  <span className="text-[#4A5568]">L{n.layer}_</span>
                  <span
                    style={{ color: HEAD_COLORS[n.head % HEAD_COLORS.length] }}
                  >
                    H{n.head}
                  </span>
                  <span className="text-[#4A5568]">_N{n.neuron}</span>
                </td>
                <td className="py-2 px-2 text-right font-mono font-bold">
                  <span
                    className={
                      n.selectivity >= 0.9
                        ? "text-[#00C896]"
                        : n.selectivity >= 0.75
                          ? "text-[#00C896]/70"
                          : "text-[#CBD5E0]"
                    }
                  >
                    {n.selectivity.toFixed(3)}
                  </span>
                </td>
                <td className="py-2 px-2 text-right font-mono text-[#CBD5E0]/70">
                  {n.mean_in.toFixed(3)}
                </td>
                <td className="py-2 px-2 text-right font-mono text-[#8B95A5]/70">
                  {n.mean_out.toFixed(3)}
                </td>
                <td className="py-2 px-2 text-right font-mono">
                  <span
                    className={
                      n.p_value < 0.001
                        ? "text-[#00C896]"
                        : n.p_value < 0.05
                          ? "text-[#00C896]/70"
                          : "text-[#4A5568]"
                    }
                  >
                    {n.p_value < 0.001 ? "<0.001" : n.p_value.toFixed(3)}
                  </span>
                </td>
                {n.per_word.map((pw, wi) => (
                  <td
                    key={wi}
                    className="py-2 px-2 text-right font-mono"
                    style={{
                      color: WORD_COLORS[wi % WORD_COLORS.length],
                      opacity: pw > 0 ? 1 : 0.3,
                    }}
                  >
                    {pw.toFixed(3)}
                  </td>
                ))}
                <td className="py-2 px-2">
                  <div className="w-24 h-3 bg-white/5 rounded-full overflow-hidden relative">
                    <motion.div
                      className={`h-full rounded-full ${
                        n.selectivity >= 0.9
                          ? "bg-gradient-to-r from-[#00C896] to-[#00C896]"
                          : n.selectivity >= 0.75
                            ? "bg-gradient-to-r from-amber-500 to-amber-300"
                            : "bg-[#4A5568]"
                      }`}
                      initial={{ width: 0 }}
                      animate={{ width: `${n.selectivity * 100}%` }}
                      transition={{ delay: i * 0.04, duration: 0.5 }}
                    />
                    <div
                      className="absolute top-0 bottom-0 w-px bg-[#4A5568]"
                      style={{ left: "50%" }}
                      title="Chance level (0.50)"
                    />
                  </div>
                </td>
              </motion.tr>
            ))}
          </tbody>
        </table>
      </div>
      <div className="flex items-center gap-4 mt-3 text-[10px] text-[#4A5568]">
        <span className="flex items-center gap-1">
          <span className="w-2 h-2 rounded-full bg-[#00C896]" /> ≥ 0.9
          (exclusive)
        </span>
        <span className="flex items-center gap-1">
          <span className="w-2 h-2 rounded-full bg-amber-400" /> ≥ 0.75 (strong)
        </span>
        <span className="flex items-center gap-1">
          <span className="w-2 h-2 rounded-full bg-[#4A5568]" /> ≥ 0.5
          (selective)
        </span>
        <span className="ml-auto">Vertical line = chance (0.50)</span>
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  "TRY IT YOURSELF" — live probe w/ overlay against categories       */
/* ================================================================== */

/* Error boundary for Try-It-Yourself (catches render crashes) */
class TryItErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; errorMsg: string }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false, errorMsg: "" };
  }
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, errorMsg: error.message || "Render error" };
  }
  render() {
    if (this.state.hasError) {
      return (
        <div className="glass-card p-5">
          <div className="flex items-center gap-2 mb-3">
            <Search size={16} className="text-[#8B95A5]" />
            <span className="text-sm font-semibold text-[#8B95A5]">
              Try It Yourself — Error
            </span>
          </div>
          <p className="text-sm text-[#8B95A5]/80 mb-3">
            Something went wrong rendering the probe results.
          </p>
          <p className="text-xs text-[#4A5568] font-mono mb-3">
            {this.state.errorMsg}
          </p>
          <button
            onClick={() => this.setState({ hasError: false, errorMsg: "" })}
            className="btn-primary text-xs"
          >
            Try Again
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}

function TryItYourself({
  precomputed,
  selectedLayer,
}: {
  precomputed: PrecomputedData | null;
  selectedLayer: number;
}) {
  const [input, setInput] = useState("");
  const [words, setWords] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [liveResult, setLiveResult] = useState<FingerprintResult | null>(null);

  const addWord = useCallback(() => {
    const w = input.trim().toLowerCase();
    if (w && !words.includes(w)) {
      setWords((prev) => [...prev, w]);
      setInput("");
    }
  }, [input, words]);

  const removeWord = (w: string) =>
    setWords((prev) => prev.filter((x) => x !== w));

  const probe = async () => {
    if (words.length < 1) return;
    setLoading(true);
    setError(null);
    setLiveResult(null);
    try {
      const resp = await analysis.neuronFingerprint("custom", words);
      const data = resp.data as FingerprintResult;
      // Validate response shape
      if (!data || !data.words || !Array.isArray(data.words)) {
        throw new Error(
          "Invalid response from backend — unexpected data shape",
        );
      }
      setLiveResult(data);
    } catch (err: any) {
      const raw = err.response?.data?.detail;
      const msg =
        typeof raw === "string"
          ? raw
          : Array.isArray(raw)
            ? raw.map((e: any) => e.msg ?? JSON.stringify(e)).join("; ")
            : err.message ||
              "Backend offline — start the server to use live probing";
      setError(msg);
      setLiveResult(null);
    } finally {
      setLoading(false);
    }
  };

  // Shared neurons across live-probed words
  const liveSharedNeurons = useMemo(() => {
    if (!liveResult || !liveResult.words || liveResult.words.length < 2)
      return null;
    try {
      const m = new Map<number, Set<number>>();
      const firstWord = liveResult.words[0];
      if (!firstWord?.layers) return null;
      const layer = firstWord.layers.find((l) => l.layer === selectedLayer);
      if (!layer || !layer.heads) return null;

      layer.heads.forEach((h) => {
        const sets = liveResult.words.map((w) => {
          const wLayer = w.layers?.find((l) => l.layer === selectedLayer);
          if (!wLayer) return new Set<number>();
          const wHead = wLayer.heads?.find((hh) => hh.head === h.head);
          return new Set(wHead?.top_neurons?.map((n) => n.idx) ?? []);
        });
        const intersection = new Set<number>();
        const first = sets[0];
        first.forEach((idx) => {
          if (sets.every((s) => s.has(idx))) intersection.add(idx);
        });
        if (intersection.size > 0) m.set(h.head, intersection);
      });
      return m.size > 0 ? m : null;
    } catch {
      return null;
    }
  }, [liveResult, selectedLayer]);

  const totalSharedCount = useMemo(() => {
    if (!liveSharedNeurons) return 0;
    let count = 0;
    liveSharedNeurons.forEach((s) => (count += s.size));
    return count;
  }, [liveSharedNeurons]);

  // Category affinity
  const categoryOverlap = useMemo(() => {
    if (!liveResult || !precomputed) return null;
    if (!liveResult.words || liveResult.words.length === 0) return null;

    try {
      const userVecs: number[][] = [];
      liveResult.words.forEach((uw) => {
        if (!uw.layers) return;
        const uLayer = uw.layers.find((l) => l.layer === selectedLayer);
        if (!uLayer || !uLayer.heads) return;
        userVecs.push(uLayer.heads.flatMap((h) => h.x_ds ?? []));
      });
      if (userVecs.length === 0 || userVecs[0].length === 0) return null;

      const dim = userVecs[0].length;
      const avgUser = new Array(dim).fill(0);
      userVecs.forEach((v) => v.forEach((val, j) => (avgUser[j] += val)));
      avgUser.forEach((_, j) => (avgUser[j] /= userVecs.length));

      const cosine = (a: number[], b: number[]) => {
        let dot = 0,
          na = 0,
          nb = 0;
        for (let k = 0; k < a.length; k++) {
          dot += a[k] * b[k];
          na += a[k] * a[k];
          nb += b[k] * b[k];
        }
        const denom = Math.sqrt(na) * Math.sqrt(nb);
        return denom > 0 ? dot / denom : 0;
      };

      const overlaps: { concept: string; similarity: number }[] = [];
      Object.entries(precomputed.concepts).forEach(([cid, cr]) => {
        const sims: number[] = [];
        cr.words.forEach((w) => {
          const layer = w.layers.find((l) => l.layer === selectedLayer);
          if (!layer) return;
          const vec = layer.heads.flatMap((h) => h.x_ds);
          sims.push(cosine(avgUser, vec));
        });
        if (sims.length > 0)
          overlaps.push({
            concept: cid,
            similarity: sims.reduce((a, b) => a + b, 0) / sims.length,
          });
      });
      overlaps.sort((a, b) => b.similarity - a.similarity);
      return overlaps;
    } catch {
      return null;
    }
  }, [liveResult, precomputed, selectedLayer]);

  return (
    <motion.div
      className="glass-card p-5"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.2 }}
    >
      <div className="flex items-center gap-2 mb-3">
        <Search size={16} className="text-[#8B95A5]" />
        <span className="text-sm font-semibold">Try It Yourself</span>
        <span className="text-[10px] text-[#4A5568] ml-2">
          Probe the model with your own words
        </span>
        <span className="text-[10px] text-[#4A5568] ml-auto">
          Requires backend server running
        </span>
      </div>

      <div className="flex flex-wrap items-center gap-2 mb-3 p-3 rounded-xl border border-white/\[0.06\] bg-[#0B1216]/60">
        {words.map((w) => (
          <span
            key={w}
            className="flex items-center gap-1 px-2.5 py-1 rounded-lg bg-cyan-500/15 border border-cyan-500/30 text-sm font-mono text-cyan-400"
          >
            {w}
            <button
              onClick={() => removeWord(w)}
              className="text-cyan-400/50 hover:text-cyan-300 ml-0.5"
            >
              <X size={12} />
            </button>
          </span>
        ))}
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") addWord();
            if (e.key === "Backspace" && !input && words.length)
              removeWord(words[words.length - 1]);
          }}
          placeholder='Type a word (e.g. "pound", "japon")…'
          className="flex-1 min-w-[140px] bg-transparent outline-none text-sm text-[#E2E8F0] placeholder-[#4A5568]"
        />
        <button
          onClick={addWord}
          disabled={!input.trim()}
          className="p-1.5 rounded-lg bg-white/5 hover:bg-white/10 text-[#8B95A5] hover:text-[#E2E8F0] disabled:opacity-30 transition-all"
        >
          <Plus size={16} />
        </button>
      </div>

      <button
        onClick={probe}
        disabled={words.length < 1 || loading}
        className="btn-primary flex items-center gap-2 disabled:opacity-40 disabled:cursor-not-allowed mb-4"
      >
        {loading ? (
          <Loader2 size={16} className="animate-spin" />
        ) : (
          <Zap size={16} />
        )}
        {loading ? "Probing…" : "Probe Model"}
      </button>

      {error && (
        <motion.p
          className="text-sm text-[#8B95A5] mb-3"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {error}
        </motion.p>
      )}

      {liveResult && (
        <motion.div
          className="space-y-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {liveSharedNeurons && (
            <motion.div
              className="p-3 rounded-xl bg-[#00C896]/5 border border-[#00C896]/15"
              initial={{ opacity: 0, y: 6 }}
              animate={{ opacity: 1, y: 0 }}
            >
              <p className="text-xs">
                <span className="text-[#CBD5E0] font-semibold">
                  {totalSharedCount} shared neuron
                  {totalSharedCount !== 1 ? "s" : ""}
                </span>
                <span className="text-[#4A5568]">
                  {" "}
                  found across {liveResult.words.length} words —{" "}
                  <span className="text-[#00C896]/70">green bars</span> =
                  neurons that fire for multiple words
                </span>
              </p>
            </motion.div>
          )}

          {liveResult.words.map((fp) => {
            if (!fp?.layers) return null;
            const layer = fp.layers.find((l) => l.layer === selectedLayer);
            if (!layer || !layer.heads) return null;
            return (
              <motion.div
                key={fp.word}
                className="rounded-xl p-4 bg-[#0B1216]/50 border border-white/[0.06] backdrop-blur-sm"
                style={{ borderLeftWidth: 3, borderLeftColor: "#22d3ee" }}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
              >
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-mono font-bold text-cyan-400">
                    "{fp.word}"
                  </span>
                  <span className="text-[10px] text-[#4A5568] font-mono">
                    {layer.heads
                      .reduce((s, h) => s + h.x_active, 0)
                      .toLocaleString()}{" "}
                    active
                  </span>
                </div>
                <div className="space-y-1">
                  {layer.heads.map((h, hi) => (
                    <NeuronStrip
                      key={hi}
                      neurons={h.top_neurons}
                      label={`H${h.head}`}
                      delay={hi * 0.03}
                      color="rgba(34,211,238,0.7)"
                      highlightNeurons={liveSharedNeurons?.get(h.head)}
                    />
                  ))}
                </div>
              </motion.div>
            );
          })}

          {categoryOverlap &&
            (() => {
              const maxSim = Math.max(
                0.01,
                ...categoryOverlap.map((co) => co.similarity),
              );
              return (
                <div className="space-y-3 mt-4">
                  <div className="flex items-center gap-2">
                    <Zap size={13} className="text-cyan-400" />
                    <span className="text-xs text-[#CBD5E0] font-semibold uppercase tracking-wider">
                      Category Affinity
                    </span>
                  </div>
                  {categoryOverlap.map((co, i) => {
                    const preset = PRESETS.find((p) => p.id === co.concept);
                    const color = CONCEPT_COLORS[co.concept] ?? "#8b5cf6";
                    const relWidth = (co.similarity / maxSim) * 80;
                    const isTop = i === 0;
                    return (
                      <motion.div
                        key={co.concept}
                        className={`flex items-center gap-3 p-2 rounded-lg transition-all ${
                          isTop
                            ? "bg-white/[0.04] border border-white/[0.06]"
                            : ""
                        }`}
                        initial={{ opacity: 0, x: -10 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: i * 0.08 }}
                      >
                        <div className="flex items-center gap-1.5 w-28 shrink-0 justify-end">
                          <span
                            className="w-2 h-2 rounded-full"
                            style={{ backgroundColor: color }}
                          />
                          <span
                            className="text-xs font-semibold"
                            style={{ color }}
                          >
                            {preset?.name}
                          </span>
                        </div>
                        <div className="flex-1 h-4 bg-white/[0.05] rounded-full overflow-hidden">
                          <motion.div
                            className="h-full rounded-full"
                            style={{
                              background: `linear-gradient(90deg, ${color}, ${color}dd)`,
                            }}
                            initial={{ width: 0 }}
                            animate={{ width: `${relWidth}%` }}
                            transition={{ delay: i * 0.1, duration: 0.5 }}
                          />
                        </div>
                        <span
                          className={`text-xs font-mono w-14 text-right ${
                            isTop ? "font-bold" : "text-[#4A5568]"
                          }`}
                          style={isTop ? { color } : undefined}
                        >
                          {co.similarity.toFixed(3)}
                        </span>
                      </motion.div>
                    );
                  })}
                  {categoryOverlap[0] &&
                    categoryOverlap[0].similarity > 0.05 && (
                      <motion.p
                        className="text-xs text-[#CBD5E0] mt-2"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 0.5 }}
                      >
                        Highest similarity with{" "}
                        <strong>
                          {PRESETS.find(
                            (p) => p.id === categoryOverlap[0].concept,
                          )?.name ?? categoryOverlap[0].concept}
                        </strong>{" "}
                        — the model recognizes semantic affinity!
                      </motion.p>
                    )}
                </div>
              );
            })()}
        </motion.div>
      )}
    </motion.div>
  );
}

/* ================================================================== */
/*  MAIN PAGE                                                          */
/* ================================================================== */
export function MonosemanticityPage() {
  const [precomputed, setPrecomputed] = useState<PrecomputedData | null>(null);
  const [loadingData, setLoadingData] = useState(true);
  const [loadError, setLoadError] = useState<string | null>(null);
  const [selectedLayer, setSelectedLayer] = useState(5);
  const [viewTab, setViewTab] = useState<ViewTab>("synapseTracking");
  const [activeConcept, setActiveConcept] = useState("currencies");
  const [intersectionConcept, setIntersectionConcept] = useState("currencies");

  useEffect(() => {
    fetch("/monosemanticity/precomputed.json")
      .then((r) => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
      })
      .then((data: PrecomputedData) => {
        setPrecomputed(data);
        setSelectedLayer(data.best_layer);
        setLoadingData(false);
      })
      .catch((err) => {
        setLoadError(err.message);
        setLoadingData(false);
      });
  }, []);

  const nLayers = precomputed?.model_info.n_layers ?? 8;
  const bestLayer = precomputed?.best_layer ?? 5;

  if (loadingData) {
    return (
      <div
        className="min-h-screen flex items-center justify-center"
        style={{ background: "#070D12" }}
      >
        <motion.div
          className="flex flex-col items-center gap-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          <Loader2 size={40} className="animate-spin text-[#00C896]" />
          <p className="text-[#8B95A5] text-sm">
            Loading monosemanticity data…
          </p>
        </motion.div>
      </div>
    );
  }

  if (loadError || !precomputed) {
    return (
      <div
        className="min-h-screen p-6 md:p-8 max-w-[1600px] mx-auto"
        style={{ background: "#070D12" }}
      >
        <motion.div
          className="flex flex-col items-center justify-center py-20 text-[#4A5568]"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          <Brain size={64} className="mb-4 opacity-30" />
          <p className="text-lg font-medium mb-2">
            Pre-computed data not found
          </p>
          <p className="text-sm text-[#4A5568] text-center max-w-md">
            Run{" "}
            <code className="px-2 py-1 bg-white/5 rounded text-xs font-mono text-[#CBD5E0]">
              python scripts/precompute_monosemanticity.py
            </code>{" "}
            to generate the visualization data, then refresh this page.
          </p>
          {loadError && (
            <p className="text-xs text-[#8B95A5]/60 mt-4 font-mono">
              {loadError}
            </p>
          )}
        </motion.div>
      </div>
    );
  }

  const currentTab = VIEW_TABS.find((t) => t.id === viewTab)!;

  return (
    <div
      className="min-h-screen p-6 md:p-8 max-w-[1600px] mx-auto"
      style={{ background: "#070D12" }}
    >
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        className="mb-6"
      >
        <h1 className="text-3xl font-bold mb-1">
          <span className="gradient-text">Monosemanticity</span> Explorer
        </h1>
        <p className="text-[#4A5568] text-sm">
          Do individual neurons specialize for specific concepts? These six
          views test whether BDH's Hebbian synapses (σ) create meaningful,
          interpretable structure.
        </p>
      </motion.div>

      {/* Toolbar */}
      <div className="flex items-center justify-between mb-4 flex-wrap gap-3">
        <LayerSelector
          nLayers={nLayers}
          selected={selectedLayer}
          onChange={setSelectedLayer}
          bestLayer={bestLayer}
        />

        <div className="flex gap-1 bg-[#0B1216]/60 rounded-xl p-1 border border-white/[0.06] flex-wrap">
          {VIEW_TABS.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setViewTab(tab.id)}
              className={`px-3 py-1.5 rounded-lg text-xs font-semibold flex items-center gap-1.5 transition-all ${
                viewTab === tab.id
                  ? "bg-[#00C896]/15 text-[#00C896]"
                  : "text-[#8B95A5] hover:text-[#E2E8F0] hover:bg-white/[0.04]"
              }`}
            >
              <span>{tab.label}</span>
            </button>
          ))}
        </div>
      </div>

      {/* Narrative step — compact */}
      <motion.div
        className="mb-5 flex items-center gap-2.5 px-3 py-2 rounded-lg bg-[#0B1216] border border-white/[0.04]"
        key={viewTab}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        <Info size={13} className="text-[#8B95A5] shrink-0" />
        <span className="text-xs text-[#8B95A5]">{currentTab.narrative}</span>
      </motion.div>

      {/* Active view */}
      <div className="mb-6">
        <AnimatePresence mode="wait">
          {viewTab === "similarity" && (
            <motion.div
              key="sim"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <SimilarityView
                concepts={precomputed.concepts}
                activeConcept={activeConcept}
                setActiveConcept={setActiveConcept}
                selectedLayer={selectedLayer}
              />
            </motion.div>
          )}
          {viewTab === "crossConcept" && (
            <motion.div
              key="cross"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <CrossConceptView
                crossPairs={precomputed.cross_concept}
                concepts={precomputed.concepts}
                selectedLayer={selectedLayer}
              />
            </motion.div>
          )}
          {viewTab === "synapseTracking" && (
            <motion.div
              key="syntrack"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <SynapseTrackingView
                tracking={precomputed.synapse_tracking ?? {}}
                activeConcept={activeConcept}
                setActiveConcept={setActiveConcept}
              />
            </motion.div>
          )}
          {viewTab === "selectivity" && (
            <motion.div
              key="selectivity"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <SelectivityView
                selectivity={precomputed.selectivity}
                concepts={precomputed.concepts}
                activeConcept={activeConcept}
                setActiveConcept={setActiveConcept}
              />
            </motion.div>
          )}
          {viewTab === "intersection" && (
            <motion.div
              key="inter"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <div className="flex flex-wrap gap-2 mb-4">
                {Object.entries(precomputed.concepts).map(([cid]) => {
                  const p = presetOf(cid);
                  const c = CONCEPT_COLORS[cid] ?? "#8b5cf6";
                  return (
                    <button
                      key={cid}
                      onClick={() => setIntersectionConcept(cid)}
                      className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
                        intersectionConcept === cid
                          ? "shadow-lg"
                          : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
                      }`}
                      style={
                        intersectionConcept === cid
                          ? {
                              borderColor: `${c}50`,
                              backgroundColor: `${c}15`,
                              color: c,
                            }
                          : undefined
                      }
                    >
                      {p?.icon} {p?.name ?? cid}
                    </button>
                  );
                })}
              </div>
              <IntersectionView
                result={precomputed.concepts[intersectionConcept]}
                selectedLayer={selectedLayer}
              />
            </motion.div>
          )}
          {viewTab === "neuronGraph" && (
            <motion.div
              key="graph"
              initial={{ opacity: 0, x: -15 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 15 }}
              transition={{ duration: 0.2 }}
            >
              <div className="flex flex-wrap gap-2 mb-4">
                {Object.entries(precomputed.concepts).map(([cid]) => {
                  const p = presetOf(cid);
                  const c = CONCEPT_COLORS[cid] ?? "#8b5cf6";
                  return (
                    <button
                      key={cid}
                      onClick={() => setActiveConcept(cid)}
                      className={`px-3 py-1.5 rounded-lg text-xs font-semibold border transition-all ${
                        activeConcept === cid
                          ? "shadow-lg"
                          : "border-white/\[0.06\] bg-[#0B1216]/60 text-[#8B95A5] hover:border-white/\[0.12\] hover:text-[#E2E8F0]"
                      }`}
                      style={
                        activeConcept === cid
                          ? {
                              borderColor: `${c}50`,
                              backgroundColor: `${c}15`,
                              color: c,
                            }
                          : undefined
                      }
                    >
                      {p?.icon} {p?.name ?? cid}
                    </button>
                  );
                })}
              </div>
              <NeuronGraphView
                result={precomputed.concepts[activeConcept]}
                selectedLayer={selectedLayer}
              />
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Monosemantic neurons table (for intersection & graph views) */}
      {(viewTab === "intersection" || viewTab === "neuronGraph") &&
        (() => {
          const cid =
            viewTab === "intersection" ? intersectionConcept : activeConcept;
          const concept = precomputed.concepts[cid];
          const presetInfo = PRESETS.find((p) => p.id === cid);
          return (
            <MonosemanticNeuronPanel
              neurons={concept?.monosemantic_neurons ?? []}
              words={concept?.words.map((w) => w.word) ?? []}
              conceptName={presetInfo?.name ?? cid}
            />
          );
        })()}

      {/* Insight — collapsible */}
      <details className="mt-6 glass-card group">
        <summary className="p-4 cursor-pointer flex items-center gap-2 text-sm font-semibold text-[#CBD5E0] select-none">
          {" "}
          How It Works — Hebbian Monosemantic Synapses
          <ChevronDown
            size={14}
            className="ml-auto text-[#4A5568] transition-transform group-open:rotate-180"
          />
        </summary>
        <div className="px-4 pb-4 text-[#8B95A5] text-xs leading-relaxed space-y-2">
          <p>
            <span className="text-[#8B95A5] font-medium">Neurons</span>{" "}
            (x_sparse) encode byte-level features — sub-word patterns shared
            across concepts.{" "}
            <span className="text-cyan-400 font-medium">Hebbian synapses</span>{" "}
            σ(i,j) = Σ y·x then strengthen selectively for specific concepts
            during inference.
          </p>
          <p>
            <strong className="text-[#CBD5E0]">Synapse Tracking</strong> shows σ
            spiking at concept words.{" "}
            <strong className="text-[#CBD5E0]">Selectivity</strong> provides
            statistical evidence.{" "}
            <strong className="text-[#CBD5E0]">Sparse Fingerprinting</strong>{" "}
            shows within-concept similarity. Together: sparse neurons + Hebbian
            synapses = interpretable by design.
          </p>
        </div>
      </details>

      {/* Divider */}
      <div className="relative my-10">
        <div className="absolute inset-0 flex items-center">
          <div className="w-full border-t border-white/[0.06]" />
        </div>
        <div className="relative flex justify-center">
          <span className="px-4 py-1 bg-[#070D12] text-[10px] text-[#4A5568] uppercase tracking-wider rounded-full border border-white/[0.06]">
            Live Exploration
          </span>
        </div>
      </div>

      {/* Try It Yourself */}
      <TryItErrorBoundary>
        <TryItYourself
          precomputed={precomputed}
          selectedLayer={selectedLayer}
        />
      </TryItErrorBoundary>
    </div>
  );
}


================================================================================
 FILE: pages\HebbianPage.tsx  (1166 lines)
================================================================================

import { useState, useEffect, useCallback, useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Zap,
  Play,
  Pause,
  RotateCcw,
  Loader2,
  Layers,
  Send,
  Activity,
  BarChart3,
  ArrowRight,
  ChevronDown,
  ChevronRight,
  Brain,
  Network,
  Sparkles,
} from "lucide-react";
import { visualization } from "../utils/api";

/* ================================================================== */
/*  Types — matches new backend /hebbian-track response                */
/* ================================================================== */
interface Prediction {
  byte: number;
  char: string;
  prob: number;
}

interface SynapseData {
  sigma: number;
  delta: number;
}

interface WordEntry {
  word: string;
  byte_range: [number, number];
  synapses: Record<string, SynapseData>;
  gate_activity: number;
}

interface TrackedSynapse {
  id: string;
  neuron: number;
  final_sigma: number;
}

interface HeadData {
  tracked_synapses: TrackedSynapse[];
  words: WordEntry[];
}

interface HeadSummary {
  head: number;
  total_gate_activity: number;
  top_synapse: TrackedSynapse | null;
}

interface LayerSummary {
  layer: number;
  heads: HeadSummary[];
}

interface HebbianResponse {
  input_text: string;
  num_bytes: number;
  num_words: number;
  words: string[];
  model_config: {
    n_layer: number;
    n_head: number;
    n_neurons: number;
  };
  predictions: {
    before: Prediction[];
    after: Prediction[];
    prefix_text: string;
  };
  layer_summary: LayerSummary[];
  layer_data: Record<number, Record<number, HeadData>>;
  sparsity: Record<string, number>;
}

/* ================================================================== */
/*  Constants                                                          */
/* ================================================================== */
const HEAD_COLORS = ["#8b5cf6", "#f59e0b", "#06b6d4", "#ef4444"];
const LAYER_GRADIENT = [
  "#4f46e5",
  "#6366f1",
  "#7c3aed",
  "#8b5cf6",
  "#a855f7",
  "#c084fc",
  "#d8b4fe",
  "#e9d5ff",
];

const EXAMPLE_SENTENCES = [
  "le parlement européen a voté cette résolution importante",
  "la france et l'allemagne coopèrent dans de nombreux domaines",
  "le dollar et l'euro sont les principales monnaies mondiales",
  "il parle couramment français et anglais depuis toujours",
];

/* ================================================================== */
/*  Component                                                          */
/* ================================================================== */
export function HebbianPage() {
  const [inputText, setInputText] = useState(EXAMPLE_SENTENCES[0]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentWord, setCurrentWord] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<HebbianResponse | null>(null);
  const [selectedLayer, setSelectedLayer] = useState<number>(0);
  const [selectedHead, setSelectedHead] = useState<number>(0);
  const [showDelta, setShowDelta] = useState(true);
  const [expandedLayer, setExpandedLayer] = useState<number | null>(null);
  const [playbackSpeed, setPlaybackSpeed] = useState(1800); // ms per word

  /* ── Current head data ── */
  const headData = useMemo((): HeadData | null => {
    if (!data) return null;
    const layerData = data.layer_data[selectedLayer];
    if (!layerData) return null;
    return layerData[selectedHead] ?? null;
  }, [data, selectedLayer, selectedHead]);

  /* ── Available layers ── */
  const availableLayers = useMemo(() => {
    if (!data) return [];
    return Object.keys(data.layer_data)
      .map(Number)
      .sort((a, b) => a - b);
  }, [data]);

  /* ── Max gate activity (for scaling bars) ── */
  const maxGate = useMemo(() => {
    if (!headData) return 1;
    return Math.max(...headData.words.map((w) => Math.abs(w.gate_activity)), 1);
  }, [headData]);

  /* ── Max sigma/delta for current synapses ── */
  const maxSigma = useMemo(() => {
    if (!headData) return 1;
    let max = 0;
    for (const w of headData.words) {
      for (const syn of Object.values(w.synapses)) {
        const v = showDelta ? Math.abs(syn.delta) : Math.abs(syn.sigma);
        if (v > max) max = v;
      }
    }
    return max || 1;
  }, [headData, showDelta]);

  /* ── Fetch from model ── */
  const runAnalysis = useCallback(async () => {
    if (!inputText.trim()) return;
    setLoading(true);
    setError(null);
    setCurrentWord(0);
    setIsPlaying(false);
    try {
      const res = await visualization.hebbianTrack(inputText.trim());
      setData(res.data);
      // Default to layer with highest gate activity
      if (res.data.layer_summary.length > 0) {
        let bestLayer = 0;
        let bestGate = 0;
        for (const ls of res.data.layer_summary) {
          const total = ls.heads.reduce(
            (s: number, h: HeadSummary) => s + h.total_gate_activity,
            0,
          );
          if (total > bestGate) {
            bestGate = total;
            bestLayer = ls.layer;
          }
        }
        setSelectedLayer(bestLayer);
        setSelectedHead(0);
      }
    } catch (e: unknown) {
      setError(e instanceof Error ? e.message : "Failed to reach backend");
    } finally {
      setLoading(false);
    }
  }, [inputText]);

  /* ── Playback ── */
  useEffect(() => {
    if (!isPlaying || !headData) return;
    const interval = setInterval(() => {
      setCurrentWord((prev) => {
        if (prev >= headData.words.length - 1) {
          setIsPlaying(false);
          return prev;
        }
        return prev + 1;
      });
    }, playbackSpeed);
    return () => clearInterval(interval);
  }, [isPlaying, headData, playbackSpeed]);

  const words = headData?.words ?? [];
  const trackedSynapses = headData?.tracked_synapses ?? [];

  return (
    <div className="min-h-screen p-8" style={{ background: '#070D12' }}>
      {/* ── Header ── */}
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        className="mb-8"
      >
        <h1 className="text-3xl font-bold mb-2">
          <span className="gradient-text">Hebbian Learning</span> Dynamics
        </h1>
        <p className="text-[#8B95A5]">
          Visualize how σ(i,j) = y_sparse · x_sparse accumulates word-by-word
          during a single forward pass — the gate mechanism IS Hebbian
          co-activation.
        </p>
      </motion.div>

      {/* ── Input ── */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="glass-card p-6 mb-6"
      >
        <label className="text-sm text-[#8B95A5] mb-2 block">
          Input sequence (French — Europarl FR trained model)
        </label>
        <div className="flex gap-3 mb-3">
          <input
            type="text"
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && runAnalysis()}
            className="input-field flex-1"
            placeholder="Type a French sentence..."
          />
          <button
            onClick={runAnalysis}
            disabled={loading || !inputText.trim()}
            className="btn-primary flex items-center gap-2 px-5"
          >
            {loading ? (
              <Loader2 size={18} className="animate-spin" />
            ) : (
              <Send size={18} />
            )}
            {loading ? "Running…" : "Analyze"}
          </button>
        </div>

        {/* Quick examples */}
        <div className="flex flex-wrap gap-2 mb-3">
          <span className="text-xs text-[#4A5568]">Try:</span>
          {EXAMPLE_SENTENCES.map((ex, i) => (
            <button
              key={i}
              onClick={() => setInputText(ex)}
              className="text-xs px-2 py-1 rounded bg-white/5 text-[#8B95A5] hover:bg-white/10 hover:text-[#E2E8F0] transition-all truncate max-w-[220px]"
            >
              {ex}
            </button>
          ))}
        </div>

        {error && (
          <div className="text-red-400 text-sm mb-3 p-2 bg-red-500/10 rounded">
            {error}
          </div>
        )}

        {data && (
          <>
            {/* Summary stats */}
            <div className="flex gap-6 mb-4 text-xs text-[#4A5568]">
              <span>
                <span className="text-white font-mono">{data.num_bytes}</span>{" "}
                bytes
              </span>
              <span>
                <span className="text-white font-mono">{data.num_words}</span>{" "}
                words
              </span>
              <span>
                <span className="text-white font-mono">
                  {data.model_config.n_layer}
                </span>{" "}
                layers
              </span>
              <span>
                <span className="text-white font-mono">
                  {data.model_config.n_head}
                </span>{" "}
                heads
              </span>
              <span>
                <span className="text-white font-mono">
                  {data.model_config.n_neurons}
                </span>{" "}
                neurons/head
              </span>
            </div>

            {/* Layer + Head selectors */}
            <div className="flex items-center gap-4 mb-4 flex-wrap">
              <div className="flex items-center gap-2">
                <Layers size={14} className="text-[#4A5568]" />
                <span className="text-xs text-[#4A5568]">Layer:</span>
                {availableLayers.map((l) => (
                  <button
                    key={l}
                    onClick={() => setSelectedLayer(l)}
                    className={`px-2.5 py-1 rounded-full text-xs font-mono transition-all ${
                      selectedLayer === l
                        ? "bg-bdh-accent text-[#E2E8F0]"
                        : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                    }`}
                  >
                    L{l}
                  </button>
                ))}
              </div>

              <div className="flex items-center gap-2">
                <span className="text-xs text-[#4A5568]">Head:</span>
                {Array.from(
                  { length: data.model_config.n_head },
                  (_, i) => i,
                ).map((h) => (
                  <button
                    key={h}
                    onClick={() => setSelectedHead(h)}
                    className={`px-2.5 py-1 rounded-full text-xs font-mono transition-all ${
                      selectedHead === h
                        ? "text-[#E2E8F0]"
                        : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                    }`}
                    style={
                      selectedHead === h
                        ? {
                            backgroundColor:
                              HEAD_COLORS[h % HEAD_COLORS.length],
                          }
                        : {}
                    }
                  >
                    H{h}
                  </button>
                ))}
              </div>

              {/* Sigma/Delta toggle */}
              <div className="flex items-center gap-2 ml-auto">
                <span className="text-xs text-[#4A5568]">View:</span>
                <button
                  onClick={() => setShowDelta(false)}
                  className={`px-2.5 py-1 rounded-full text-xs transition-all ${
                    !showDelta
                      ? "bg-bdh-accent text-[#E2E8F0]"
                      : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                  }`}
                >
                  Cumulative σ
                </button>
                <button
                  onClick={() => setShowDelta(true)}
                  className={`px-2.5 py-1 rounded-full text-xs transition-all ${
                    showDelta
                      ? "bg-bdh-accent text-[#E2E8F0]"
                      : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                  }`}
                >
                  Δσ per word
                </button>
              </div>
            </div>

            {/* Word timeline */}
            <div className="flex flex-wrap gap-1 mb-4">
              {words.map((w, idx) => {
                const isActive = idx === currentWord;
                const isPast = idx < currentWord;
                const gate = w.gate_activity;
                const intensity = Math.min(gate / maxGate, 1);
                return (
                  <motion.span
                    key={idx}
                    className={`px-2 py-1 rounded font-mono text-sm cursor-pointer transition-all ${
                      isActive
                        ? "bg-bdh-accent text-[#E2E8F0] scale-110 ring-2 ring-bdh-accent/50"
                        : isPast
                          ? "text-[#2A7FFF] border border-[#2A7FFF]/30"
                          : "bg-white/5 text-[#4A5568]"
                    }`}
                    style={
                      !isActive && isPast
                        ? {
                            backgroundColor: `rgba(139, 92, 246, ${0.1 + intensity * 0.4})`,
                          }
                        : {}
                    }
                    onClick={() => setCurrentWord(idx)}
                    animate={isActive ? { scale: [1, 1.05, 1] } : {}}
                    transition={{ duration: 0.3 }}
                    title={`Gate activity: ${gate.toFixed(2)}`}
                  >
                    {w.word}
                  </motion.span>
                );
              })}
            </div>

            {/* Playback controls */}
            <div className="flex items-center gap-4">
              <button
                onClick={() => setIsPlaying(!isPlaying)}
                className="btn-primary flex items-center gap-2"
                disabled={!words.length}
              >
                {isPlaying ? <Pause size={18} /> : <Play size={18} />}
                {isPlaying ? "Pause" : "Play"}
              </button>
              <button
                onClick={() => {
                  setCurrentWord(0);
                  setIsPlaying(false);
                }}
                className="btn-secondary flex items-center gap-2"
              >
                <RotateCcw size={18} />
                Reset
              </button>
              <input
                type="range"
                min={0}
                max={Math.max(0, words.length - 1)}
                value={currentWord}
                onChange={(e) => setCurrentWord(parseInt(e.target.value))}
                className="flex-1"
              />
              <span className="text-[#8B95A5] font-mono text-sm">
                {words.length > 0 ? currentWord + 1 : 0}/{words.length}
              </span>
            </div>

            {/* Speed control */}
            <div className="flex items-center gap-3 mt-3">
              <span className="text-xs text-[#4A5568]">Speed:</span>
              <button
                onClick={() => setPlaybackSpeed(2800)}
                className={`px-2 py-0.5 rounded text-xs transition-all ${
                  playbackSpeed === 2800
                    ? "bg-bdh-accent text-[#E2E8F0]"
                    : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                }`}
              >
                Slow
              </button>
              <button
                onClick={() => setPlaybackSpeed(1800)}
                className={`px-2 py-0.5 rounded text-xs transition-all ${
                  playbackSpeed === 1800
                    ? "bg-bdh-accent text-[#E2E8F0]"
                    : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                }`}
              >
                Normal
              </button>
              <button
                onClick={() => setPlaybackSpeed(1000)}
                className={`px-2 py-0.5 rounded text-xs transition-all ${
                  playbackSpeed === 1000
                    ? "bg-bdh-accent text-[#E2E8F0]"
                    : "bg-white/5 text-[#8B95A5] hover:bg-white/10"
                }`}
              >
                Fast
              </button>
              <span className="text-[10px] text-[#4A5568] font-mono">
                {(playbackSpeed / 1000).toFixed(1)}s/word
              </span>
            </div>
          </>
        )}
      </motion.div>

      {/* ── Main panels ── */}
      {data && headData && (
        <div className="grid lg:grid-cols-2 gap-6 mb-6">
          {/* ── LEFT: σ Timeline ── */}
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="glass-card p-6"
          >
            <h3 className="text-lg font-semibold mb-1 flex items-center gap-2">
              <Activity size={20} className="text-bdh-accent" />
              {showDelta ? "Δσ" : "σ"} Word Timeline
              <span className="text-xs text-[#4A5568] font-normal ml-1">
                L{selectedLayer} H{selectedHead}
              </span>
            </h3>
            <p className="text-xs text-[#4A5568] mb-4">
              {showDelta
                ? "Per-word Hebbian increment: how much σ grows at each word"
                : "Cumulative Hebbian σ = Σ y_sparse · x_sparse up to each word"}
            </p>

            {/* Tracked synapse legend */}
            <div className="flex flex-wrap gap-2 mb-3">
              {trackedSynapses.map((syn, i) => (
                <span
                  key={syn.id}
                  className="text-[10px] font-mono px-2 py-1 rounded"
                  style={{
                    backgroundColor: `${HEAD_COLORS[i % HEAD_COLORS.length]}20`,
                    color: HEAD_COLORS[i % HEAD_COLORS.length],
                    borderLeft: `3px solid ${HEAD_COLORS[i % HEAD_COLORS.length]}`,
                  }}
                >
                  {syn.id} (final σ={syn.final_sigma.toFixed(1)})
                </span>
              ))}
            </div>

            {/* Word bars */}
            <div className="space-y-1.5 max-h-[420px] overflow-y-auto pr-1">
              <AnimatePresence mode="popLayout">
                {words.map((w, wi) => {
                  const isActive = wi === currentWord;
                  const isPast = wi <= currentWord;
                  return (
                    <motion.div
                      key={wi}
                      initial={{ opacity: 0, x: -10 }}
                      animate={{
                        opacity: isPast ? 1 : 0.3,
                        x: 0,
                      }}
                      className={`p-2 rounded-lg cursor-pointer transition-all ${
                        isActive
                          ? "bg-bdh-accent/15 ring-1 ring-bdh-accent/40"
                          : "bg-white/[0.04] hover:bg-white/[0.05]"
                      }`}
                      onClick={() => setCurrentWord(wi)}
                    >
                      <div className="flex items-center gap-2 mb-1">
                        <span
                          className={`font-mono text-sm w-24 truncate ${
                            isActive ? "text-white font-bold" : "text-[#8B95A5]"
                          }`}
                        >
                          {w.word}
                        </span>
                        <span className="text-[10px] text-[#4A5568] font-mono">
                          gate={w.gate_activity.toFixed(1)}
                        </span>
                      </div>

                      {/* Per-synapse bars */}
                      <div className="space-y-0.5">
                        {trackedSynapses.map((syn, si) => {
                          const sd = w.synapses[syn.id];
                          if (!sd) return null;
                          const val = showDelta ? sd.delta : sd.sigma;
                          const pct =
                            maxSigma > 0 ? (Math.abs(val) / maxSigma) * 100 : 0;
                          const color = HEAD_COLORS[si % HEAD_COLORS.length];
                          return (
                            <div
                              key={syn.id}
                              className="flex items-center gap-1"
                            >
                              <span
                                className="text-[9px] font-mono w-8 text-right"
                                style={{ color }}
                              >
                                {syn.id.slice(0, 5)}
                              </span>
                              <div className="flex-1 h-2 bg-white/[0.08] rounded-full overflow-hidden">
                                <motion.div
                                  className="h-full rounded-full"
                                  style={{ backgroundColor: color }}
                                  initial={{ width: 0 }}
                                  animate={{
                                    width: isPast
                                      ? `${Math.min(pct, 100)}%`
                                      : "0%",
                                  }}
                                  transition={{ duration: 0.3 }}
                                />
                              </div>
                              <span
                                className="text-[9px] font-mono w-14 text-right"
                                style={{ color: isPast ? color : "#555" }}
                              >
                                {isPast ? val.toFixed(2) : "—"}
                              </span>
                            </div>
                          );
                        })}
                      </div>
                    </motion.div>
                  );
                })}
              </AnimatePresence>
            </div>
          </motion.div>

          {/* ── RIGHT: Prediction Shift + Layer Summary ── */}
          <div className="space-y-6">
            {/* Before/After Predictions */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              className="glass-card p-6"
            >
              <h3 className="text-lg font-semibold mb-1 flex items-center gap-2">
                <BarChart3 size={20} className="text-[#00C896]" />
                Context-Driven Prediction Shift
              </h3>
              <p className="text-xs text-[#4A5568] mb-4">
                How the Hebbian gate reshapes predictions: top next-byte
                probabilities before vs after seeing the full sentence
              </p>

              <div className="grid grid-cols-2 gap-4">
                {/* Before */}
                <div>
                  <div className="text-xs text-[#4A5568] mb-2 flex items-center gap-1">
                    <span className="w-2 h-2 rounded-full bg-[#4A5568]" />
                    Before (&ldquo;{data.predictions.prefix_text}&rdquo;)
                  </div>
                  <div className="space-y-1">
                    {data.predictions.before.slice(0, 8).map((p, i) => (
                      <div key={i} className="flex items-center gap-2 text-xs">
                        <span className="font-mono text-[#8B95A5] w-8 text-center bg-white/5 rounded px-1">
                          {p.char}
                        </span>
                        <div className="flex-1 h-2 bg-white/5 rounded-full overflow-hidden">
                          <div
                            className="h-full bg-[#4A5568] rounded-full"
                            style={{ width: `${p.prob * 100}%` }}
                          />
                        </div>
                        <span className="font-mono text-[#4A5568] w-12 text-right">
                          {(p.prob * 100).toFixed(1)}%
                        </span>
                      </div>
                    ))}
                  </div>
                </div>

                {/* After */}
                <div>
                  <div className="text-xs text-[#4A5568] mb-2 flex items-center gap-1">
                    <span className="w-2 h-2 rounded-full bg-[#00C896]" />
                    After (full sentence)
                  </div>
                  <div className="space-y-1">
                    {data.predictions.after.slice(0, 8).map((p, i) => (
                      <div key={i} className="flex items-center gap-2 text-xs">
                        <span className="font-mono text-[#00C896] w-8 text-center bg-[#00C896]/10 rounded px-1">
                          {p.char}
                        </span>
                        <div className="flex-1 h-2 bg-white/5 rounded-full overflow-hidden">
                          <div
                            className="h-full bg-[#00C896] rounded-full"
                            style={{ width: `${p.prob * 100}%` }}
                          />
                        </div>
                        <span className="font-mono text-[#00C896] w-12 text-right">
                          {(p.prob * 100).toFixed(1)}%
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <div className="mt-3 p-2 bg-white/\[0.03\] rounded text-xs text-[#4A5568]">
                <ArrowRight
                  size={12}
                  className="inline text-[#00C896] mr-1"
                />
                The gate = x_sparse · y_sparse shapes which neurons contribute
                to the next prediction. More context → more specific gates →
                sharper distribution.
              </div>
            </motion.div>

            {/* Layer-by-Layer σ Summary */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.1 }}
              className="glass-card p-6"
            >
              <h3 className="text-lg font-semibold mb-1 flex items-center gap-2">
                <Layers size={20} className="text-[#2A7FFF]" />
                Layer-by-Layer Gate Activity
              </h3>
              <p className="text-xs text-[#4A5568] mb-4">
                Total Hebbian gate magnitude per layer — where does the model
                concentrate its gating?
              </p>

              <div className="space-y-2">
                {data.layer_summary.map((ls) => {
                  const totalGate = ls.heads.reduce(
                    (s: number, h: HeadSummary) => s + h.total_gate_activity,
                    0,
                  );
                  const maxLayerGate = Math.max(
                    ...data.layer_summary.map((l) =>
                      l.heads.reduce(
                        (s: number, h: HeadSummary) =>
                          s + h.total_gate_activity,
                        0,
                      ),
                    ),
                  );
                  const pct =
                    maxLayerGate > 0 ? (totalGate / maxLayerGate) * 100 : 0;
                  const isExpanded = expandedLayer === ls.layer;
                  const isSelected = selectedLayer === ls.layer;

                  return (
                    <div key={ls.layer}>
                      <div
                        className={`flex items-center gap-2 p-2 rounded-lg cursor-pointer transition-all ${
                          isSelected
                            ? "bg-bdh-accent/10 ring-1 ring-bdh-accent/30"
                            : "hover:bg-white/[0.05]"
                        }`}
                        onClick={() => {
                          setSelectedLayer(ls.layer);
                          setExpandedLayer(isExpanded ? null : ls.layer);
                        }}
                      >
                        {isExpanded ? (
                          <ChevronDown size={12} className="text-[#4A5568]" />
                        ) : (
                          <ChevronRight size={12} className="text-[#4A5568]" />
                        )}
                        <span
                          className={`font-mono text-xs w-6 ${isSelected ? "text-[#E2E8F0]" : "text-[#8B95A5]"}`}
                        >
                          L{ls.layer}
                        </span>
                        <div className="flex-1 h-3 bg-white/5 rounded-full overflow-hidden">
                          <motion.div
                            className="h-full rounded-full"
                            style={{
                              backgroundColor:
                                LAYER_GRADIENT[
                                  ls.layer % LAYER_GRADIENT.length
                                ],
                            }}
                            initial={{ width: 0 }}
                            animate={{ width: `${pct}%` }}
                            transition={{ duration: 0.5 }}
                          />
                        </div>
                        <span className="font-mono text-xs text-[#8B95A5] w-16 text-right">
                          {totalGate.toFixed(0)}
                        </span>
                      </div>

                      {/* Expanded: per-head breakdown */}
                      <AnimatePresence>
                        {isExpanded && (
                          <motion.div
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: "auto", opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            className="overflow-hidden ml-6 mt-1 space-y-1"
                          >
                            {ls.heads.map((h) => (
                              <div
                                key={h.head}
                                className={`flex items-center gap-2 p-1.5 rounded cursor-pointer ${
                                  selectedHead === h.head && isSelected
                                    ? "bg-white/[0.08]"
                                    : "hover:bg-white/[0.04]"
                                }`}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setSelectedLayer(ls.layer);
                                  setSelectedHead(h.head);
                                }}
                              >
                                <span
                                  className="w-4 h-4 rounded-full text-[8px] flex items-center justify-center"
                                  style={{
                                    backgroundColor: `${HEAD_COLORS[h.head % HEAD_COLORS.length]}30`,
                                    color:
                                      HEAD_COLORS[h.head % HEAD_COLORS.length],
                                  }}
                                >
                                  {h.head}
                                </span>
                                <div className="flex-1 h-2 bg-white/5 rounded-full overflow-hidden">
                                  <div
                                    className="h-full rounded-full"
                                    style={{
                                      width: `${totalGate > 0 ? (h.total_gate_activity / totalGate) * 100 : 0}%`,
                                      backgroundColor:
                                        HEAD_COLORS[
                                          h.head % HEAD_COLORS.length
                                        ],
                                    }}
                                  />
                                </div>
                                <span className="text-[10px] font-mono text-[#4A5568] w-14 text-right">
                                  {h.total_gate_activity.toFixed(0)}
                                </span>
                                {h.top_synapse && (
                                  <span className="text-[9px] text-[#4A5568] font-mono">
                                    top: {h.top_synapse.id}
                                  </span>
                                )}
                              </div>
                            ))}
                          </motion.div>
                        )}
                      </AnimatePresence>
                    </div>
                  );
                })}
              </div>
            </motion.div>
          </div>
        </div>
      )}

      {/* ── Gate Activity Heatmap ── */}
      {data && headData && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="glass-card p-6 mb-6"
        >
          <h3 className="text-lg font-semibold mb-1 flex items-center gap-2">
            <Zap size={20} className="text-amber-400" />
            Gate Activity by Word
          </h3>
          <p className="text-xs text-[#4A5568] mb-4">
            Total Σ(x_sparse · y_sparse) at each word position — brighter =
            stronger Hebbian co-activation
          </p>

          <div className="flex flex-wrap gap-1">
            {words.map((w, i) => {
              const intensity = Math.min(w.gate_activity / maxGate, 1);
              const isActive = i === currentWord;
              return (
                <motion.div
                  key={i}
                  className={`px-3 py-2 rounded-lg cursor-pointer text-sm font-mono transition-all ${
                    isActive ? "ring-2 ring-amber-400/60" : ""
                  }`}
                  style={{
                    backgroundColor: `rgba(245, 158, 11, ${0.05 + intensity * 0.5})`,
                    color:
                      intensity > 0.5
                        ? "#fff"
                        : intensity > 0.2
                          ? "#fbbf24"
                          : "#6b7280",
                  }}
                  onClick={() => setCurrentWord(i)}
                  whileHover={{ scale: 1.05 }}
                  title={`gate=${w.gate_activity.toFixed(2)}`}
                >
                  {w.word}
                  <div className="text-[9px] text-center mt-0.5 opacity-60">
                    {w.gate_activity.toFixed(0)}
                  </div>
                </motion.div>
              );
            })}
          </div>
        </motion.div>
      )}

      {/* ── Animated Hero (shown before analysis) ── */}
      {!data && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="space-y-6"
        >
          {/* Animated pipeline diagram */}
          <div className="glass-card p-8 relative overflow-hidden">
            <h3 className="text-xl font-bold mb-2 text-center relative z-10">
              <Sparkles size={18} className="inline text-amber-400 mr-2" />
              The BDH Hebbian Pipeline
            </h3>
            <p className="text-[#4A5568] text-sm text-center mb-8 relative z-10">
              How a single byte flows through the gated Hebbian architecture
            </p>

            {/* 4-stage animated pipeline */}
            <div className="relative z-10 flex items-center justify-center gap-2 md:gap-4 flex-wrap">
              {[
                {
                  label: "Encode",
                  formula: "x_sparse = ReLU(x·E)",
                  color: "#3b82f6",
                  icon: Brain,
                  desc: "Project to 8192-dim sparse space",
                },
                {
                  label: "Attend",
                  formula: "a* = Attn(x_sparse)·x",
                  color: "#22c55e",
                  icon: Network,
                  desc: "Linear attention co-activation",
                },
                {
                  label: "Gate",
                  formula: "gate = x·y (Hebbian)",
                  color: "#8b5cf6",
                  icon: Zap,
                  desc: "Fire together, gate together",
                },
                {
                  label: "Decode",
                  formula: "x_l = x + D·gate",
                  color: "#f59e0b",
                  icon: Layers,
                  desc: "Residual back to embed space",
                },
              ].map((stage, i) => (
                <div
                  key={stage.label}
                  className="flex items-center gap-2 md:gap-4"
                >
                  <motion.div
                    className="relative flex flex-col items-center"
                    initial={{ opacity: 0, y: 30 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.2 + i * 0.15, duration: 0.5 }}
                  >
                    {/* Pulsing ring */}
                    <motion.div
                      className="absolute inset-0 rounded-2xl"
                      style={{ border: `2px solid ${stage.color}` }}
                      animate={{
                        scale: [1, 1.08, 1],
                        opacity: [0.3, 0.7, 0.3],
                      }}
                      transition={{
                        duration: 2,
                        repeat: Infinity,
                        delay: i * 0.5,
                      }}
                    />
                    <div
                      className="w-36 md:w-44 p-4 rounded-2xl border"
                      style={{
                        borderColor: `${stage.color}40`,
                        background: `${stage.color}08`,
                      }}
                    >
                      <div className="flex items-center gap-2 mb-2">
                        <stage.icon size={16} style={{ color: stage.color }} />
                        <span
                          className="text-sm font-semibold"
                          style={{ color: stage.color }}
                        >
                          {i + 1}. {stage.label}
                        </span>
                      </div>
                      <div className="font-mono text-[11px] text-[#CBD5E0] mb-1">
                        {stage.formula}
                      </div>
                      <p className="text-[10px] text-[#4A5568]">{stage.desc}</p>
                    </div>
                  </motion.div>

                  {/* Animated arrow between stages */}
                  {i < 3 && (
                    <motion.div
                      className="hidden md:flex items-center"
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      transition={{ delay: 0.5 + i * 0.15 }}
                    >
                      <motion.div
                        animate={{ x: [0, 6, 0] }}
                        transition={{
                          duration: 1.5,
                          repeat: Infinity,
                          delay: i * 0.4,
                        }}
                      >
                        <ArrowRight size={18} className="text-[#4A5568]" />
                      </motion.div>
                    </motion.div>
                  )}
                </div>
              ))}
            </div>

            {/* Animated neuron firing visualization */}
            <div className="mt-10 relative z-10">
              <div className="flex items-center justify-center gap-1 mb-3">
                <Zap size={14} className="text-[#2A7FFF]" />
                <span className="text-xs text-[#4A5568]">
                  Simulated neuron co-activation
                </span>
              </div>
              <div className="flex justify-center gap-[2px] flex-wrap max-w-2xl mx-auto">
                {Array.from({ length: 80 }, (_, i) => {
                  const phase = (i * 0.3) % (2 * Math.PI);
                  return (
                    <motion.div
                      key={i}
                      className="w-3 h-8 rounded-sm"
                      animate={{
                        backgroundColor: [
                          "rgba(139, 92, 246, 0.05)",
                          i % 7 === 0 || i % 11 === 0
                            ? "rgba(139, 92, 246, 0.7)"
                            : "rgba(139, 92, 246, 0.15)",
                          "rgba(139, 92, 246, 0.05)",
                        ],
                        scaleY: [
                          0.3,
                          i % 7 === 0 || i % 11 === 0 ? 1 : 0.5,
                          0.3,
                        ],
                      }}
                      transition={{
                        duration: 2.5,
                        repeat: Infinity,
                        delay: phase * 0.3,
                        ease: "easeInOut",
                      }}
                    />
                  );
                })}
              </div>
              <p className="text-center text-[10px] text-[#4A5568] mt-2">
                ~5% of 8192 neurons fire per token — the gate amplifies
                correlated pairs
              </p>
            </div>
          </div>

          {/* Key insight cards */}
          <div className="grid md:grid-cols-3 gap-4">
            {[
              {
                icon: Brain,
                color: "#8b5cf6",
                title: "Hebbian Gating",
                text: 'gate = x_sparse · y_sparse implements "neurons that fire together, gate together" — a direct Hebbian outer product at each layer.',
              },
              {
                icon: Activity,
                color: "#06b6d4",
                title: "Cumulative σ",
                text: "σ(i,j) = Σ y[τ,i]·x[τ,j] accumulates through the sentence. Watch how context words strengthen specific synapse pairs.",
              },
              {
                icon: BarChart3,
                color: "#22c55e",
                title: "Prediction Shift",
                text: "See how the Hebbian gate reshapes the model's next-byte predictions as more context flows in — from generic to specific.",
              },
            ].map((card, i) => (
              <motion.div
                key={card.title}
                className="glass-card p-5 border-t-2"
                style={{ borderTopColor: card.color }}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.6 + i * 0.1 }}
              >
                <div className="flex items-center gap-2 mb-2">
                  <card.icon size={18} style={{ color: card.color }} />
                  <span
                    className="font-semibold text-sm"
                    style={{ color: card.color }}
                  >
                    {card.title}
                  </span>
                </div>
                <p className="text-xs text-[#8B95A5] leading-relaxed">
                  {card.text}
                </p>
              </motion.div>
            ))}
          </div>

          {/* Bottom note */}
          <motion.div
            className="glass-card p-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 1 }}
          >
            <p className="text-[#4A5568] text-xs text-center">
              <span className="text-white font-medium">Note:</span> This
              visualizes inference-time Hebbian dynamics within a single forward
              pass. The model&apos;s weights are frozen — what changes is which
              neurons co-activate as context accumulates word by word.
            </p>
          </motion.div>
        </motion.div>
      )}

      {/* ── Compact Explainer (shown after analysis, collapsed) ── */}
      {data && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="glass-card p-4 mt-6"
        >
          <div className="flex items-center gap-2 mb-3">
            <Brain size={16} className="text-bdh-accent" />
            <span className="text-sm font-semibold text-[#CBD5E0]">
              Pipeline Recap
            </span>
            <div className="flex-1 h-px bg-white/5" />
          </div>
          <div className="flex gap-3 flex-wrap text-[10px] font-mono">
            <span className="px-2 py-1 rounded bg-blue-500/10 text-blue-400 border border-blue-500/20">
              1. x_sparse = ReLU(x·E)
            </span>
            <ArrowRight size={12} className="text-[#4A5568] self-center" />
            <span className="px-2 py-1 rounded bg-green-500/10 text-green-400 border border-green-500/20">
              2. a* = Attn(x_sparse)·x
            </span>
            <ArrowRight size={12} className="text-[#4A5568] self-center" />
            <span className="px-2 py-1 rounded bg-[#2A7FFF]/10 text-[#2A7FFF] border border-[#2A7FFF]/20">
              3. gate = x·y (Hebbian)
            </span>
            <ArrowRight size={12} className="text-[#4A5568] self-center" />
            <span className="px-2 py-1 rounded bg-amber-500/10 text-amber-400 border border-amber-500/20">
              4. x_l = x + D·gate
            </span>
          </div>
          <p className="text-[10px] text-[#4A5568] mt-2">
            gate = x_sparse · y_sparse is the Hebbian signal. σ accumulates
            through the sentence. Weights are frozen — only co-activation
            patterns change.
          </p>
        </motion.div>
      )}
    </div>
  );
}


================================================================================
 FILE: pages\MergePage.tsx  (1390 lines)
================================================================================

import React, { useState, useEffect, useCallback } from "react";
import { motion } from "framer-motion";
import {
  GitMerge,
  Check,
  Zap,
  Brain,
  BarChart3,
  FileText,
  AlertCircle,
  Terminal,
  Send,
  Loader2,
  Activity,
  TrendingDown,
  Timer,
} from "lucide-react";

/* ================================================================== */
/*  Types                                                              */
/* ================================================================== */
interface ModelInfo {
  name: string;
  flag: string;
  params: number;
  n_neurons: number;
  n_heads: number;
  n_layers: number;
  n_embd: number;
}
interface Heritage {
  model1_name: string;
  model2_name: string;
  neurons_per_head_original: number;
  neurons_per_head_merged: number;
  total_neurons_per_model: number;
  total_neurons_merged: number;
  ranges: Record<string, { start: number; end: number }>;
}
interface EvalResult {
  french_loss: number | null;
  portuguese_loss: number | null;
}
interface Sample {
  label: string;
  prompt: string;
  generated: string;
  french_generated?: string;
  portuguese_generated?: string;
  merged_generated?: string;
  finetuned_generated?: string;
}
interface HeritageProbeLayerData {
  french: LayerHeritage;
  portuguese: LayerHeritage;
}
interface HeritageProbeInput {
  layers: Record<string, HeritageProbeLayerData>;
  summary: {
    french_percentage: number;
    portuguese_percentage: number;
    dominant_heritage: string;
  };
}
interface HeritageProbeData {
  french_input: HeritageProbeInput;
  portuguese_input: HeritageProbeInput;
  summary: {
    french_input_french_pct: number;
    french_input_portuguese_pct: number;
    portuguese_input_french_pct: number;
    portuguese_input_portuguese_pct: number;
    routing_quality: number;
    clear_separation: boolean;
  };
}
interface FinetuneInfo {
  source_checkpoint: string;
  iters: number;
  lr: number;
  pre_loss: number;
  post_loss: number;
}
interface MergeData {
  heritage: Heritage;
  models: Record<string, ModelInfo>;
  evaluation: Record<string, EvalResult>;
  samples: Sample[];
  heritage_probe?: HeritageProbeData;
  finetune_info?: FinetuneInfo;
}
interface ProbeResult {
  text: string;
  heritage_split: number;
  layers: Record<number, { french: LayerHeritage; portuguese: LayerHeritage }>;
  summary: {
    french_percentage: number;
    portuguese_percentage: number;
    dominant_heritage: string;
  };
}
interface LayerHeritage {
  origin: string;
  active_count: number;
  total_count: number;
  activation_ratio: number;
}

/* ================================================================== */
/*  Helpers                                                            */
/* ================================================================== */
const fmtP = (n: number) =>
  n >= 1e6 ? `${(n / 1e6).toFixed(1)}M` : `${(n / 1e3).toFixed(0)}K`;
const fmtN = (n: number) => n.toLocaleString();
const lossColor = (v: number | null) =>
  v === null
    ? "text-[#4A5568]"
    : v < 1.2
      ? "text-[#00C896]"
      : v < 2.0
        ? "text-amber-400"
        : "text-red-400";
const lossDisplay = (v: number | null) => (v === null ? "—" : v.toFixed(4));
const API = "/api/merge";

/* ================================================================== */
/*  Main                                                               */
/* ================================================================== */
export function MergePage() {
  const [data, setData] = useState<MergeData | null>(null);
  const [loading, setLoading] = useState(true);
  const [backendAvailable, setBackendAvailable] = useState(false);

  useEffect(() => {
    fetch("/merge/merge_data.json")
      .then((r) => r.json())
      .then((d) => {
        setData(d);
        setLoading(false);
      })
      .catch(() => setLoading(false));
    fetch("/health")
      .then((r) => (r.ok ? setBackendAvailable(true) : null))
      .catch(() => {});
  }, []);

  if (loading)
    return (
      <div
        className="min-h-screen flex items-center justify-center"
        style={{ background: "#070D12" }}
      >
        <Loader2 className="w-8 h-8 animate-spin text-[#8B95A5]" />
      </div>
    );

  const d = data;
  const h = d?.heritage;
  const models = d?.models;
  const ev = d?.evaluation;
  const samples = d?.samples;
  const hasEval = ev && Object.values(ev).some((e) => e.french_loss !== null);
  const hasFT = ev && "finetuned" in ev;
  const probeData = d?.heritage_probe;
  const ftInfo = d?.finetune_info;

  return (
    <div
      className="max-w-7xl mx-auto px-4 py-8 space-y-10"
      style={{ background: "#070D12", minHeight: "100vh" }}
    >
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex items-center gap-3 mb-2">
          <GitMerge className="w-8 h-8 text-[#00C896]" />
          <h1 className="text-3xl font-bold text-[#E2E8F0]">Model Merging</h1>
        </div>
        <p className="text-[#8B95A5] max-w-3xl">
          BDH's sparse, modular architecture enables direct concatenation of
          specialist models.
          {hasFT
            ? " After a brief fine-tuning step, the merged model handles both languages with near-specialist quality."
            : " Each specialist's neurons operate independently in the merged model."}
        </p>
      </motion.div>

      {h && models && (
        <MergeDiagram heritage={h} models={models} hasFT={hasFT} />
      )}
      {models && ev && <ModelCards models={models} evaluation={ev} />}
      {hasEval && <LossComparison evaluation={ev!} hasFT={!!hasFT} />}
      {ftInfo && <FinetuneInfoPanel info={ftInfo} />}
      {samples && samples.length > 0 && <SampleGenerations samples={samples} />}
      {h && <HeritageMap heritage={h} />}
      {probeData && h && (
        <PrecomputedHeritageProbe probe={probeData} heritage={h} />
      )}
      {h && <HeritageProbe heritage={h} backendAvailable={backendAvailable} />}
      <LiveGeneration backendAvailable={backendAvailable} />
      <InsightPanel hasFT={!!hasFT} />
    </div>
  );
}

/* ================================================================== */
/*  Merge Diagram                                                      */
/* ================================================================== */
function MergeDiagram({
  heritage: h,
  models,
  hasFT,
}: {
  heritage: Heritage;
  models: Record<string, ModelInfo>;
  hasFT?: boolean;
}) {
  const [step, setStep] = useState(0);
  const maxStep = hasFT ? 4 : 3;
  useEffect(() => {
    const t = setInterval(() => setStep((s) => (s + 1) % maxStep), 1500);
    return () => clearInterval(t);
  }, [maxStep]);

  const steps = [
    {
      label: h.model1_name.charAt(0).toUpperCase() + h.model1_name.slice(1),
      sub: "Specialist",
      icon: "FR",
    },
    {
      label: h.model2_name.charAt(0).toUpperCase() + h.model2_name.slice(1),
      sub: "Specialist",
      icon: "PT",
    },
    { label: "Merge", sub: "Concatenate N", icon: "M" },
    ...(hasFT
      ? [{ label: "Fine-tune", sub: "Adapt routing", icon: "FT" }]
      : []),
    { label: "Polyglot", sub: "Both languages", icon: "P" },
  ];

  const fr = models[h.model1_name];
  const pt = models[h.model2_name];
  const mg = models.finetuned || models.merged;

  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.1 }}
    >
      <div className="flex items-center gap-2 mb-4">
        <h2 className="text-lg font-semibold">MERGE PROCESS</h2>
      </div>
      <div className="flex items-center justify-between mb-8">
        {steps.map((s, i) => (
          <React.Fragment key={i}>
            <div className="flex flex-col items-center">
              <motion.div
                className={`w-14 h-14 rounded-full flex items-center justify-center text-sm font-bold border-2 transition-all duration-300
                ${i <= step ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]" : "border-white/[0.12] text-[#4A5568]"}`}
                animate={i === step ? { scale: [1, 1.1, 1] } : {}}
                transition={{ repeat: Infinity, duration: 1.5 }}
              >
                {i < step ? <Check className="w-5 h-5" /> : s.icon}
              </motion.div>
              <span
                className={`text-xs mt-1 ${i <= step ? "text-[#00C896]" : "text-[#4A5568]"}`}
              >
                {s.label}
              </span>
              <span className="text-[10px] text-[#4A5568]">{s.sub}</span>
            </div>
            {i < steps.length - 1 && (
              <div
                className={`flex-1 h-0.5 mx-2 ${i < step ? "bg-[#00C896]/50" : "bg-white/10"}`}
              />
            )}
          </React.Fragment>
        ))}
      </div>
      {/* Visual */}
      <div className="grid grid-cols-3 gap-4 items-center">
        <motion.div
          className="border border-white/10 rounded-lg p-4"
          animate={{ opacity: step >= 0 ? 1 : 0.3 }}
        >
          <div className="flex items-center gap-2 text-sm mb-2">
            <span className="text-[#00C896] font-mono">FR</span>
            <span className="text-[#00C896] font-semibold">{fr?.name}</span>
          </div>
          <div className="text-xs text-[#8B95A5]">
            N/head:{" "}
            <span className="text-[#E2E8F0] font-mono">
              {fmtN(fr?.n_neurons || 0)}
            </span>
          </div>
          <div className="flex gap-0.5 mt-2">
            {Array(12)
              .fill(0)
              .map((_, i) => (
                <div key={i} className="w-3 h-5 rounded-sm bg-[#00C896]/40" />
              ))}
          </div>
        </motion.div>
        <motion.div
          className={`border rounded-lg p-4 text-center ${step >= 3 ? "border-white/[0.12] bg-white/[0.03]" : "border-white/10"}`}
          animate={{ opacity: step >= 2 ? 1 : 0.2 }}
          transition={{ duration: 0.5 }}
        >
          {step >= 3 && mg && (
            <>
              <div className="flex items-center justify-center gap-2 mb-1">
                <span className="font-semibold text-[#E2E8F0]">{mg.name}</span>
              </div>
              <div className="text-xs text-[#8B95A5]">
                N/head:{" "}
                <span className="font-mono text-[#E2E8F0]">
                  {fmtN(mg.n_neurons)}
                </span>
              </div>
              <div className="flex gap-0.5 mt-2 justify-center flex-wrap">
                {Array(12)
                  .fill(0)
                  .map((_, i) => (
                    <div
                      key={i}
                      className="w-3 h-5 rounded-sm bg-[#00C896]/40"
                    />
                  ))}
                {Array(12)
                  .fill(0)
                  .map((_, i) => (
                    <div
                      key={i + 12}
                      className="w-3 h-5 rounded-sm bg-sky-500/40"
                    />
                  ))}
              </div>
              <div className="flex gap-3 justify-center mt-1 text-[10px] text-[#4A5568]">
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 rounded-sm bg-[#00C896]" /> French
                </span>
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 rounded-sm bg-sky-500" /> Portuguese
                </span>
              </div>
            </>
          )}
        </motion.div>
        <motion.div
          className="border border-white/10 rounded-lg p-4"
          animate={{ opacity: step >= 1 ? 1 : 0.3 }}
        >
          <div className="flex items-center gap-2 text-sm mb-2">
            <span className="text-sky-400 font-mono">PT</span>
            <span className="text-sky-300 font-semibold">{pt?.name}</span>
          </div>
          <div className="text-xs text-[#8B95A5]">
            N/head:{" "}
            <span className="text-[#E2E8F0] font-mono">
              {fmtN(pt?.n_neurons || 0)}
            </span>
          </div>
          <div className="flex gap-0.5 mt-2">
            {Array(12)
              .fill(0)
              .map((_, i) => (
                <div key={i} className="w-3 h-5 rounded-sm bg-sky-500/40" />
              ))}
          </div>
        </motion.div>
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  Model Cards                                                        */
/* ================================================================== */
function ModelCards({
  models,
  evaluation,
}: {
  models: Record<string, ModelInfo>;
  evaluation: Record<string, EvalResult>;
}) {
  const order = Object.keys(models);
  const colors: Record<string, string> = {
    french: "cyan",
    portuguese: "emerald",
    merged: "amber",
    finetuned: "purple",
  };
  return (
    <div
      className={`grid grid-cols-1 gap-4 ${order.length <= 3 ? "md:grid-cols-3" : "md:grid-cols-2 lg:grid-cols-4"}`}
    >
      {order.map((k, i) => {
        const m = models[k];
        const ev = evaluation[k];
        const c = colors[k] || "zinc";
        return (
          <motion.div
            key={k}
            className={`glass-card p-5 ${k === "finetuned" ? "" : ""}`}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 * i }}
          >
            <div className="flex items-center gap-2 mb-3">
              <span className="text-xs">{m.flag}</span>
              <span className="font-semibold text-[#E2E8F0]">{m.name}</span>
            </div>
            <div className="space-y-1.5 text-sm">
              <Row label="Parameters" value={fmtP(m.params)} />
              <Row label="Neurons/Head" value={fmtN(m.n_neurons)} />
              <Row
                label="Layers x Heads"
                value={`${m.n_layers} x ${m.n_heads}`}
              />
              <Row label="Embedding dim" value={String(m.n_embd)} />
              {ev && (
                <>
                  <div className="border-t border-white/[0.06] my-2" />
                  <Row
                    label="French loss"
                    value={lossDisplay(ev.french_loss)}
                    valueClass={lossColor(ev.french_loss)}
                  />
                  <Row
                    label="Portuguese loss"
                    value={lossDisplay(ev.portuguese_loss)}
                    valueClass={lossColor(ev.portuguese_loss)}
                  />
                </>
              )}
            </div>
          </motion.div>
        );
      })}
    </div>
  );
}
function Row({
  label,
  value,
  valueClass,
}: {
  label: string;
  value: string;
  valueClass?: string;
}) {
  return (
    <div className="flex justify-between">
      <span className="text-[#8B95A5]">{label}</span>
      <span className={`font-mono ${valueClass || "text-[#E2E8F0]"}`}>
        {value}
      </span>
    </div>
  );
}

/* ================================================================== */
/*  Loss Comparison                                                    */
/* ================================================================== */
function LossComparison({
  evaluation,
  hasFT,
}: {
  evaluation: Record<string, EvalResult>;
  hasFT: boolean;
}) {
  const order = Object.keys(evaluation);
  const flags: Record<string, string> = {
    french: "FR",
    portuguese: "PT",
    merged: "MG",
    finetuned: "FT",
  };
  const rowColors: Record<string, string> = {
    merged: "",
    finetuned: "",
  };
  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.2 }}
    >
      <div className="flex items-center gap-2 mb-4">
        <BarChart3 className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">LOSS COMPARISON</h2>
        <span className="text-xs text-[#4A5568] ml-2">
          NEXT-BYTE PREDICTION LOSS (LOWER = BETTER)
        </span>
      </div>
      <table className="w-full text-sm">
        <thead>
          <tr className="text-[#4A5568] border-b border-white/[0.06]">
            <th className="text-left pb-2 w-1/3">Model</th>
            <th className="text-right pb-2 text-[#CBD5E0]">French Loss</th>
            <th className="text-right pb-2 text-[#CBD5E0]">Portuguese Loss</th>
          </tr>
        </thead>
        <tbody>
          {order.map((k) => {
            const ev = evaluation[k];
            return (
              <tr
                key={k}
                className={`border-b border-white/[0.06] ${rowColors[k] || ""}`}
              >
                <td className="py-3 flex items-center gap-2">
                  <span className="text-xs">{flags[k] || k}</span>
                  <span className="font-medium">
                    {k === "finetuned"
                      ? "Merged (fine-tuned)"
                      : k === "merged"
                        ? "Merged (zero-shot)"
                        : k.charAt(0).toUpperCase() + k.slice(1)}
                  </span>
                </td>
                <td
                  className={`text-right font-mono ${lossColor(ev.french_loss)}`}
                >
                  {lossDisplay(ev.french_loss)}
                </td>
                <td
                  className={`text-right font-mono ${lossColor(ev.portuguese_loss)}`}
                >
                  {lossDisplay(ev.portuguese_loss)}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
      <div className="mt-4 p-3 bg-white/[0.03] rounded-lg text-sm text-[#8B95A5] flex items-start gap-2">
        {hasFT ? (
          <span>
            The zero-shot merge shows degraded loss because averaging embeddings
            blurs the routing signal. After just ~500 iterations of fine-tuning
            on mixed data, the model{" "}
            <b className="text-[#E2E8F0]">
              recovers near-specialist quality on both languages
            </b>{" "}
            — proving BDH's neuron spaces are truly composable.
          </span>
        ) : (
          <span>
            Each specialist excels at its own language. The merged model handles{" "}
            <b className="text-[#E2E8F0]">both languages</b> after concatenating
            neuron spaces.
          </span>
        )}
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  Sample Generations                                                 */
/* ================================================================== */
function SampleGenerations({ samples }: { samples: Sample[] }) {
  const [selected, setSelected] = useState(0);
  const s = samples[selected];
  const hasFT = !!s?.finetuned_generated;

  const gens = [
    { key: "french_generated", label: "French Specialist", color: "cyan" },
    {
      key: "portuguese_generated",
      label: "Portuguese Specialist",
      color: "emerald",
    },
    { key: "merged_generated", label: "Merged (zero-shot)", color: "amber" },
    ...(hasFT
      ? [
          {
            key: "finetuned_generated",
            label: "Merged (fine-tuned)",
            color: "purple",
          },
        ]
      : []),
  ];

  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.3 }}
    >
      <div className="flex items-center gap-2 mb-4">
        <FileText className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">SAMPLE GENERATIONS</h2>
        <span className="text-xs text-[#4A5568] ml-2">
          SAME PROMPT THROUGH ALL MODELS
        </span>
      </div>
      <div className="flex gap-2 mb-4 flex-wrap">
        {samples.map((sample, i) => (
          <button
            key={i}
            onClick={() => setSelected(i)}
            className={`px-3 py-1 text-xs rounded-full border transition-all ${
              i === selected
                ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
                : "border-white/10 text-[#4A5568] hover:border-white/20"
            }`}
          >
            {sample.label}
          </button>
        ))}
      </div>
      <div className="space-y-3">
        {gens.map((g) => {
          const text = (s as any)[g.key];
          if (!text) return null;
          return (
            <div
              key={g.key}
              className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06]"
            >
              <span className="text-xs font-medium text-[#CBD5E0] mb-1 block">
                {g.label}
              </span>
              <p className="font-mono text-sm text-[#CBD5E0] break-all">
                <span className="text-[#CBD5E0]">{s.prompt}</span>
                <span className="text-[#8B95A5]">
                  {text.slice(s.prompt.length)}
                </span>
              </p>
            </div>
          );
        })}
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  Heritage Map                                                       */
/* ================================================================== */
function HeritageMap({ heritage: h }: { heritage: Heritage }) {
  const segs = 120;
  const split = segs / 2;
  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.4 }}
    >
      <div className="flex items-center gap-2 mb-3">
        <AlertCircle className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">NEURON HERITAGE MAP</h2>
      </div>
      <p className="text-sm text-[#8B95A5] mb-3">
        Each neuron traces back to exactly one specialist.{" "}
        {h.model1_name.charAt(0).toUpperCase() + h.model1_name.slice(1)}{" "}
        neurons: 0–{fmtN(h.ranges[h.model1_name]?.end || 0)},{" "}
        {h.model2_name.charAt(0).toUpperCase() + h.model2_name.slice(1)}{" "}
        neurons: {fmtN(h.ranges[h.model2_name]?.start || 0)}–
        {fmtN(h.ranges[h.model2_name]?.end || 0)}.
      </p>
      <div className="flex gap-[1px] my-3" style={{ height: 24 }}>
        {Array(segs)
          .fill(0)
          .map((_, i) => (
            <div
              key={i}
              className={`flex-1 rounded-sm ${i < split ? "bg-[#00C896]/70" : "bg-sky-500/70"}`}
              style={{ opacity: 0.5 + Math.random() * 0.5 }}
            />
          ))}
      </div>
      <div className="flex justify-between text-[10px] text-[#4A5568] font-mono mb-4">
        <span>0</span>
        <span>← {h.model1_name} →</span>
        <span>{fmtN(h.neurons_per_head_original)}</span>
        <span>← {h.model2_name} →</span>
        <span>{fmtN(h.neurons_per_head_merged)}</span>
      </div>
      <div className="grid grid-cols-3 gap-4">
        {[
          {
            l: `${h.model1_name.toUpperCase()} NEURONS`,
            v: fmtN(h.total_neurons_per_model),
            c: "cyan",
          },
          {
            l: `${h.model2_name.toUpperCase()} NEURONS`,
            v: fmtN(h.total_neurons_per_model),
            c: "emerald",
          },
          { l: "MERGED TOTAL", v: fmtN(h.total_neurons_merged), c: "purple" },
        ].map((x, i) => (
          <div
            key={i}
            className="text-center border border-white/[0.06] rounded-lg py-3"
          >
            <div className="text-xl font-bold text-[#E2E8F0] font-mono">
              {x.v}
            </div>
            <div className="text-[10px] text-[#4A5568]">{x.l}</div>
          </div>
        ))}
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  LIVE Heritage Probe                                                */
/* ================================================================== */
function HeritageProbe({
  heritage,
  backendAvailable,
}: {
  heritage: Heritage;
  backendAvailable: boolean;
}) {
  const [text, setText] = useState(
    "Le parlement européen a adopté la résolution.",
  );
  const [result, setResult] = useState<ProbeResult | null>(null);
  const [probing, setProbing] = useState(false);
  const [error, setError] = useState("");

  const probe = useCallback(async () => {
    if (!text.trim()) return;
    setProbing(true);
    setError("");
    try {
      // Try fine-tuned first, fall back to merged_polyglot
      let model = "merged_finetuned";
      let res = await fetch(`${API}/heritage-probe`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, model_name: model }),
      });
      if (!res.ok) {
        model = "merged_polyglot";
        res = await fetch(`${API}/heritage-probe`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text, model_name: model }),
        });
      }
      if (!res.ok) throw new Error(await res.text());
      setResult(await res.json());
    } catch (e: any) {
      setError(e.message || "Probe failed");
    }
    setProbing(false);
  }, [text]);

  const presets = [
    {
      label: "French",
      text: "Le parlement européen a adopté la résolution sur le commerce.",
    },
    {
      label: "Portuguese",
      text: "O parlamento europeu adoptou a resolução sobre o comércio.",
    },
    {
      label: "English",
      text: "The European Parliament adopted the resolution on trade.",
    },
    { label: "Mixed", text: "Bonjour, o parlamento decidiu today." },
  ];

  const s = result?.summary;
  const frPct = s?.french_percentage || 50;
  const ptPct = s?.portuguese_percentage || 50;

  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.5 }}
    >
      <div className="flex items-center gap-2 mb-2">
        <Activity className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">LIVE HERITAGE PROBE</h2>
        {backendAvailable && (
          <span className="text-[10px] bg-[#00C896]/10 text-[#00C896] border border-[#00C896]/20 px-2 py-0.5 rounded-full">
            LIVE
          </span>
        )}
      </div>
      <p className="text-sm text-[#8B95A5] mb-4">
        Type text and see which neurons fire — French-origin or
        Portuguese-origin. French text should activate more French neurons.
      </p>

      {!backendAvailable ? (
        <div className="bg-white/[0.03] rounded-lg p-4 text-sm text-[#8B95A5]">
          <Terminal className="w-4 h-4 inline mr-2" />
          Backend required. Start with:{" "}
          <code className="text-[#CBD5E0]">
            python -m uvicorn backend.main:app --reload
          </code>
        </div>
      ) : (
        <>
          <div className="flex gap-2 mb-3 flex-wrap">
            {presets.map((p) => (
              <button
                key={p.label}
                onClick={() => setText(p.text)}
                className="px-2 py-1 text-xs rounded border border-white/10 text-[#8B95A5] hover:border-white/20 transition-colors"
              >
                {p.label}
              </button>
            ))}
          </div>
          <div className="flex gap-2 mb-4">
            <input
              value={text}
              onChange={(e) => setText(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && probe()}
              className="flex-1 bg-[#0B1216] border border-white/10 rounded-lg px-3 py-2 text-sm text-[#E2E8F0] focus:outline-none focus:border-[#00C896]/50"
              placeholder="Type French, Portuguese, or English..."
            />
            <button
              onClick={probe}
              disabled={probing}
              className="px-4 py-2 bg-[#00C896]/15 border border-[#00C896]/50 rounded-lg text-[#00C896] text-sm font-medium hover:bg-[#00C896]/30 disabled:opacity-50 flex items-center gap-2"
            >
              {probing ? (
                <Loader2 className="w-4 h-4 animate-spin" />
              ) : (
                <Send className="w-4 h-4" />
              )}{" "}
              Probe
            </button>
          </div>
          {error && <div className="text-[#8B95A5] text-sm mb-2">{error}</div>}
          {result && s && (
            <div className="space-y-4">
              <div>
                <div className="flex justify-between text-xs text-[#8B95A5] mb-1">
                  <span className="text-[#CBD5E0]">
                    French neurons: {frPct.toFixed(1)}%
                  </span>
                  <span className="text-[#E2E8F0]">
                    Portuguese neurons: {ptPct.toFixed(1)}%
                  </span>
                </div>
                <div className="flex h-8 rounded-lg overflow-hidden">
                  <motion.div
                    className="bg-[#00C896]/70 flex items-center justify-center text-xs font-bold text-[#E2E8F0]"
                    initial={{ width: "50%" }}
                    animate={{ width: `${frPct}%` }}
                    transition={{ duration: 0.5 }}
                  >
                    {frPct > 15 && `${frPct.toFixed(0)}%`}
                  </motion.div>
                  <motion.div
                    className="bg-sky-500/70 flex items-center justify-center text-xs font-bold text-[#E2E8F0]"
                    initial={{ width: "50%" }}
                    animate={{ width: `${ptPct}%` }}
                    transition={{ duration: 0.5 }}
                  >
                    {ptPct > 15 && `${ptPct.toFixed(0)}%`}
                  </motion.div>
                </div>
                <div className="text-center mt-2 text-sm">
                  Dominant:{" "}
                  <span
                    className={`font-semibold ${s.dominant_heritage === "french" ? "text-[#00C896]" : "text-[#E2E8F0]"}`}
                  >
                    {s.dominant_heritage.charAt(0).toUpperCase() +
                      s.dominant_heritage.slice(1)}
                  </span>
                </div>
              </div>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-2">
                {Object.entries(result.layers).map(([idx, ld]) => {
                  const fr = ld.french,
                    pt = ld.portuguese;
                  const t = fr.activation_ratio + pt.activation_ratio;
                  const w = t > 0 ? (fr.activation_ratio / t) * 100 : 50;
                  return (
                    <div
                      key={idx}
                      className="bg-[#0B1216]/50 rounded-lg p-2 border border-white/[0.06]"
                    >
                      <div className="text-[10px] text-[#4A5568] mb-1 text-center">
                        Layer {idx}
                      </div>
                      <div className="flex h-3 rounded overflow-hidden mb-1">
                        <div
                          className="bg-[#00C896]/70"
                          style={{ width: `${w}%` }}
                        />
                        <div
                          className="bg-sky-500/70"
                          style={{ width: `${100 - w}%` }}
                        />
                      </div>
                      <div className="flex justify-between text-[9px] text-[#4A5568]">
                        <span>{fr.active_count}</span>
                        <span>{pt.active_count}</span>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
        </>
      )}
    </motion.div>
  );
}

/* ================================================================== */
/*  LIVE Generation                                                    */
/* ================================================================== */
function LiveGeneration({ backendAvailable }: { backendAvailable: boolean }) {
  const [prompt, setPrompt] = useState(
    "Le commerce international est essentiel pour",
  );
  const [gens, setGens] = useState<Record<string, string>>({});
  const [generating, setGenerating] = useState(false);

  const go = useCallback(async () => {
    if (!prompt.trim()) return;
    setGenerating(true);
    try {
      const r = await fetch(`${API}/side-by-side`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt, max_tokens: 60 }),
      });
      if (r.ok) {
        const d = await r.json();
        setGens(d.generations);
      }
    } catch {}
    setGenerating(false);
  }, [prompt]);

  if (!backendAvailable) return null;

  const colors: Record<string, string> = {
    french_specialist: "cyan",
    french: "cyan",
    portuguese_specialist: "emerald",
    portuguese: "emerald",
    merged_polyglot: "amber",
    merged: "amber",
    merged_finetuned: "purple",
    finetuned: "purple",
  };
  const labels: Record<string, string> = {
    french_specialist: "French Specialist",
    french: "French Specialist",
    portuguese_specialist: "Portuguese Specialist",
    portuguese: "Portuguese Specialist",
    merged_polyglot: "Merged (zero-shot)",
    merged: "Merged (zero-shot)",
    merged_finetuned: "Merged (fine-tuned)",
    finetuned: "Merged (fine-tuned)",
  };

  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.6 }}
    >
      <div className="flex items-center gap-2 mb-2">
        <Zap className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">LIVE GENERATION</h2>
        <span className="text-[10px] bg-[#00C896]/10 text-[#00C896] border border-[#00C896]/20 px-2 py-0.5 rounded-full">
          LIVE
        </span>
      </div>
      <p className="text-sm text-[#8B95A5] mb-4">
        Same prompt through all models. Compare specialist quality with merged
        and fine-tuned output.
      </p>
      <div className="flex gap-2 mb-4">
        <input
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && go()}
          className="flex-1 bg-[#0B1216] border border-white/10 rounded-lg px-3 py-2 text-sm text-[#E2E8F0] focus:outline-none focus:border-[#00C896]/50"
        />
        <button
          onClick={go}
          disabled={generating}
          className="px-4 py-2 bg-white/5 border border-white/\[0.12\] rounded-lg text-[#E2E8F0] text-sm font-medium hover:bg-white/10 disabled:opacity-50 flex items-center gap-2"
        >
          {generating ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <Zap className="w-4 h-4" />
          )}{" "}
          Generate
        </button>
      </div>
      {Object.keys(gens).length > 0 && (
        <div className="space-y-2">
          {Object.entries(gens).map(([name, text]) => {
            const c = colors[name] || "zinc";
            return (
              <div
                key={name}
                className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06]"
              >
                <span className="text-xs font-medium text-[#CBD5E0] mb-1 block">
                  {labels[name] || name}
                </span>
                <p className="font-mono text-sm text-[#CBD5E0] break-all">
                  <span className="text-[#CBD5E0]">{prompt}</span>
                  <span className="text-[#8B95A5]">{text}</span>
                </p>
              </div>
            );
          })}
        </div>
      )}
    </motion.div>
  );
}

/* ================================================================== */
/*  Fine-tune Info Panel                                               */
/* ================================================================== */
function FinetuneInfoPanel({ info }: { info: FinetuneInfo }) {
  const reduction = ((1 - info.post_loss / info.pre_loss) * 100).toFixed(1);
  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.25 }}
    >
      <div className="flex items-center gap-2 mb-4">
        <TrendingDown className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">FINE-TUNING RESULTS</h2>
        <span className="text-xs text-[#4A5568] ml-2">
          POST-MERGE ADAPTATION
        </span>
      </div>
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        {[
          { label: "Iterations", value: String(info.iters) },
          {
            label: "Learning Rate",
            value: info.lr.toExponential(1),
          },
          {
            label: "Pre-FT Loss",
            value: info.pre_loss.toFixed(4),
          },
          {
            label: "Post-FT Loss",
            value: info.post_loss.toFixed(4),
          },
        ].map((item, i) => (
          <div
            key={i}
            className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06] text-center"
          >
            <div className="text-lg font-bold font-mono text-[#E2E8F0]">
              {item.value}
            </div>
            <div className="text-[10px] text-[#4A5568]">{item.label}</div>
          </div>
        ))}
      </div>
      {/* Loss reduction bar */}
      <div className="bg-[#0B1216]/50 rounded-lg p-4 border border-white/[0.06]">
        <div className="flex justify-between text-xs text-[#8B95A5] mb-2">
          <span>
            Pre-finetune:{" "}
            <span className="text-[#8B95A5] font-mono">
              {info.pre_loss.toFixed(4)}
            </span>
          </span>
          <span>
            Post-finetune:{" "}
            <span className="text-[#CBD5E0] font-mono">
              {info.post_loss.toFixed(4)}
            </span>
          </span>
        </div>
        <div className="relative h-6 bg-white/5 rounded-full overflow-hidden">
          <motion.div
            className="absolute inset-y-0 left-0 bg-gradient-to-r from-[#00C896]/60 to-[#00C896]/60 rounded-full"
            initial={{ width: "100%" }}
            animate={{ width: `${(info.post_loss / info.pre_loss) * 100}%` }}
            transition={{ duration: 1.5, ease: "easeOut" }}
          />
          <div className="absolute inset-0 flex items-center justify-center text-xs font-bold text-[#E2E8F0]">
            {reduction}% reduction
          </div>
        </div>
        <div className="text-center mt-2 text-xs text-[#4A5568]">
          <Timer className="w-3 h-3 inline mr-1" />
          {info.iters} iterations of mixed-language fine-tuning on CPU
        </div>
      </div>
    </motion.div>
  );
}

/* ================================================================== */
/*  Precomputed Heritage Probe                                         */
/* ================================================================== */
function PrecomputedHeritageProbe({
  probe,
  heritage,
}: {
  probe: HeritageProbeData;
  heritage: Heritage;
}) {
  const [selected, setSelected] = useState<"french_input" | "portuguese_input">(
    "french_input",
  );
  const inputData = probe[selected];
  const s = probe.summary;

  const frName =
    heritage.model1_name.charAt(0).toUpperCase() +
    heritage.model1_name.slice(1);
  const ptName =
    heritage.model2_name.charAt(0).toUpperCase() +
    heritage.model2_name.slice(1);

  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.45 }}
    >
      <div className="flex items-center gap-2 mb-2">
        <Brain className="w-5 h-5 text-[#8B95A5]" />
        <h2 className="text-lg font-semibold">HERITAGE PROBE</h2>
        <span className="text-[10px] bg-[#00C896]/10 text-[#00C896] border border-[#00C896]/20 px-2 py-0.5 rounded-full">
          PRECOMPUTED
        </span>
      </div>
      <p className="text-sm text-[#8B95A5] mb-4">
        Neuron activation patterns when feeding French vs Portuguese text
        through the fine-tuned merged model. Shows which neuron bank
        (French-origin vs Portuguese-origin) activates for each input language.
      </p>

      {/* Input selector */}
      <div className="flex gap-2 mb-4">
        {[
          {
            key: "french_input" as const,
            label: `${frName} Input`,
          },
          {
            key: "portuguese_input" as const,
            label: `${ptName} Input`,
          },
        ].map((tab) => (
          <button
            key={tab.key}
            onClick={() => setSelected(tab.key)}
            className={`px-3 py-1.5 text-xs rounded-lg border transition-all ${
              selected === tab.key
                ? "border-[#00C896]/50 bg-[#00C896]/15 text-[#00C896]"
                : "border-white/10 text-[#4A5568] hover:border-white/20"
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Summary bar */}
      <div className="mb-4">
        <div className="flex justify-between text-xs text-[#8B95A5] mb-1">
          <span className="text-[#CBD5E0]">
            {frName} neurons: {inputData.summary.french_percentage.toFixed(1)}%
          </span>
          <span className="text-[#E2E8F0]">
            {ptName} neurons:{" "}
            {inputData.summary.portuguese_percentage.toFixed(1)}%
          </span>
        </div>
        <div className="flex h-8 rounded-lg overflow-hidden">
          <motion.div
            className="bg-[#00C896]/70 flex items-center justify-center text-xs font-bold text-[#E2E8F0]"
            key={`fr-${selected}`}
            initial={{ width: "50%" }}
            animate={{ width: `${inputData.summary.french_percentage}%` }}
            transition={{ duration: 0.5 }}
          >
            {inputData.summary.french_percentage > 15 &&
              `${inputData.summary.french_percentage.toFixed(0)}%`}
          </motion.div>
          <motion.div
            className="bg-sky-500/70 flex items-center justify-center text-xs font-bold text-[#E2E8F0]"
            key={`pt-${selected}`}
            initial={{ width: "50%" }}
            animate={{ width: `${inputData.summary.portuguese_percentage}%` }}
            transition={{ duration: 0.5 }}
          >
            {inputData.summary.portuguese_percentage > 15 &&
              `${inputData.summary.portuguese_percentage.toFixed(0)}%`}
          </motion.div>
        </div>
        <div className="text-center mt-1 text-sm">
          Dominant:{" "}
          <span
            className={`font-semibold ${inputData.summary.dominant_heritage === heritage.model1_name ? "text-[#00C896]" : "text-[#E2E8F0]"}`}
          >
            {inputData.summary.dominant_heritage.charAt(0).toUpperCase() +
              inputData.summary.dominant_heritage.slice(1)}
          </span>
        </div>
      </div>

      {/* Per-layer breakdown */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-2 mb-4">
        {Object.entries(inputData.layers).map(([idx, ld]) => {
          const fr = ld.french,
            pt = ld.portuguese;
          const t = fr.activation_ratio + pt.activation_ratio;
          const w = t > 0 ? (fr.activation_ratio / t) * 100 : 50;
          return (
            <div
              key={idx}
              className="bg-[#0B1216]/50 rounded-lg p-2 border border-white/[0.06]"
            >
              <div className="text-[10px] text-[#4A5568] mb-1 text-center">
                Layer {idx}
              </div>
              <div className="flex h-3 rounded overflow-hidden mb-1">
                <div className="bg-[#00C896]/70" style={{ width: `${w}%` }} />
                <div
                  className="bg-sky-500/70"
                  style={{ width: `${100 - w}%` }}
                />
              </div>
              <div className="flex justify-between text-[9px] text-[#4A5568]">
                <span>{fr.active_count}</span>
                <span>{pt.active_count}</span>
              </div>
            </div>
          );
        })}
      </div>

      {/* Routing quality summary */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
        <div className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06] text-center">
          <div className="text-xs text-[#4A5568] mb-1">
            {frName} Input → {frName} Neurons
          </div>
          <div
            className={`text-lg font-bold font-mono ${s.french_input_french_pct > 55 ? "text-[#00C896]" : "text-[#8B95A5]"}`}
          >
            {s.french_input_french_pct.toFixed(1)}%
          </div>
        </div>
        <div className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06] text-center">
          <div className="text-xs text-[#4A5568] mb-1">
            {ptName} Input → {ptName} Neurons
          </div>
          <div
            className={`text-lg font-bold font-mono ${s.portuguese_input_portuguese_pct > 55 ? "text-sky-400" : "text-[#8B95A5]"}`}
          >
            {s.portuguese_input_portuguese_pct.toFixed(1)}%
          </div>
        </div>
        <div className="bg-[#0B1216]/50 rounded-lg p-3 border border-white/[0.06] text-center">
          <div className="text-xs text-[#4A5568] mb-1">Routing Quality</div>
          <div
            className={`text-lg font-bold font-mono ${s.routing_quality > 60 ? "text-[#00C896]" : s.routing_quality > 50 ? "text-[#CBD5E0]" : "text-[#8B95A5]"}`}
          >
            {s.routing_quality.toFixed(1)}%
          </div>
          {s.clear_separation ? (
            <div className="text-[10px] text-[#00C896] mt-1">
              ✓ Clear language separation
            </div>
          ) : (
            <div className="text-[10px] text-[#8B95A5] mt-1">
              Both banks co-activate — shared representations emerged
            </div>
          )}
        </div>
      </div>

      {!s.clear_separation && (
        <div className="mt-3 p-3 bg-white/[0.03] rounded-lg border border-white/[0.08] text-sm text-[#8B95A5]">
          <AlertCircle className="w-4 h-4 inline mr-1 text-[#8B95A5]" />
          <span>
            The fine-tuned model uses both neuron banks for both languages
            rather than strict routing. This is expected when fine-tuning on a
            small built-in dataset — the model learned shared representations
            across both banks. With larger training data, more distinct routing
            patterns may emerge.
          </span>
        </div>
      )}
    </motion.div>
  );
}

/* ================================================================== */
/*  Insight Panel                                                      */
/* ================================================================== */
function InsightPanel({ hasFT }: { hasFT: boolean }) {
  return (
    <motion.div
      className="glass-card p-6"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ delay: 0.7 }}
    >
      <div className="flex items-center gap-2 mb-4">
        <h2 className="text-lg font-semibold">Why This Matters</h2>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <h3 className="text-[#E2E8F0] font-semibold mb-2">
            Transformers Can't Do This
          </h3>
          <p className="text-sm text-[#8B95A5]">
            Transformer weights are densely interconnected. Concatenating two
            transformer models produces garbage. Any "merging" requires
            expensive fine-tuning, distillation, or careful weight interpolation
            — and even then, the merged model shares all its capacity between
            tasks.
          </p>
        </div>
        <div>
          <h3 className="text-[#00C896] font-semibold mb-2">
            BDH Does It Naturally
          </h3>
          <p className="text-sm text-[#8B95A5]">
            BDH's sparse, modular architecture means neurons operate
            independently. Concatenating two models stacks their neuron spaces
            perfectly.
            {hasFT
              ? " A brief fine-tuning step (~500 iterations) teaches the shared embeddings to route correctly to both neuron banks, restoring near-specialist quality."
              : " The shared embedding layer can be adapted with minimal fine-tuning to route to both banks."}
          </p>
        </div>
      </div>
      {hasFT && (
        <div className="mt-4 p-3 bg-white/[0.03] rounded-lg border border-white/[0.08] text-sm">
          <span className="text-[#E2E8F0] font-medium">The workflow:</span>
          <span className="text-[#CBD5E0]">
            {" "}
            Train specialists independently → concatenate neurons → fine-tune
            routing (~5 min) → polyglot model. This enables{" "}
            <b>modular AI development</b> impossible with transformers.
          </span>
        </div>
      )}
      {!hasFT && (
        <div className="mt-4 p-3 bg-white/[0.03] rounded-lg border border-white/[0.08] text-sm">
          <span className="text-[#E2E8F0] font-medium">Implication:</span>
          <span className="text-[#CBD5E0]">
            {" "}
            Train specialists for specific tasks, merge them freely. This
            enables <b>modular AI development</b> — a paradigm impossible with
            current transformer architectures.
          </span>
        </div>
      )}
    </motion.div>
  );
}


================================================================================
 FILE: pages\FindingsPage.tsx  (1308 lines)
================================================================================

import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { motion, AnimatePresence, useInView } from "framer-motion";
import * as d3 from "d3";
import { Play, Pause, RotateCcw, ChevronDown } from "lucide-react";

/* ================================================================ */
/*  Types                                                            */
/* ================================================================ */

interface HistogramBin {
  bin_start: number;
  bin_end: number;
  count: number;
}

interface SelectivityData {
  histogram: HistogramBin[];
  total_neurons: number;
  total_selective: number;
  mean_selectivity: number;
}

interface SynapseWord {
  word: string;
  byte_start: number;
  byte_end: number;
  is_concept: boolean;
  sigma: Record<string, number>;
  delta_sigma: Record<string, number>;
}

interface TrackingSentence {
  sentence: string;
  n_bytes: number;
  words: SynapseWord[];
}

interface SynapseInfo {
  id: string;
  label: string;
  layer: number;
  head: number;
  i: number;
  j: number;
  selectivity: number;
}

interface SynapseTracking {
  synapses: SynapseInfo[];
  sentences: TrackingSentence[];
}

interface CrossConcept {
  primary: string;
  secondary: string;
  distinctness_per_layer: number[];
}

interface MonoNeuron {
  layer: number;
  head: number;
  neuron: number;
  selectivity: number;
  mean_in: number;
  mean_out: number;
  p_value: number;
  per_word: number[];
}

interface ConceptData {
  concept: string;
  words: unknown[];
  similarity: Record<string, number>;
  shared_neurons: unknown[];
  model_info: unknown;
  monosemantic_neurons: MonoNeuron[];
}

interface PrecomputedData {
  model_info: { n_layers: number; n_heads: number; n_neurons: number };
  best_layer: number;
  concepts: Record<string, ConceptData>;
  cross_concept: CrossConcept[];
  selectivity: SelectivityData;
  synapse_tracking: Record<string, SynapseTracking>;
}

interface EvalResult {
  french_loss: number | null;
  portuguese_loss: number | null;
}

interface MergeData {
  heritage: {
    neurons_per_head_original: number;
    neurons_per_head_merged: number;
    [k: string]: unknown;
  };
  models: Record<
    string,
    { params: number; n_neurons: number; [k: string]: unknown }
  >;
  evaluation: Record<string, EvalResult>;
  heritage_probe: {
    summary: {
      french_input_french_pct: number;
      portuguese_input_portuguese_pct: number;
      routing_quality: number;
      clear_separation: boolean;
      [k: string]: unknown;
    };
  };
  finetune_info: {
    iters: number;
    lr: number;
    pre_loss: number;
    post_loss: number;
    [k: string]: unknown;
  };
}

/* ================================================================ */
/*  Constants & Helpers                                               */
/* ================================================================ */

const C = {
  french: "#3b82f6",
  portuguese: "#10b981",
  merged: "#8b5cf6",
  finetuned: "#f59e0b",
  accent: "#00C896",
  red: "#ef4444",
};

const CARD = "rounded-xl p-6" + " " + "card-interactive";

/* ================================================================ */
/*  Animated Counter                                                  */
/* ================================================================ */

function AnimatedNumber({
  target,
  decimals = 0,
  suffix = "",
  prefix = "",
  duration = 1.2,
}: {
  target: number;
  decimals?: number;
  suffix?: string;
  prefix?: string;
  duration?: number;
}) {
  const [current, setCurrent] = useState(0);
  const ref = useRef<HTMLSpanElement>(null);
  const inView = useInView(ref, { once: true });

  useEffect(() => {
    if (!inView) return;
    const start = performance.now();
    function tick(now: number) {
      const t = Math.min((now - start) / (duration * 1000), 1);
      const ease = 1 - Math.pow(1 - t, 3);
      setCurrent(target * ease);
      if (t < 1) requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }, [inView, target, duration]);

  return (
    <span ref={ref}>
      {prefix}
      {current.toFixed(decimals)}
      {suffix}
    </span>
  );
}

/* ================================================================ */
/*  Hero Stat Card                                                    */
/* ================================================================ */

function HeroCard({
  label,
  value,
  suffix,
  decimals,
}: {
  label: string;
  value: number;
  suffix?: string;
  decimals?: number;
  color?: string;
  icon?: React.ElementType;
  index?: number;
}) {
  return (
    <div className={CARD + " flex flex-col items-center text-center"}>
      <div className="text-3xl font-bold text-[#E2E8F0] mb-1">
        <AnimatedNumber
          target={value}
          decimals={decimals ?? 0}
          suffix={suffix ?? ""}
        />
      </div>
      <div className="text-xs text-[#8B95A5] uppercase tracking-wider">
        {label}
      </div>
    </div>
  );
}

/* ================================================================ */
/*  Loss Comparison Grouped Bar Chart                                 */
/* ================================================================ */

function LossChart({ evaluation }: { evaluation: Record<string, EvalResult> }) {
  const wrapRef = useRef<HTMLDivElement>(null);
  const inView = useInView(wrapRef, { once: true, margin: "-60px" });

  const W = 520,
    H = 300;
  const M = { top: 30, right: 20, bottom: 60, left: 50 };

  const models = ["french", "portuguese", "merged", "finetuned"] as const;
  const langs = ["french_loss", "portuguese_loss"] as const;
  const langLabel: Record<string, string> = {
    french_loss: "French",
    portuguese_loss: "Portuguese",
  };
  const modelLabel: Record<string, string> = {
    french: "FR Specialist",
    portuguese: "PT Specialist",
    merged: "Merged",
    finetuned: "Finetuned",
  };

  const allVals = models.flatMap((m) =>
    langs.map((l) => Number(evaluation[m]?.[l as keyof EvalResult] ?? 0)),
  );
  const yMax = Math.max(...allVals) * 1.15;

  const x0 = d3
    .scaleBand()
    .domain([...models])
    .range([M.left, W - M.right])
    .paddingInner(0.25);
  const x1 = d3
    .scaleBand()
    .domain([...langs])
    .range([0, x0.bandwidth()])
    .padding(0.08);
  const y = d3
    .scaleLinear()
    .domain([0, yMax])
    .range([H - M.bottom, M.top]);

  return (
    <div ref={wrapRef}>
      <svg viewBox={`0 0 ${W} ${H}`} className="w-full">
        {/* Grid */}
        {y.ticks(5).map((t) => (
          <g key={t}>
            <line
              x1={M.left}
              x2={W - M.right}
              y1={y(t)}
              y2={y(t)}
              stroke="#374151"
              strokeWidth={0.5}
            />
            <text
              x={M.left - 6}
              y={y(t) + 4}
              textAnchor="end"
              fill="#9ca3af"
              fontSize={10}
            >
              {t.toFixed(1)}
            </text>
          </g>
        ))}

        {/* Bars */}
        {models.map((m) =>
          langs.map((l) => {
            const val = Number(evaluation[m]?.[l as keyof EvalResult] ?? 0);
            const bx = (x0(m) ?? 0) + (x1(l) ?? 0);
            const bw = x1.bandwidth();
            const bh = y(0) - y(val);
            const clr = l === "french_loss" ? C.french : C.portuguese;
            return (
              <g key={`${m}-${l}`}>
                <motion.rect
                  x={bx}
                  width={bw}
                  rx={3}
                  fill={clr}
                  fillOpacity={0.85}
                  initial={{ y: y(0), height: 0 }}
                  animate={
                    inView ? { y: y(val), height: bh } : { y: y(0), height: 0 }
                  }
                  transition={{ duration: 0.7, delay: 0.12 }}
                />
                <motion.text
                  x={bx + bw / 2}
                  textAnchor="middle"
                  fill="#e5e7eb"
                  fontSize={9}
                  fontWeight={600}
                  initial={{ y: y(0), opacity: 0 }}
                  animate={
                    inView
                      ? { y: y(val) - 5, opacity: 1 }
                      : { y: y(0), opacity: 0 }
                  }
                  transition={{ duration: 0.7, delay: 0.35 }}
                >
                  {val.toFixed(2)}
                </motion.text>
              </g>
            );
          }),
        )}

        {/* X labels */}
        {models.map((m) => (
          <text
            key={m}
            x={(x0(m) ?? 0) + x0.bandwidth() / 2}
            y={H - M.bottom + 18}
            textAnchor="middle"
            fill="#d1d5db"
            fontSize={11}
            fontWeight={500}
          >
            {modelLabel[m]}
          </text>
        ))}

        {/* Legend */}
        {langs.map((l, i) => (
          <g key={l} transform={`translate(${M.left + i * 120}, ${H - 14})`}>
            <rect
              width={12}
              height={12}
              rx={2}
              fill={l === "french_loss" ? C.french : C.portuguese}
              fillOpacity={0.85}
            />
            <text x={18} y={10} fill="#d1d5db" fontSize={11}>
              {langLabel[l]}
            </text>
          </g>
        ))}
      </svg>
    </div>
  );
}

/* ================================================================ */
/*  Fine-tune Before/After                                            */
/* ================================================================ */

function FinetuneMeter({
  preLoss,
  postLoss,
  iters,
}: {
  preLoss: number;
  postLoss: number;
  iters: number;
}) {
  const reduction = ((preLoss - postLoss) / preLoss) * 100;

  return (
    <div className="space-y-5">
      <div className="text-center">
        <div className="text-3xl font-bold text-[#E2E8F0]">
          <AnimatedNumber target={reduction} decimals={1} suffix="%" />
        </div>
        <p className="text-[#4A5568] text-sm mt-1">Loss Reduction</p>
      </div>

      {[
        { label: "Before Fine-tuning", val: preLoss, color: "#6b7280" },
        {
          label: `After ${iters} iterations`,
          val: postLoss,
          color: C.french,
        },
      ].map((row) => (
        <div key={row.label}>
          <div className="flex justify-between text-xs text-[#8B95A5] mb-1">
            <span>{row.label}</span>
            <span className="text-white font-mono">{row.val.toFixed(4)}</span>
          </div>
          <div className="h-4 rounded bg-white/5 overflow-hidden">
            <div
              className="h-full rounded"
              style={{
                background: row.color,
                width: `${(row.val / 4) * 100}%`,
              }}
            />
          </div>
        </div>
      ))}
    </div>
  );
}

/* ================================================================ */
/*  Selectivity Histogram                                             */
/* ================================================================ */

function SelectivityHistogram({ histogram }: { histogram: HistogramBin[] }) {
  const W = 480,
    H = 240;
  const M = { top: 16, right: 12, bottom: 40, left: 44 };

  const x = d3
    .scaleLinear()
    .domain([0, 1])
    .range([M.left, W - M.right]);
  const yMax = d3.max(histogram, (d) => d.count) ?? 1;
  const y = d3
    .scaleLinear()
    .domain([0, yMax * 1.1])
    .range([H - M.bottom, M.top]);

  return (
    <svg viewBox={`0 0 ${W} ${H}`} className="w-full">
      {y.ticks(4).map((t) => (
        <g key={t}>
          <line
            x1={M.left}
            x2={W - M.right}
            y1={y(t)}
            y2={y(t)}
            stroke="#374151"
            strokeWidth={0.5}
          />
          <text
            x={M.left - 6}
            y={y(t) + 4}
            textAnchor="end"
            fill="#9ca3af"
            fontSize={9}
          >
            {t >= 1000 ? `${(t / 1000).toFixed(1)}k` : t}
          </text>
        </g>
      ))}

      {histogram.map((bin, i) => {
        const bx = x(bin.bin_start);
        const bw = x(bin.bin_end) - x(bin.bin_start) - 1;
        const bh = y(0) - y(bin.count);
        return (
          <motion.rect
            key={i}
            x={bx}
            width={Math.max(bw, 1)}
            rx={2}
            fill={C.accent}
            fillOpacity={0.75}
            initial={{ y: y(0), height: 0 }}
            whileInView={{ y: y(bin.count), height: bh }}
            viewport={{ once: true }}
            transition={{ duration: 0.5, delay: i * 0.03 }}
          />
        );
      })}

      {[0, 0.25, 0.5, 0.75, 1.0].map((v) => (
        <text
          key={v}
          x={x(v)}
          y={H - M.bottom + 16}
          textAnchor="middle"
          fill="#9ca3af"
          fontSize={10}
        >
          {v.toFixed(2)}
        </text>
      ))}
      <text
        x={(M.left + W - M.right) / 2}
        y={H - 4}
        textAnchor="middle"
        fill="#6b7280"
        fontSize={10}
      >
        Selectivity Score
      </text>
    </svg>
  );
}

/* ================================================================ */
/*  Radial Gauge                                                      */
/* ================================================================ */

function RadialGauge({
  value,
  max,
  label,
  color,
  size = 170,
}: {
  value: number;
  max: number;
  label: string;
  color: string;
  size?: number;
}) {
  const r = size / 2 - 14;
  const circ = 2 * Math.PI * r;
  const pct = value / max;

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke="#1f2937"
          strokeWidth={10}
        />
        <motion.circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke={color}
          strokeWidth={10}
          strokeLinecap="round"
          strokeDasharray={circ}
          initial={{ strokeDashoffset: circ }}
          whileInView={{ strokeDashoffset: circ * (1 - pct) }}
          viewport={{ once: true }}
          transition={{ duration: 1.2, ease: "easeOut" }}
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
        <text
          x={size / 2}
          y={size / 2 - 6}
          textAnchor="middle"
          fill="white"
          fontSize={size / 5.5}
          fontWeight={700}
        >
          {(pct * 100).toFixed(1)}%
        </text>
        <text
          x={size / 2}
          y={size / 2 + 14}
          textAnchor="middle"
          fill="#9ca3af"
          fontSize={size / 13}
        >
          {value.toLocaleString()} / {max.toLocaleString()}
        </text>
      </svg>
      <span className="text-[#8B95A5] text-xs mt-1">{label}</span>
    </div>
  );
}

/* ================================================================ */
/*  Heritage Routing Donut                                            */
/* ================================================================ */

function RoutingDonut({
  frPct,
  ptPct,
  quality,
}: {
  frPct: number;
  ptPct: number;
  quality: number;
}) {
  const size = 180,
    r = 68;
  const circ = 2 * Math.PI * r;
  const frArc = circ * (frPct / 100);
  const ptArc = circ * (ptPct / 100);

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <motion.circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke={C.french}
          strokeWidth={14}
          strokeDasharray={`${frArc} ${circ - frArc}`}
          initial={{ strokeDashoffset: circ }}
          whileInView={{ strokeDashoffset: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 1 }}
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
        <motion.circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke={C.portuguese}
          strokeWidth={14}
          strokeDasharray={`${ptArc} ${circ - ptArc}`}
          strokeDashoffset={-frArc}
          initial={{ opacity: 0 }}
          whileInView={{ opacity: 1 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.5 }}
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />
        <text
          x={size / 2}
          y={size / 2 - 4}
          textAnchor="middle"
          fill="white"
          fontSize={20}
          fontWeight={700}
        >
          {quality.toFixed(1)}%
        </text>
        <text
          x={size / 2}
          y={size / 2 + 14}
          textAnchor="middle"
          fill="#9ca3af"
          fontSize={10}
        >
          routing quality
        </text>
      </svg>
      <div className="flex gap-5 mt-2 text-xs text-[#CBD5E0]">
        <span className="flex items-center gap-1.5">
          <span
            className="w-2.5 h-2.5 rounded-full"
            style={{ background: C.french }}
          />
          FR {frPct.toFixed(1)}%
        </span>
        <span className="flex items-center gap-1.5">
          <span
            className="w-2.5 h-2.5 rounded-full"
            style={{ background: C.portuguese }}
          />
          PT {ptPct.toFixed(1)}%
        </span>
      </div>
    </div>
  );
}

/* ================================================================ */
/*  Sigma Curve Mini-Replay                                           */
/* ================================================================ */

function SigmaReplay({
  tracking,
}: {
  tracking: SynapseTracking;
  category?: string;
}) {
  const [sentIdx, setSentIdx] = useState(0);
  const [step, setStep] = useState(0);
  const [playing, setPlaying] = useState(false);
  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);

  const sent = tracking.sentences[sentIdx];
  const words = sent?.words ?? [];
  const mainSynId = tracking.synapses[0]?.id ?? "";

  const cumSigma = useMemo(() => {
    const res: number[] = [];
    let acc = 0;
    for (const w of words) {
      acc += w.delta_sigma[mainSynId] ?? 0;
      res.push(acc);
    }
    return res;
  }, [words, mainSynId]);

  const maxSigma = Math.max(...cumSigma, 1);

  useEffect(() => {
    if (playing) {
      timerRef.current = setInterval(() => {
        setStep((s) => {
          if (s >= words.length - 1) {
            setPlaying(false);
            return s;
          }
          return s + 1;
        });
      }, 550);
    }
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [playing, words.length]);

  const restart = useCallback(() => {
    setStep(0);
    setPlaying(true);
  }, []);

  const W = 440,
    H = 160;
  const M = { top: 12, right: 12, bottom: 30, left: 40 };
  const xS = d3
    .scaleLinear()
    .domain([0, Math.max(words.length - 1, 1)])
    .range([M.left, W - M.right]);
  const yS = d3
    .scaleLinear()
    .domain([0, maxSigma * 1.1])
    .range([H - M.bottom, M.top]);

  const visibleData = cumSigma.slice(0, step + 1);
  const pathD = d3
    .line<number>()
    .x((_, i) => xS(i))
    .y((d) => yS(d))
    .curve(d3.curveMonotoneX)(visibleData);

  return (
    <div className="space-y-3">
      {/* Controls */}
      <div className="flex items-center gap-2">
        <div className="relative flex-1">
          <select
            value={sentIdx}
            onChange={(e) => {
              setSentIdx(Number(e.target.value));
              setStep(0);
              setPlaying(false);
            }}
            className="w-full bg-white/5 border border-white/10 rounded-lg px-3 py-1.5 text-sm text-[#E2E8F0] appearance-none pr-8"
          >
            {tracking.sentences.map((s, i) => (
              <option key={i} value={i}>
                {s.sentence}
              </option>
            ))}
          </select>
          <ChevronDown
            size={14}
            className="absolute right-2 top-1/2 -translate-y-1/2 text-[#4A5568] pointer-events-none"
          />
        </div>
        <button
          onClick={() => setPlaying((p) => !p)}
          className="p-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-[#CBD5E0]"
        >
          {playing ? <Pause size={14} /> : <Play size={14} />}
        </button>
        <button
          onClick={restart}
          className="p-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-[#CBD5E0]"
        >
          <RotateCcw size={14} />
        </button>
      </div>

      {/* Chart */}
      <svg viewBox={`0 0 ${W} ${H}`} className="w-full">
        {yS.ticks(3).map((t) => (
          <line
            key={t}
            x1={M.left}
            x2={W - M.right}
            y1={yS(t)}
            y2={yS(t)}
            stroke="#374151"
            strokeWidth={0.5}
          />
        ))}
        {pathD && (
          <motion.path
            d={pathD}
            fill="none"
            stroke={C.accent}
            strokeWidth={2.5}
            strokeLinecap="round"
            initial={{ pathLength: 0 }}
            animate={{ pathLength: 1 }}
            transition={{ duration: 0.3 }}
          />
        )}
        {visibleData.length > 0 && (
          <motion.circle
            cx={xS(step)}
            cy={yS(visibleData[step] ?? 0)}
            r={5}
            fill={C.accent}
            stroke="white"
            strokeWidth={2}
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ type: "spring", stiffness: 300 }}
          />
        )}
        {words.map((w, i) => (
          <text
            key={i}
            x={xS(i)}
            y={H - M.bottom + 16}
            textAnchor="middle"
            fill={i === step ? "white" : w.is_concept ? C.finetuned : "#6b7280"}
            fontSize={9}
            fontWeight={i === step ? 700 : 400}
          >
            {w.word.length > 8 ? w.word.slice(0, 7) + "\u2026" : w.word}
          </text>
        ))}
      </svg>

      {/* Value display */}
      <div className="text-center">
        <AnimatePresence mode="wait">
          <motion.span
            key={step}
            initial={{ opacity: 0, y: 6 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -6 }}
            className="inline-block px-3 py-1 rounded-full bg-white/5 text-sm"
          >
            <span className="text-[#8B95A5]">&sigma; =</span>{" "}
            <span className="text-white font-mono font-bold">
              {cumSigma[step]?.toFixed(2)}
            </span>
            <span className="text-[#4A5568] ml-2">
              at &ldquo;{words[step]?.word}&rdquo;
            </span>
          </motion.span>
        </AnimatePresence>
      </div>
    </div>
  );
}

/* ================================================================ */
/*  Cross-Concept Distinctness                                        */
/* ================================================================ */

function DistinctnessChart({
  crossConcept,
  nLayers,
}: {
  crossConcept: CrossConcept[];
  nLayers: number;
}) {
  const nLegend = crossConcept.length;
  const legendH = nLegend * 16 + 8;
  const W = 480,
    H = 200 + legendH;
  const M = { top: 12, right: 20, bottom: 40 + legendH, left: 44 };
  const layers = Array.from({ length: nLayers }, (_, i) => i);

  const xS = d3
    .scaleLinear()
    .domain([0, nLayers - 1])
    .range([M.left, W - M.right]);
  const allVals = crossConcept.flatMap((c) => c.distinctness_per_layer);
  const yMax = Math.max(...allVals, 0.5) * 1.15;
  const yS = d3
    .scaleLinear()
    .domain([0, yMax])
    .range([H - M.bottom, M.top]);

  const palette = [
    C.french,
    C.portuguese,
    C.merged,
    C.finetuned,
    C.accent,
    C.red,
  ];

  return (
    <svg viewBox={`0 0 ${W} ${H}`} className="w-full">
      {yS.ticks(4).map((t) => (
        <g key={t}>
          <line
            x1={M.left}
            x2={W - M.right}
            y1={yS(t)}
            y2={yS(t)}
            stroke="#374151"
            strokeWidth={0.5}
          />
          <text
            x={M.left - 6}
            y={yS(t) + 4}
            textAnchor="end"
            fill="#9ca3af"
            fontSize={9}
          >
            {t.toFixed(2)}
          </text>
        </g>
      ))}

      {crossConcept.map((cc, ci) => {
        const p =
          d3
            .line<number>()
            .x((_, i) => xS(i))
            .y((d) => yS(d))
            .curve(d3.curveMonotoneX)(cc.distinctness_per_layer) ?? "";
        return (
          <motion.path
            key={ci}
            d={p}
            fill="none"
            stroke={palette[ci % palette.length]}
            strokeWidth={2}
            strokeLinecap="round"
            initial={{ pathLength: 0, opacity: 0 }}
            whileInView={{ pathLength: 1, opacity: 1 }}
            viewport={{ once: true }}
            transition={{ duration: 1, delay: ci * 0.15 }}
          />
        );
      })}

      {layers.map((l) => (
        <text
          key={l}
          x={xS(l)}
          y={H - M.bottom + 18}
          textAnchor="middle"
          fill="#9ca3af"
          fontSize={10}
        >
          L{l}
        </text>
      ))}
      <text
        x={(M.left + W - M.right) / 2}
        y={H - 4}
        textAnchor="middle"
        fill="#6b7280"
        fontSize={10}
      >
        Layer
      </text>

      {crossConcept.map((cc, ci) => (
        <g
          key={`lg${ci}`}
          transform={`translate(${M.left}, ${H - legendH + 8 + ci * 16})`}
        >
          <line
            x1={0}
            x2={14}
            y1={0}
            y2={0}
            stroke={palette[ci % palette.length]}
            strokeWidth={2}
          />
          <text x={18} y={4} fill="#d1d5db" fontSize={9}>
            {cc.primary} vs {cc.secondary}
          </text>
        </g>
      ))}
    </svg>
  );
}

/* ================================================================ */
/*  Neuron Heatmap                                                    */
/* ================================================================ */

function NeuronHeatmap({
  concepts,
}: {
  concepts: Record<string, ConceptData>;
}) {
  return (
    <div className="space-y-4">
      {Object.entries(concepts).map(([cat, data]) => {
        const neurons = data.monosemantic_neurons.slice(0, 12);
        return (
          <div key={cat}>
            <div className="text-xs text-[#8B95A5] uppercase tracking-wider mb-1.5">
              {data.concept}
            </div>
            <div className="flex gap-1 flex-wrap">
              {neurons.map((n, i) => (
                <div key={i} className="relative group cursor-default">
                  <div
                    className="w-8 h-8 rounded flex items-center justify-center text-[8px] font-mono text-[#E2E8F0]/90"
                    style={{ background: d3.interpolateViridis(n.selectivity) }}
                  >
                    {n.selectivity.toFixed(1)}
                  </div>
                  <div className="absolute bottom-full mb-1 left-1/2 -translate-x-1/2 hidden group-hover:block bg-[#0B1216] border border-white/10 rounded px-2 py-1 text-[10px] whitespace-nowrap z-20 pointer-events-none">
                    L{n.layer} H{n.head} N{n.neuron}
                    <br />
                    sel: {n.selectivity.toFixed(3)} &bull; p=
                    {n.p_value.toFixed(4)}
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      })}
      <div className="flex items-center gap-2 mt-2">
        <span className="text-[10px] text-[#4A5568]">0.0</span>
        <div
          className="h-2 flex-1 rounded"
          style={{
            background: `linear-gradient(to right, ${d3.interpolateViridis(0)}, ${d3.interpolateViridis(0.5)}, ${d3.interpolateViridis(1)})`,
          }}
        />
        <span className="text-[10px] text-[#4A5568]">1.0</span>
        <span className="text-[10px] text-[#4A5568] ml-1">selectivity</span>
      </div>
    </div>
  );
}

/* ================================================================ */
/*  Section Header                                                    */
/* ================================================================ */

function SectionHead({
  title,
  sub,
}: {
  icon?: React.ElementType;
  title: string;
  sub: string;
}) {
  return (
    <div className="mb-6">
      <h2 className="text-lg font-semibold text-[#E2E8F0] mb-1">{title}</h2>
      <p className="text-sm text-[#4A5568]">{sub}</p>
    </div>
  );
}

/* ================================================================ */
/*  Main Page                                                         */
/* ================================================================ */

export function FindingsPage() {
  const [monoData, setMonoData] = useState<PrecomputedData | null>(null);
  const [mergeData, setMergeData] = useState<MergeData | null>(null);
  const [loading, setLoading] = useState(true);
  const [activeTrackCat, setActiveTrackCat] = useState("");

  useEffect(() => {
    Promise.all([
      fetch("/monosemanticity/precomputed.json").then((r) => r.json()),
      fetch("/merge/merge_data.json").then((r) => r.json()),
    ])
      .then(([mono, merge]) => {
        setMonoData(mono);
        setMergeData(merge);
      })
      .finally(() => setLoading(false));
  }, []);

  // Set default tracking category
  useEffect(() => {
    if (monoData && !activeTrackCat) {
      const cats = Object.keys(monoData.synapse_tracking);
      if (cats.length) setActiveTrackCat(cats[0]);
    }
  }, [monoData, activeTrackCat]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-[60vh] text-[#4A5568] text-sm">
        Loading…
      </div>
    );
  }

  if (!monoData || !mergeData) {
    return (
      <div className="text-center py-20 text-[#8B95A5]">
        Failed to load data.
      </div>
    );
  }

  const sel = monoData.selectivity;
  const ft = mergeData.finetune_info;
  const probe = mergeData.heritage_probe.summary;
  const nCats = Object.keys(monoData.concepts).length;
  const nLayers = monoData.model_info.n_layers;
  const trackingCats = Object.keys(monoData.synapse_tracking);

  return (
    <div
      className="max-w-6xl mx-auto space-y-16 pb-20"
      style={{ background: "#070D12", minHeight: "100vh" }}
    >
      {/* ── Title ── */}
      <div className="pt-4">
        <h1 className="text-2xl font-bold text-[#E2E8F0] mb-1">Findings</h1>
        <p className="text-[#4A5568] text-sm">
          Monosemanticity, heritage routing, and merge viability — measured on
          real checkpoints.
        </p>
      </div>

      {/* ── Hero Stats ── */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <HeroCard label="Neurons Analyzed" value={sel.total_neurons} />
        <HeroCard label="Selective Neurons" value={sel.total_selective} />
        <HeroCard
          label="Mean Selectivity"
          value={sel.mean_selectivity}
          decimals={4}
        />
        <HeroCard label="Concept Categories" value={nCats} />
      </div>

      {/* ── Loss Landscape ── */}
      <section>
        <SectionHead
          title="Loss Landscape"
          sub="Cross-lingual loss comparison across model variants. Lower is better."
        />
        <div className="grid md:grid-cols-5 gap-6">
          <div className={`${CARD} md:col-span-3`}>
            <LossChart evaluation={mergeData.evaluation} />
          </div>
          <div className={`${CARD} md:col-span-2 flex flex-col justify-center`}>
            <FinetuneMeter
              preLoss={ft.pre_loss}
              postLoss={ft.post_loss}
              iters={ft.iters}
            />
          </div>
        </div>
      </section>

      {/* ── Selectivity ── */}
      <section>
        <SectionHead
          title="Neuron Selectivity"
          sub="Distribution of selectivity scores. Selective neurons fire strongly for specific concepts."
        />
        <div className="grid md:grid-cols-5 gap-6">
          <div className={`${CARD} md:col-span-3`}>
            <SelectivityHistogram histogram={sel.histogram} />
          </div>
          <div
            className={`${CARD} md:col-span-2 flex items-center justify-center`}
          >
            <RadialGauge
              value={sel.total_selective}
              max={sel.total_neurons}
              label="Selective / Total Neurons"
              color={C.accent}
            />
          </div>
        </div>
      </section>

      {/* ── Heritage Routing ── */}
      <section>
        <SectionHead
          title="Heritage Routing"
          sub="How well the merged model routes inputs to their parent-language neurons."
        />
        <div className="grid md:grid-cols-3 gap-6">
          <div className={`${CARD} flex items-center justify-center`}>
            <RoutingDonut
              frPct={probe.french_input_french_pct}
              ptPct={probe.portuguese_input_portuguese_pct}
              quality={probe.routing_quality}
            />
          </div>
          <div className={`${CARD} md:col-span-2`}>
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                {[
                  {
                    label: "FR \u2192 FR neurons",
                    value: probe.french_input_french_pct,
                    color: C.french,
                  },
                  {
                    label: "PT \u2192 PT neurons",
                    value: probe.portuguese_input_portuguese_pct,
                    color: C.portuguese,
                  },
                ].map((item) => (
                  <div key={item.label}>
                    <div className="flex justify-between text-xs text-[#8B95A5] mb-1">
                      <span>{item.label}</span>
                      <span className="text-white font-mono">
                        {item.value.toFixed(1)}%
                      </span>
                    </div>
                    <div className="h-3 rounded-full bg-white/5 overflow-hidden">
                      <motion.div
                        className="h-full rounded-full"
                        style={{ background: item.color }}
                        initial={{ width: 0 }}
                        whileInView={{ width: `${item.value}%` }}
                        viewport={{ once: true }}
                        transition={{ duration: 0.8 }}
                      />
                    </div>
                  </div>
                ))}
              </div>
              <div className="text-center pt-2">
                <span
                  className={`inline-flex items-center gap-1.5 px-3 py-1 rounded text-xs font-medium ${
                    probe.clear_separation
                      ? "bg-white/5 text-[#CBD5E0] border border-white/10"
                      : "bg-white/5 text-[#8B95A5] border border-white/10"
                  }`}
                >
                  {probe.clear_separation
                    ? "Clear Separation Detected"
                    : "No Clear Separation \u2014 Needs More Training"}
                </span>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* ── Sigma Replay ── */}
      <section>
        <SectionHead
          title="Synapse \u03C3-Curve Replay"
          sub="Cumulative sigma accumulated word-by-word as the model reads a sentence."
        />
        <div className={CARD}>
          <div className="flex gap-2 mb-4 flex-wrap">
            {trackingCats.map((cat) => (
              <button
                key={cat}
                onClick={() => setActiveTrackCat(cat)}
                className={`px-3 py-1 rounded-lg text-xs font-medium transition-colors ${
                  activeTrackCat === cat
                    ? "bg-white/10 text-[#E2E8F0] border border-white/\[0.12\]"
                    : "bg-transparent text-[#8B95A5] border border-white/10 hover:text-[#E2E8F0]"
                }`}
              >
                {cat.charAt(0).toUpperCase() + cat.slice(1)}
              </button>
            ))}
          </div>
          {activeTrackCat && monoData.synapse_tracking[activeTrackCat] && (
            <SigmaReplay
              tracking={monoData.synapse_tracking[activeTrackCat]}
              category={activeTrackCat}
            />
          )}
        </div>
      </section>

      {/* ── Cross-Concept Distinctness ── */}
      <section>
        <SectionHead
          title="Cross-Concept Distinctness"
          sub="Per-layer distinctness between concept pairs. Higher values = stronger separation."
        />
        <div className={CARD}>
          <DistinctnessChart
            crossConcept={monoData.cross_concept}
            nLayers={nLayers}
          />
        </div>
      </section>

      {/* ── Neuron Heatmap ── */}
      <section>
        <SectionHead
          title="Monosemantic Neuron Map"
          sub="Top selective neurons per concept. Hover for layer/head/neuron details."
        />
        <div className={CARD}>
          <NeuronHeatmap concepts={monoData.concepts} />
        </div>
      </section>
    </div>
  );
}


================================================================================
 FILE: pages\LearnBDHPage.tsx  (1346 lines)
================================================================================

import React, { useState, useMemo, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ChevronLeft, ChevronRight } from "lucide-react";

/* ═══════════════════════════════════════════════════════════════
   DETERMINISTIC PSEUDO-RANDOM  (stable across renders)
   ═══════════════════════════════════════════════════════════════ */
function seededRandom(seed: number) {
  let s = seed;
  return () => {
    s = (s * 16807) % 2147483647;
    return (s - 1) / 2147483646;
  };
}

/* ═══════════════════════════════════════════════════════════════
   STEP DATA — BDH Architecture Building Blocks
   ═══════════════════════════════════════════════════════════════ */
interface StepData {
  id: number;
  title: string;
  subtitle: string;
  difficulty: "Easy" | "Medium" | "Hard";
  description: string[];
  theory: { heading: string; content: string }[];
  keyInsight: string;
  code: string;
}

const STEPS: StepData[] = [
  {
    id: 1,
    title: "Byte Embedding",
    subtitle: "Raw bytes to continuous vectors",
    difficulty: "Easy",
    description: [
      "BDH reads raw UTF-8 bytes — no tokenizer, no subword encoding. Each byte (0–255) maps to a learnable 256-dimensional vector through an embedding lookup table.",
      "The input tensor transforms from (B, T) → (B, T, D), then gets unsqueezed to (B, 1, T, D) so every attention head receives the same initial representation.",
      'The character "é" becomes two bytes [195, 169], giving the model fine-grained access to every character in every language without any tokenizer bias.',
    ],
    theory: [
      {
        heading: "Why bytes over tokens?",
        content:
          "Tokenizers like BPE create a fixed vocabulary from training data, biasing the model toward languages and patterns seen during tokenizer training. Byte-level input is universal — every UTF-8 string, every language, every symbol is already supported.",
      },
      {
        heading: "Embedding dimensions",
        content:
          "With vocab_size = 256 and n_embd = 256, the embedding table is a 256 × 256 matrix. Each of the 256 possible byte values gets its own unique 256-dimensional vector, learned during training.",
      },
      {
        heading: "Multi-head broadcast",
        content:
          "After embedding, the tensor is unsqueezed from (B,T,D) to (B,1,T,D). The size-1 dimension broadcasts across all attention heads, so every head starts from the same embedding before applying its own encoder.",
      },
    ],
    keyInsight:
      "Byte-level embedding means BDH can process any language, any script, any encoding — without needing a language-specific tokenizer.",
    code: `self.embed = nn.Embedding(256, D)   # D = 256

# In forward():
x = self.embed(idx)       # (B, T) → (B, T, D)
x = x.unsqueeze(1)        # → (B, 1, T, D)
x = self.ln(x)            # Initial LayerNorm`,
  },
  {
    id: 2,
    title: "Sparse Encoding",
    subtitle: "D→N expansion + ReLU sparsification",
    difficulty: "Medium",
    description: [
      "Each attention head owns an encoder matrix that projects from D = 256 to N = 8,192 neuron dimensions — a 32× expansion into an overcomplete representation.",
      "After expansion, ReLU zeros out all negative activations. This typically leaves only ~5% of neurons active (sparsity ≈ 95%), creating a sparse distributed code where each neuron can specialize.",
      "Some neurons learn to fire for French text, others for numbers, others for punctuation. The sparsity enforces clean separation between concepts.",
    ],
    theory: [
      {
        heading: "Overcomplete representations",
        content:
          "With N >> D, there are far more neurons than input dimensions. This overcomplete basis lets the model represent inputs as combinations of many specific features rather than few entangled ones.",
      },
      {
        heading: "ReLU as a sparsifier",
        content:
          "ReLU(x) = max(0, x) sets all negative values to zero. In practice, roughly 95% of neurons end up at zero for any given input. The model learns which neurons should fire for which patterns through backpropagation.",
      },
      {
        heading: "Sparsity enables interpretability",
        content:
          'Dense representations entangle features — one neuron might encode "French + noun + capitalized." Sparse overcomplete representations let each neuron encode a single concept, making the model naturally interpretable.',
      },
    ],
    keyInsight:
      "The D→N expansion with ReLU is where interpretability begins — each of the 8,192 neurons per head can specialize for one concept.",
    code: `# Encoder matrix per head: (nh, D, N) = (4, 256, 8192)
enc = self.encoders[layer_idx]

# Project to neuron space
x_latent = x @ enc          # (B, nh, T, N)

# Sparsify — ~95% of activations become zero
x_sparse = F.relu(x_latent) # (B, nh, T, N)`,
  },
  {
    id: 3,
    title: "Rotary Position Embedding",
    subtitle: "Position-dependent rotation in neuron space",
    difficulty: "Medium",
    description: [
      "RoPE encodes positional information by rotating pairs of dimensions in the sparse representation. Each dimension pair rotates at a different frequency, creating a unique position signature for every token.",
      "The frequency for dimension i is: freq_i = 1 / (θ^(i/N)) where θ = 2¹⁶. Lower dimensions oscillate quickly (capturing local patterns), higher dimensions oscillate slowly (capturing global structure).",
      "When computing attention, the relative position between two tokens is captured entirely by the angle between their rotated vectors — no additional position parameters needed.",
    ],
    theory: [
      {
        heading: "Rotation mechanics",
        content:
          "For a token at position t, each pair of dimensions (2i, 2i+1) is rotated by angle t × freq_i: v·cos(θ) + v_rot·sin(θ). This preserves vector magnitude while encoding position.",
      },
      {
        heading: "Relative position from rotation",
        content:
          "When computing Q·Kᵀ, the angle between rotated Q at position p and rotated K at position q depends only on (p − q). This gives position-aware attention without absolute position embeddings.",
      },
      {
        heading: "Frequency spectrum",
        content:
          "With N = 8,192 dimensions and θ = 65,536, the frequencies span many octaves. High-frequency components capture local character-level proximity; low-frequency components capture long-range document structure.",
      },
    ],
    keyInsight:
      "RoPE gives BDH position awareness through rotation — no additional parameters. Relative position is encoded in the angle between any two token vectors.",
    code: `def get_freqs(n, theta, dtype):
    return 1.0 / (theta ** (arange(0, n) / n)) / (2 * pi)

# Position-dependent phases
r_phases = arange(0, T).view(1,1,-1,1) * self.freqs

# Apply rotation
QR = self.rope(r_phases, Q)   # rotated queries
KR = QR                        # self-attention`,
  },
  {
    id: 4,
    title: "Linear Attention",
    subtitle: "Causal co-activation in sparse space",
    difficulty: "Hard",
    description: [
      "BDH computes attention directly in the sparse neuron space. Rotated queries and keys produce attention scores: scores = QR · KRᵀ, then a causal mask ensures each token only looks at the past.",
      "Unlike standard transformers, there is no softmax. The raw co-activation scores are directly interpretable — they represent how strongly two sparse activation patterns overlap.",
      'Values V stay in embedding space (D = 256), so the attention output captures "what context contributes" in the original representation.',
    ],
    theory: [
      {
        heading: "No softmax — raw co-activation",
        content:
          "Standard transformers normalize attention into a probability distribution with softmax. BDH skips this: scores = (QR @ KR.T).tril(). The raw scores are Hebbian co-activations — when two neurons fire together, the score is high.",
      },
      {
        heading: "Causal masking",
        content:
          ".tril(diagonal=−1) masks the upper triangle to zero, preventing future-token leakage. Position t can only attend to positions 0 through t−1, making BDH autoregressive for generation.",
      },
      {
        heading: "Effective linear complexity",
        content:
          "Because the sparse representations have ~95% zeros, the effective attention computation is far cheaper than dense O(T²). Only the ~5% non-zero neurons contribute meaningfully to dot products.",
      },
    ],
    keyInsight:
      'The attention matrix IS a Hebbian co-activation map — "neurons that fire together, wire together" implemented as linear algebra, with no softmax to obscure the raw signals.',
    code: `# In Attention.forward():
scores = (QR @ KR.mT)        # (B, nh, T, T)
scores = scores.tril(-1)     # causal mask

# V is in embedding space, not neuron space
output = scores @ V           # (B, nh, T, D)`,
  },
  {
    id: 5,
    title: "Value Encoding",
    subtitle: "Second sparse path for attended context",
    difficulty: "Medium",
    description: [
      "The attention output yKV lives in embedding space (D = 256). A second encoder matrix projects it back to sparse neuron space: D → N = 8,192 per head.",
      'A second ReLU creates another sparse representation. This y_sparse captures "which neurons are relevant based on what attention gathered from context."',
      'Now we have two independently sparse vectors: x_sparse ("what features this token has") and y_sparse ("what features the context provides").',
    ],
    theory: [
      {
        heading: "Why a second encoding?",
        content:
          "x_sparse encodes the token itself. y_sparse encodes its context. These carry fundamentally different information and must be independently sparsified so the gating step can combine them meaningfully.",
      },
      {
        heading: "Separate encoder matrices",
        content:
          "enc_v is a distinct parameter from enc. This allows the value path to learn different sparse features than the input path. The two encoders develop complementary, specialized representations.",
      },
      {
        heading: "Dual sparsity",
        content:
          "After value encoding, we have two independent sparse vectors. A neuron active in x_sparse may be silent in y_sparse, and vice versa. Their intersection (next step) creates extremely selective activation.",
      },
    ],
    keyInsight:
      'The second encoder creates a parallel sparse representation from context: x_sparse says "what I am," y_sparse says "what my neighbors say I should produce."',
    code: `# After attention + LayerNorm
yKV = self.ln(yKV)            # (B, nh, T, D)

# Second encoding: D → N
y_latent = yKV @ enc_v         # (B, nh, T, N)
y_sparse = F.relu(y_latent)    # second sparsification`,
  },
  {
    id: 6,
    title: "Sparse Gating",
    subtitle: "Double sparsity through element-wise multiplication",
    difficulty: "Easy",
    description: [
      "The core operation: xy = x_sparse × y_sparse. Element-wise multiplication means a neuron must be active in BOTH the input encoding AND the value encoding to survive.",
      "If x_sparse[i] = 0.8 but y_sparse[i] = 0, then xy[i] = 0 — the neuron is silenced. This creates dramatically higher sparsity than either path alone.",
      "In V2, a persistent ρ buffer modulates the gate: xy × (1 + ρ). The ρ is an exponential moving average of historical gate activity — frequently co-active neurons get amplified over time.",
    ],
    theory: [
      {
        heading: "Gating as feature selection",
        content:
          "Multiplication acts as a soft AND gate: output is non-zero only where both inputs agree. This ensures only contextually-appropriate features pass to the decoder. After gating, ~99% of neurons are zero.",
      },
      {
        heading: "ρ buffer — Hebbian memory (V2)",
        content:
          "ρ accumulates which neurons have historically been co-active: ρ ← decay · ρ + (1−decay) · mean(gate). The (1+ρ) modulation amplifies frequently-used pathways — a form of synaptic long-term potentiation.",
      },
      {
        heading: "Interpretability from gating",
        content:
          "After gating, surviving neurons are doubly validated: the token activates them AND the context confirms them. This creates extremely clean, monosemantic activations where each active neuron has a clear, singular meaning.",
      },
    ],
    keyInsight:
      'Gating is BDH\'s key mechanism — requiring agreement between "what I am" and "what context says" lets only the most relevant neurons survive.',
    code: `# Element-wise gating
xy_sparse = x_sparse * y_sparse   # (B, nh, T, N)

# V2: ρ modulation (Hebbian memory)
if per_layer_encoders:
    rho = self.rho[layer_idx]      # (nh, N)
    xy_sparse *= (1.0 + rho)

xy_sparse = self.drop(xy_sparse)`,
  },
  {
    id: 7,
    title: "Decode + Residual",
    subtitle: "N→D compression and skip connection",
    difficulty: "Medium",
    description: [
      "The gated sparse representation is reshaped by concatenating all heads: (B, nh, T, N) → (B, 1, T, nh×N). Then a decoder matrix projects from nh × N = 32,768 back down to D = 256.",
      "LayerNorm normalizes the decoded output, and a residual connection adds it to the original input: x = LN(x + y). The layer only needs to learn what to ADD to the representation.",
      "This output becomes the input to the next layer, and the encode → attend → gate → decode cycle repeats.",
    ],
    theory: [
      {
        heading: "Head concatenation",
        content:
          "Each of the 4 heads independently processes N = 8,192 neurons. Reshaping from (nh, T, N) to (T, nh×N) concatenates all heads' sparse outputs into one 32,768-dimensional vector.",
      },
      {
        heading: "Decoder projection",
        content:
          "The decoder matrix (nh×N, D) = (32768, 256) compresses the wide sparse code back to embedding space. The model learns which combinations of sparse activations should produce which embedding updates.",
      },
      {
        heading: "Residual learning",
        content:
          "x = LN(x + y) means the layer learns a residual: what to add. Without the skip connection, gradients vanish in deep networks. With it, information flows freely and each layer can focus on refinement.",
      },
    ],
    keyInsight:
      "The decoder reverses the encoder's expansion, compressing 32,768 sparse dimensions back to 256 dense dimensions. The residual connection preserves the original signal.",
    code: `# Reshape: (B, nh, T, N) → (B, 1, T, nh*N)
concat = xy_sparse.transpose(1, 2)
           .reshape(B, 1, T, N * nh)

# Decode: nh*N → D
yMLP = concat @ dec    # (B, 1, T, D)
y = self.ln(yMLP)

# Residual connection
x = self.ln(x + y)`,
  },
  {
    id: 8,
    title: "Full BDH Layer",
    subtitle: "Complete processing pipeline",
    difficulty: "Hard",
    description: [
      "A complete BDH layer chains all previous steps: Encode → Sparsify → Attend → Value-Encode → Gate → Decode → Residual. This entire cycle repeats n_layer = 6 times.",
      "After all layers, the output is squeezed back to (B, T, D) and projected through lm_head (D → vocab_size = 256) to predict the next byte.",
      "Cross-entropy loss between predictions and targets drives learning — encoders, decoders, attention, and embeddings all co-adapt through backpropagation.",
    ],
    theory: [
      {
        heading: "Layer specialization",
        content:
          "With 6 stacked layers, each processes progressively abstract representations. Early layers tend to capture character-level patterns (byte digraphs, encoding sequences). Later layers capture semantic patterns (word identity, language detection).",
      },
      {
        heading: "Parameter count",
        content:
          "Per layer: 2 encoder matrices (4 × 256 × 8192 each ≈ 8.4M), 1 decoder (32768 × 256 ≈ 8.4M), plus attention buffers. Total: ~25M per layer, ~150M for 6 layers. Modest by modern standards.",
      },
      {
        heading: "Output projection",
        content:
          "lm_head (D=256, vocab=256) maps the final representation to byte probabilities. Training minimizes cross-entropy: −log P(correct_byte), sending gradients through all layers simultaneously.",
      },
    ],
    keyInsight:
      "BDH's power comes from stacking sparse layers. Each layer is individually interpretable — we can read which neurons fire and why — yet together they form a capable multilingual model.",
    code: `x = self.embed(idx).unsqueeze(1)
x = self.ln(x)

for layer_idx in range(n_layer):
    enc, enc_v, dec = get_params(layer_idx)
    x_sparse  = F.relu(x @ enc)           # encode
    yKV       = self.attn(x_sparse, x_sparse, x)
    y_sparse  = F.relu(self.ln(yKV) @ enc_v)
    xy_sparse = x_sparse * y_sparse        # gate
    y = self.ln(xy_sparse.reshape(…) @ dec)
    x = self.ln(x + y)                     # residual

logits = x.squeeze(1) @ self.lm_head`,
  },
];

const DIFF_COLORS: Record<
  string,
  { bg: string; text: string; border: string }
> = {
  Easy: {
    bg: "bg-[#00C896]/10",
    text: "text-[#00C896]",
    border: "border-[#00C896]/20",
  },
  Medium: {
    bg: "bg-amber-900/40",
    text: "text-amber-400",
    border: "border-amber-800/50",
  },
  Hard: {
    bg: "bg-rose-900/40",
    text: "text-rose-400",
    border: "border-rose-800/50",
  },
};

/* ═══════════════════════════════════════════════════════════════
   VISUALIZATIONS — One per architecture step
   ═══════════════════════════════════════════════════════════════ */

/* ---------- 1. Byte Embedding -------------------------------- */
const ByteEmbeddingViz: React.FC = () => {
  const bytes = [
    { val: 66, ch: "B" },
    { val: 111, ch: "o" },
    { val: 110, ch: "n" },
    { val: 106, ch: "j" },
    { val: 111, ch: "o" },
    { val: 117, ch: "u" },
    { val: 114, ch: "r" },
  ];
  const rand = useMemo(() => seededRandom(42), []);
  const vectors = useMemo(
    () => bytes.map(() => Array.from({ length: 16 }, () => rand() * 2 - 1)),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );

  return (
    <div className="flex flex-col items-center gap-6">
      <div className="text-xs text-[#4A5568] tracking-wider">
        "Bonjour" → 7 bytes → 7 embedding vectors (showing 16 of 256 dims)
      </div>
      <div className="flex items-start gap-3 overflow-x-auto pb-2">
        {bytes.map((b, i) => (
          <div
            key={i}
            className="flex flex-col items-center gap-2 min-w-[60px]"
          >
            <div className="flex flex-col items-center">
              <span className="text-lg font-mono text-white font-semibold">
                {b.ch}
              </span>
              <span className="text-[10px] text-[#4A5568] font-mono">
                {b.val}
              </span>
            </div>
            <div className="w-px h-3 bg-white/10" />
            <div className="flex gap-px">
              {vectors[i].map((v, j) => (
                <div
                  key={j}
                  className="w-[3px] rounded-sm"
                  style={{
                    height: `${Math.abs(v) * 28 + 4}px`,
                    backgroundColor:
                      v > 0
                        ? `rgba(52, 211, 153, ${Math.abs(v) * 0.7 + 0.3})`
                        : `rgba(244, 63, 94, ${Math.abs(v) * 0.7 + 0.3})`,
                    marginTop: v > 0 ? `${(1 - Math.abs(v)) * 14}px` : "0px",
                  }}
                />
              ))}
            </div>
            <span className="text-[9px] text-[#4A5568] font-mono">D=256</span>
          </div>
        ))}
      </div>
      <div className="flex items-center gap-4 text-[10px] text-[#4A5568]">
        <span className="flex items-center gap-1">
          <span className="w-2 h-2 rounded-sm bg-[#00C896]/60" /> positive
        </span>
        <span className="flex items-center gap-1">
          <span className="w-2 h-2 rounded-sm bg-rose-400/60" /> negative
        </span>
      </div>
    </div>
  );
};

/* ---------- 2. Sparse Encoding ------------------------------- */
const SparseEncodingViz: React.FC = () => {
  const [showRelu, setShowRelu] = useState(false);
  const rand = useMemo(() => seededRandom(123), []);
  const bars = useMemo(
    () => Array.from({ length: 48 }, () => rand() * 2 - 1),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );

  const activeCount = bars.filter((v) => v > 0).length;
  const sparsity = (((bars.length - activeCount) / bars.length) * 100).toFixed(
    0,
  );

  return (
    <div className="flex flex-col items-center gap-4">
      <div className="flex items-center gap-3">
        <button
          onClick={() => setShowRelu(false)}
          className={`px-3 py-1 text-xs rounded transition-colors ${
            !showRelu
              ? "bg-white/10 text-[#E2E8F0]"
              : "text-[#4A5568] hover:text-[#CBD5E0]"
          }`}
        >
          Before ReLU
        </button>
        <button
          onClick={() => setShowRelu(true)}
          className={`px-3 py-1 text-xs rounded transition-colors ${
            showRelu
              ? "bg-[#00C896]/10 text-[#00C896]"
              : "text-[#4A5568] hover:text-[#CBD5E0]"
          }`}
        >
          After ReLU
        </button>
        {showRelu && (
          <span className="text-xs text-[#00C896] font-mono ml-2">
            sparsity: {sparsity}%
          </span>
        )}
      </div>
      <div className="text-[10px] text-[#4A5568] tracking-wider">
        Showing 48 of 8,192 neurons per head
      </div>
      <div className="relative flex items-end gap-[2px] h-32 px-4">
        <div className="absolute bottom-1/2 left-0 right-0 h-px bg-white/5" />
        {bars.map((v, i) => {
          const value = showRelu ? Math.max(0, v) : v;
          const isZeroed = showRelu && v < 0;
          const absVal = Math.abs(value);
          const height = absVal * 56;
          const isPositive = value >= 0;

          return (
            <div
              key={i}
              className="relative flex flex-col items-center"
              style={{ height: "128px", justifyContent: "center" }}
            >
              <div
                className="w-[5px] rounded-sm transition-all duration-300"
                style={{
                  height: `${isZeroed ? 2 : height + 2}px`,
                  backgroundColor: isZeroed
                    ? "rgb(63, 63, 70)"
                    : isPositive
                      ? `rgba(52, 211, 153, ${absVal * 0.6 + 0.4})`
                      : `rgba(161, 161, 170, ${absVal * 0.6 + 0.3})`,
                  [isPositive ? "marginTop" : "marginBottom"]: "auto",
                  alignSelf: isPositive ? "flex-end" : "flex-start",
                  opacity: isZeroed ? 0.3 : 1,
                }}
              />
            </div>
          );
        })}
      </div>
      <div className="flex items-center gap-2 text-[10px] text-[#4A5568]">
        <span className="font-mono">D=256</span>
        <span>→</span>
        <span className="font-mono">N=8,192</span>
        <span>→</span>
        <span className="font-mono">ReLU</span>
        <span>→</span>
        <span className="font-mono text-[#00C896]">~5% active</span>
      </div>
    </div>
  );
};

/* ---------- 3. RoPE ------------------------------------------ */
const RoPEViz: React.FC = () => {
  const [position, setPosition] = useState(3);
  const freqs = [0.5, 0.15, 0.05];
  const colors = ["#34d399", "#60a5fa", "#fbbf24"];
  const labels = [
    "dim 0–1 (fast)",
    "dim 100–101 (mid)",
    "dim 8000–8001 (slow)",
  ];
  const W = 480;
  const H = 120;

  return (
    <div className="flex flex-col items-center gap-3">
      <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-1">
        Position-dependent phase rotation at three frequencies
      </div>
      <svg width={W} height={H} className="overflow-visible">
        {Array.from({ length: 9 }, (_, i) => (
          <line
            key={`g${i}`}
            x1={i * (W / 8)}
            y1={0}
            x2={i * (W / 8)}
            y2={H}
            stroke="rgb(39,39,42)"
            strokeWidth={1}
          />
        ))}
        <line
          x1={0}
          y1={H / 2}
          x2={W}
          y2={H / 2}
          stroke="rgb(63,63,70)"
          strokeWidth={1}
        />

        {freqs.map((f, fi) => {
          const points = Array.from({ length: W }, (_, px) => {
            const t = (px / W) * 8;
            const y = H / 2 - Math.sin(t * f * Math.PI * 2) * (H / 2 - 8);
            return `${px},${y}`;
          }).join(" ");
          return (
            <polyline
              key={fi}
              points={points}
              fill="none"
              stroke={colors[fi]}
              strokeWidth={1.5}
              opacity={0.7}
            />
          );
        })}

        <line
          x1={position * (W / 8)}
          y1={0}
          x2={position * (W / 8)}
          y2={H}
          stroke="white"
          strokeWidth={1.5}
          strokeDasharray="3,3"
        />
        {freqs.map((f, fi) => {
          const t = position;
          const y = H / 2 - Math.sin(t * f * Math.PI * 2) * (H / 2 - 8);
          return (
            <circle
              key={fi}
              cx={position * (W / 8)}
              cy={y}
              r={4}
              fill={colors[fi]}
              stroke="white"
              strokeWidth={1}
            />
          );
        })}

        {Array.from({ length: 9 }, (_, i) => (
          <text
            key={`l${i}`}
            x={i * (W / 8)}
            y={H + 14}
            textAnchor="middle"
            className="text-[9px] fill-[#4A5568] font-mono"
          >
            t={i}
          </text>
        ))}
      </svg>

      <input
        type="range"
        min={0}
        max={8}
        step={1}
        value={position}
        onChange={(e) => setPosition(Number(e.target.value))}
        className="w-48 accent-[#00C896]"
      />
      <div className="text-[10px] text-[#8B95A5] font-mono">
        position = {position}
      </div>

      <div className="flex gap-4 mt-1">
        {labels.map((l, i) => (
          <span
            key={i}
            className="flex items-center gap-1 text-[10px] text-[#4A5568]"
          >
            <span
              className="w-3 h-[2px] rounded"
              style={{ backgroundColor: colors[i] }}
            />
            {l}
          </span>
        ))}
      </div>
    </div>
  );
};

/* ---------- 4. Linear Attention ------------------------------ */
const LinearAttentionViz: React.FC = () => {
  const [hovered, setHovered] = useState<number | null>(null);
  const tokens = ["B", "o", "n", "j", "o", "u"];
  const n = tokens.length;
  const rand = useMemo(() => seededRandom(77), []);
  const weights = useMemo(
    () =>
      Array.from({ length: n }, (_, i) =>
        Array.from({ length: n }, (_, j) => (j < i ? rand() : 0)),
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );
  const cellSize = 44;

  return (
    <div className="flex flex-col items-center gap-3">
      <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-1">
        Causal attention matrix — lower triangle only (tril)
      </div>
      <div className="flex items-start gap-2">
        <div
          className="flex flex-col items-end justify-start pt-3"
          style={{ marginTop: cellSize + 4 }}
        >
          {tokens.map((t, i) => (
            <div
              key={i}
              className={`font-mono text-xs flex items-center justify-center transition-colors ${
                hovered === i ? "text-[#00C896]" : "text-[#4A5568]"
              }`}
              style={{ height: cellSize }}
            >
              {t}
            </div>
          ))}
        </div>

        <div>
          <div className="flex" style={{ paddingLeft: 0 }}>
            {tokens.map((t, i) => (
              <div
                key={i}
                className="font-mono text-xs text-[#4A5568] flex items-center justify-center"
                style={{ width: cellSize, height: cellSize * 0.6 }}
              >
                {t}
              </div>
            ))}
          </div>

          <div className="border border-white/[0.06] rounded">
            {weights.map((row, i) => (
              <div key={i} className="flex">
                {row.map((w, j) => {
                  const isCausal = j < i;
                  const isHighlighted = hovered === i;
                  return (
                    <div
                      key={j}
                      className="border border-white/[0.06] flex items-center justify-center text-[9px] font-mono transition-all cursor-default"
                      style={{
                        width: cellSize,
                        height: cellSize,
                        backgroundColor: isCausal
                          ? `rgba(52, 211, 153, ${w * (isHighlighted ? 1 : 0.65)})`
                          : i === j
                            ? "rgba(63, 63, 70, 0.3)"
                            : "rgba(24, 24, 27, 0.5)",
                      }}
                      onMouseEnter={() => setHovered(i)}
                      onMouseLeave={() => setHovered(null)}
                    >
                      {isCausal ? (
                        <span
                          className={
                            isHighlighted
                              ? "text-[#E2E8F0]"
                              : "text-[#00C896]/80/60"
                          }
                        >
                          {w.toFixed(2)}
                        </span>
                      ) : i === j ? (
                        <span className="text-[#4A5568]">—</span>
                      ) : (
                        <span className="text-[#374151]">0</span>
                      )}
                    </div>
                  );
                })}
              </div>
            ))}
          </div>
        </div>
      </div>
      <div className="flex items-center gap-4 text-[10px] text-[#4A5568] mt-1">
        <span className="flex items-center gap-1">
          <span className="w-3 h-3 rounded-sm bg-[#00C896]/50" />
          attends (j &lt; i)
        </span>
        <span className="flex items-center gap-1">
          <span className="w-3 h-3 rounded-sm bg-white/[0.03] border border-white/10" />
          masked (j ≥ i)
        </span>
        <span className="text-[#4A5568]">hover a row to highlight</span>
      </div>
    </div>
  );
};

/* ---------- 5. Value Encoding -------------------------------- */
const ValueEncodingViz: React.FC = () => {
  const steps = [
    {
      label: "yKV",
      dims: "D=256",
      desc: "Attention output",
      color: "border-sky-700 bg-sky-900/20",
    },
    {
      label: "LN",
      dims: "",
      desc: "LayerNorm",
      color: "border-white/10 bg-white/[0.04]",
    },
    {
      label: "@ enc_v",
      dims: "D→N",
      desc: "Second encoder",
      color: "border-amber-700 bg-amber-900/20",
    },
    {
      label: "ReLU",
      dims: "",
      desc: "Sparsify",
      color: "border-[#00C896]/30 bg-[#00C896]/8",
    },
    {
      label: "y_sparse",
      dims: "N=8192",
      desc: "Context features",
      color: "border-[#00C896]/40 bg-[#00C896]/8",
    },
  ];

  return (
    <div className="flex flex-col items-center gap-4">
      <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-1">
        Second encoding path: attended values → sparse neuron space
      </div>
      <div className="flex items-center gap-2 flex-wrap justify-center">
        {steps.map((s, i) => (
          <React.Fragment key={i}>
            <div
              className={`border rounded-lg px-4 py-3 text-center ${s.color}`}
            >
              <div className="text-sm font-mono text-[#E2E8F0]">{s.label}</div>
              {s.dims && (
                <div className="text-[10px] text-[#8B95A5] font-mono mt-0.5">
                  {s.dims}
                </div>
              )}
              <div className="text-[10px] text-[#4A5568] mt-1">{s.desc}</div>
            </div>
            {i < steps.length - 1 && (
              <span className="text-[#4A5568] text-lg">→</span>
            )}
          </React.Fragment>
        ))}
      </div>
      <div className="text-[10px] text-[#4A5568] mt-1">
        Creates the second independent sparse representation needed for gating
      </div>
    </div>
  );
};

/* ---------- 6. Sparse Gating --------------------------------- */
const SparseGatingViz: React.FC = () => {
  const rand = useMemo(() => seededRandom(55), []);
  const n = 14;
  const xSparse = useMemo(
    () =>
      Array.from({ length: n }, () =>
        rand() > 0.6 ? +(rand() * 0.8 + 0.2).toFixed(1) : 0,
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );
  const ySparse = useMemo(
    () =>
      Array.from({ length: n }, () =>
        rand() > 0.55 ? +(rand() * 0.8 + 0.2).toFixed(1) : 0,
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );
  const gated = xSparse.map((x, i) => +(x * ySparse[i]).toFixed(2));

  const xActive = xSparse.filter((v) => v > 0).length;
  const yActive = ySparse.filter((v) => v > 0).length;
  const gatedActive = gated.filter((v) => v > 0).length;

  const BarRow = ({
    values,
    color,
    label,
    count,
  }: {
    values: number[];
    color: string;
    label: string;
    count: number;
  }) => (
    <div className="flex items-center gap-3">
      <div className="w-20 text-right">
        <span className="text-xs text-[#8B95A5] font-mono">{label}</span>
        <span className="text-[10px] text-[#4A5568] ml-1">
          ({count}/{n})
        </span>
      </div>
      <div className="flex gap-[3px]">
        {values.map((v, i) => (
          <div
            key={i}
            className="w-6 h-8 rounded-sm flex items-end justify-center transition-all"
            style={{
              backgroundColor: v > 0 ? color : "rgb(39, 39, 42)",
              opacity: v > 0 ? v * 0.6 + 0.4 : 0.4,
            }}
          >
            {v > 0 && (
              <span className="text-[7px] text-[#E2E8F0]/80 font-mono mb-0.5">
                {v.toFixed(1)}
              </span>
            )}
          </div>
        ))}
      </div>
    </div>
  );

  return (
    <div className="flex flex-col items-center gap-2">
      <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-2">
        Element-wise multiplication: both must be active to survive
      </div>
      <BarRow
        values={xSparse}
        color="rgba(52, 211, 153, 0.7)"
        label="x_sparse"
        count={xActive}
      />
      <div className="text-[#4A5568] text-lg font-mono ml-20">×</div>
      <BarRow
        values={ySparse}
        color="rgba(96, 165, 250, 0.7)"
        label="y_sparse"
        count={yActive}
      />
      <div className="text-[#4A5568] text-lg font-mono ml-20">=</div>
      <BarRow
        values={gated}
        color="rgba(251, 191, 36, 0.7)"
        label="gated"
        count={gatedActive}
      />
      <div className="text-[10px] text-[#4A5568] mt-2">
        {xActive} active × {yActive} active → only{" "}
        <span className="text-amber-400 font-semibold">
          {gatedActive} survive
        </span>{" "}
        the gate
      </div>
    </div>
  );
};

/* ---------- 7. Decode + Residual ----------------------------- */
const DecodeResidualViz: React.FC = () => (
  <div className="flex flex-col items-center gap-4">
    <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-1">
      Compress sparse code back to embedding space + skip connection
    </div>

    <div className="relative flex items-center gap-2 max-w-xl mx-auto flex-wrap justify-center">
      {/* Input */}
      <div className="border border-white/10 rounded px-3 py-2 bg-white/[0.04] text-center min-w-[56px]">
        <div className="text-xs font-mono text-[#CBD5E0]">x</div>
        <div className="text-[9px] text-[#4A5568]">D=256</div>
      </div>

      <span className="text-[#4A5568] text-sm">→</span>

      {/* Gated sparse */}
      <div className="border border-amber-800/50 rounded px-3 py-2 bg-amber-900/20 text-center">
        <div className="text-xs font-mono text-amber-300">xy_sparse</div>
        <div className="text-[9px] text-[#4A5568]">nh×N = 32,768</div>
      </div>

      <span className="text-[#4A5568] text-sm">→</span>

      {/* Decoder */}
      <div className="border border-white/[0.12] rounded px-3 py-2 bg-white/[0.05] text-center">
        <div className="text-xs font-mono text-[#CBD5E0]">@ dec</div>
        <div className="text-[9px] text-[#4A5568]">N→D</div>
      </div>

      <span className="text-[#4A5568] text-sm">→</span>

      {/* LN */}
      <div className="border border-white/10 rounded px-2 py-2 bg-white/[0.04] text-center">
        <div className="text-xs font-mono text-[#CBD5E0]">LN</div>
      </div>

      <span className="text-[#4A5568] text-sm font-mono">+x</span>

      <span className="text-[#4A5568] text-sm">→</span>

      {/* Output */}
      <div className="border border-[#00C896]/30 rounded px-3 py-2 bg-[#00C896]/8 text-center">
        <div className="text-xs font-mono text-[#00C896]">output</div>
        <div className="text-[9px] text-[#4A5568]">D=256</div>
      </div>
    </div>

    <div className="flex items-center gap-2 text-[10px] text-[#4A5568] mt-2">
      <span className="font-mono">32,768</span>
      <span>→ 128× compression →</span>
      <span className="font-mono text-[#00C896]">256</span>
      <span className="text-[#374151] mx-2">|</span>
      <span className="text-[#4A5568]">
        + residual skip keeps gradient flow
      </span>
    </div>
  </div>
);

/* ---------- 8. Full BDH Layer -------------------------------- */
const FullLayerViz: React.FC = () => {
  const pipeline = [
    {
      label: "Embed",
      dim: "D",
      color: "border-white/[0.12] bg-white/[0.04]",
      text: "text-[#CBD5E0]",
    },
    {
      label: "Encode",
      dim: "D→N",
      color: "border-sky-700 bg-sky-900/20",
      text: "text-sky-300",
    },
    {
      label: "ReLU",
      dim: "N",
      color: "border-[#00C896]/30 bg-[#00C896]/8",
      text: "text-[#00C896]",
    },
    {
      label: "Attend",
      dim: "T×T",
      color: "border-[#2A7FFF]/30 bg-[#2A7FFF]/10",
      text: "text-[#2A7FFF]",
    },
    {
      label: "Enc V",
      dim: "D→N",
      color: "border-amber-700 bg-amber-900/20",
      text: "text-amber-300",
    },
    {
      label: "Gate",
      dim: "N",
      color: "border-amber-600 bg-amber-900/30",
      text: "text-amber-300",
    },
    {
      label: "Decode",
      dim: "N→D",
      color: "border-[#00C896]/40 bg-[#00C896]/8",
      text: "text-[#00C896]",
    },
  ];

  return (
    <div className="flex flex-col items-center gap-4">
      <div className="text-[10px] text-[#4A5568] tracking-wider uppercase mb-1">
        Complete BDH layer pipeline — repeated 6 times
      </div>

      <div className="flex items-center gap-1.5 flex-wrap justify-center">
        {pipeline.map((p, i) => (
          <React.Fragment key={i}>
            <div
              className={`border rounded-lg px-3 py-2 text-center ${p.color}`}
            >
              <div className={`text-xs font-mono font-medium ${p.text}`}>
                {p.label}
              </div>
              <div className="text-[9px] text-[#4A5568] font-mono mt-0.5">
                {p.dim}
              </div>
            </div>
            {i < pipeline.length - 1 && (
              <span className="text-[#374151] text-sm">→</span>
            )}
          </React.Fragment>
        ))}
        <span className="text-[#4A5568] text-sm ml-1">+ res</span>
      </div>

      <div className="flex items-center gap-2 mt-2">
        <span className="text-[10px] text-[#4A5568]">×6 layers:</span>
        {Array.from({ length: 6 }, (_, i) => (
          <div
            key={i}
            className="w-8 h-5 rounded border border-white/10 bg-white/[0.05] flex items-center justify-center"
          >
            <span className="text-[9px] font-mono text-[#8B95A5]">L{i}</span>
          </div>
        ))}
        <span className="text-[#374151] text-sm ml-1">→</span>
        <div className="border border-[#00C896]/30 rounded px-2 py-0.5 bg-[#00C896]/8">
          <span className="text-[10px] font-mono text-[#00C896]">lm_head</span>
        </div>
      </div>

      <div className="text-[10px] text-[#4A5568] mt-1">
        Early layers → syntax &amp; phonetics · Later layers → semantics &amp;
        language identity
      </div>
    </div>
  );
};

/* ═══════════════════════════════════════════════════════════════
   STEP VISUALIZATION ROUTER
   ═══════════════════════════════════════════════════════════════ */
const vizComponents: Record<number, React.FC> = {
  1: ByteEmbeddingViz,
  2: SparseEncodingViz,
  3: RoPEViz,
  4: LinearAttentionViz,
  5: ValueEncodingViz,
  6: SparseGatingViz,
  7: DecodeResidualViz,
  8: FullLayerViz,
};

const StepVisualization: React.FC<{ stepId: number }> = ({ stepId }) => {
  const Viz = vizComponents[stepId];
  return Viz ? <Viz /> : null;
};

/* ═══════════════════════════════════════════════════════════════
   MAIN COMPONENT
   ═══════════════════════════════════════════════════════════════ */
export function LearnBDHPage() {
  const [currentStep, setCurrentStep] = useState(0);
  const [activeTab, setActiveTab] = useState<"description" | "theory">(
    "description",
  );

  const step = STEPS[currentStep];
  const diff = DIFF_COLORS[step.difficulty];

  const goNext = useCallback(() => {
    if (currentStep < STEPS.length - 1) {
      setCurrentStep((s) => s + 1);
      setActiveTab("description");
    }
  }, [currentStep]);

  const goPrev = useCallback(() => {
    if (currentStep > 0) {
      setCurrentStep((s) => s - 1);
      setActiveTab("description");
    }
  }, [currentStep]);

  return (
    <div className="flex h-full min-h-0" style={{ background: "#070D12" }}>
      {/* ── Sidebar ── */}
      <aside className="w-72 shrink-0 border-r border-white/[0.06] bg-[#0B1216] flex flex-col">
        <div className="px-6 pt-6 pb-4">
          <h2 className="text-sm font-semibold text-[#E2E8F0] tracking-tight">
            Learn BDH
          </h2>
          <p className="text-[11px] text-[#4A5568] mt-0.5">
            8 architecture steps
          </p>
        </div>

        <nav className="flex-1 overflow-y-auto px-3 pb-4">
          {STEPS.map((s, i) => {
            const isActive = i === currentStep;
            return (
              <button
                key={s.id}
                onClick={() => {
                  setCurrentStep(i);
                  setActiveTab("description");
                }}
                className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg mb-0.5 text-left transition-colors ${
                  isActive ? "bg-white/[0.06]" : "hover:bg-white/[0.04]"
                }`}
              >
                <span
                  className={`shrink-0 w-7 h-7 rounded-full flex items-center justify-center text-xs font-mono font-medium border transition-colors ${
                    isActive
                      ? "bg-[#00C896] border-[#00C896] text-[#E2E8F0]"
                      : "border-white/10 text-[#4A5568] bg-[#0B1216]"
                  }`}
                >
                  {s.id}
                </span>
                <span
                  className={`text-sm truncate transition-colors ${
                    isActive ? "text-white font-medium" : "text-[#8B95A5]"
                  }`}
                >
                  {s.title}
                </span>
              </button>
            );
          })}
        </nav>
      </aside>

      {/* ── Main content ── */}
      <main className="flex-1 overflow-y-auto">
        <AnimatePresence mode="wait">
          <motion.div
            key={step.id}
            initial={{ opacity: 0, y: 8 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -8 }}
            transition={{ duration: 0.2 }}
            className="max-w-4xl mx-auto px-8 py-8"
          >
            {/* ── Header ── */}
            <div className="flex items-center gap-3 mb-1">
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-mono font-medium bg-[#00C896]/10 text-[#00C896] border border-[#00C896]/20">
                {String(step.id).padStart(2, "0")}/
                {String(STEPS.length).padStart(2, "0")}
              </span>
              <h1 className="text-2xl font-semibold text-[#E2E8F0] tracking-tight">
                {step.title}
              </h1>
              <span
                className={`ml-auto inline-flex items-center px-2.5 py-0.5 rounded-full text-[11px] font-medium border ${diff.bg} ${diff.text} ${diff.border}`}
              >
                {step.difficulty}
              </span>
            </div>
            <p className="text-sm text-[#4A5568] mb-6">{step.subtitle}</p>

            {/* ── Tabs ── */}
            <div className="flex gap-1 mb-6 border-b border-white/[0.06] pb-px">
              {(["description", "theory"] as const).map((tab) => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  className={`px-4 py-2 text-sm capitalize rounded-t transition-colors ${
                    activeTab === tab
                      ? "bg-white/[0.05] text-[#E2E8F0] border-b-2 border-[#00C896]"
                      : "text-[#4A5568] hover:text-[#CBD5E0]"
                  }`}
                >
                  {tab}
                </button>
              ))}
            </div>

            {/* ── Tab content ── */}
            {activeTab === "description" ? (
              <div>
                {/* Visualization card */}
                <div className="border border-white/[0.06] rounded-xl bg-[#0B1216]/60 p-6 mb-8">
                  <span className="text-[10px] uppercase tracking-widest text-[#4A5568] block mb-5">
                    Visualization
                  </span>
                  <StepVisualization stepId={step.id} />
                </div>

                {/* Description */}
                <div className="space-y-3 mb-8">
                  {step.description.map((p, i) => (
                    <p
                      key={i}
                      className="text-sm text-[#CBD5E0] leading-relaxed"
                    >
                      {p}
                    </p>
                  ))}
                </div>

                {/* Key insight */}
                <div className="border-l-2 border-[#00C896]/40 pl-4 py-2 bg-[#00C896]/5 rounded-r">
                  <span className="text-[10px] uppercase tracking-widest text-[#00C896]/70 block mb-1">
                    Key Insight
                  </span>
                  <p className="text-sm text-[#00C896]/80/80 leading-relaxed">
                    {step.keyInsight}
                  </p>
                </div>
              </div>
            ) : (
              <div>
                {/* Theory sections */}
                <div className="space-y-6 mb-8">
                  {step.theory.map((t, i) => (
                    <div key={i}>
                      <h3 className="text-sm font-medium text-[#E2E8F0] mb-1.5">
                        {t.heading}
                      </h3>
                      <p className="text-sm text-[#8B95A5] leading-relaxed">
                        {t.content}
                      </p>
                    </div>
                  ))}
                </div>

                {/* Code snippet */}
                <div className="border border-white/[0.06] rounded-xl overflow-hidden">
                  <div className="flex items-center gap-2 px-4 py-2 bg-[#0B1216]/80 border-b border-white/[0.06]">
                    <span className="text-[10px] uppercase tracking-widest text-[#4A5568]">
                      Source — bdh.py
                    </span>
                  </div>
                  <pre className="px-5 py-4 text-[13px] leading-relaxed font-mono text-[#CBD5E0] overflow-x-auto bg-[#070D12]/60">
                    {step.code}
                  </pre>
                </div>
              </div>
            )}

            {/* ── Navigation ── */}
            <div className="flex items-center justify-between mt-10 pt-6 border-t border-white/[0.06]/60">
              <button
                onClick={goPrev}
                disabled={currentStep === 0}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm transition-colors ${
                  currentStep === 0
                    ? "text-[#374151] cursor-not-allowed"
                    : "text-[#8B95A5] hover:text-[#E2E8F0] hover:bg-white/[0.05]"
                }`}
              >
                <ChevronLeft size={16} />
                {currentStep > 0 ? STEPS[currentStep - 1].title : "Previous"}
              </button>

              <div className="flex gap-1.5">
                {STEPS.map((_, i) => (
                  <button
                    key={i}
                    onClick={() => {
                      setCurrentStep(i);
                      setActiveTab("description");
                    }}
                    className={`w-2 h-2 rounded-full transition-colors ${
                      i === currentStep
                        ? "bg-[#00C896]"
                        : "bg-white/10 hover:bg-white/20"
                    }`}
                  />
                ))}
              </div>

              <button
                onClick={goNext}
                disabled={currentStep === STEPS.length - 1}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm transition-colors ${
                  currentStep === STEPS.length - 1
                    ? "text-[#374151] cursor-not-allowed"
                    : "text-[#8B95A5] hover:text-[#E2E8F0] hover:bg-white/[0.05]"
                }`}
              >
                {currentStep < STEPS.length - 1
                  ? STEPS[currentStep + 1].title
                  : "Next"}
                <ChevronRight size={16} />
              </button>
            </div>
          </motion.div>
        </AnimatePresence>
      </main>
    </div>
  );
}

